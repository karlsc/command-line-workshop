../workspace/.c9/metadata/workspace/Gruntfile.js:{"filter":false,"title":"Gruntfile.js","tooltip":"/Gruntfile.js","undoManager":{"mark":7,"position":7,"stack":[[{"start":{"row":205,"column":2},"end":{"row":205,"column":3},"action":"insert","lines":["é"],"id":2}],[{"start":{"row":205,"column":3},"end":{"row":205,"column":4},"action":"insert","lines":["é"],"id":3}],[{"start":{"row":205,"column":3},"end":{"row":205,"column":4},"action":"remove","lines":["é"],"id":4}],[{"start":{"row":205,"column":2},"end":{"row":205,"column":3},"action":"remove","lines":["é"],"id":5}],[{"start":{"row":205,"column":2},"end":{"row":205,"column":3},"action":"insert","lines":["/"],"id":6}],[{"start":{"row":205,"column":3},"end":{"row":205,"column":4},"action":"insert","lines":["/"],"id":7}],[{"start":{"row":208,"column":58},"end":{"row":208,"column":74},"action":"remove","lines":["'imagemin:dist',"],"id":8}],[{"start":{"row":208,"column":57},"end":{"row":208,"column":58},"action":"remove","lines":[" "],"id":9}]]},"ace":{"folds":[],"scrolltop":2521,"scrollleft":0,"selection":{"start":{"row":208,"column":57},"end":{"row":208,"column":57},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":{"row":179,"state":"start","mode":"ace/mode/javascript"}},"timestamp":1441737548831,"hash":"11b6cda3f8e0dd330b6ca2ce141df907e92ab059"}
../workspace/src/_layouts/default.html:        <a href="javascript:void(0)" class="main-nav__link">Courses</a>
../workspace/src/_data/fulltime_curriculum.json:            "JavaScript and JSON Review",
../workspace/src/_data/fulltime_curriculum.json:            "Trying mobile development using JavaScript with React Native",
../workspace/src/_data/fulltime_learn.json:      "icon": "/assets/images/full-time/javascript.png",
../workspace/src/_data/fulltime_learn.json:      "title": "JavaScript",
../workspace/src/_config.yml:  Learn HTML, CSS, & Javascript in just 8 weeks. Click here for more info.
../workspace/src/on-demand/index.html:      <li>The very fundamentals of JavaScript</li>
../workspace/src/on-demand/index.html:<section class="javascript-frontend">
../workspace/src/on-demand/index.html:    <h2>Javascript &amp; jQuery</h2>
../workspace/src/on-demand/index.html:      JavaScript originated as a language to add dynamic functionality to a web page. Over the years, it has evolved into
../workspace/src/on-demand/index.html:      Even though this part of the preparatory material deals with JavaScript from a front-end perspective, a lot of the
../workspace/src/on-demand/index.html:      general programming concepts will apply on the back-end as well when we look at NodeJS. Since JavaScript is an integral
../workspace/src/on-demand/index.html:        <h3><a target="_blank" href="http://www.codecademy.com/tracks/javascript">Codecademy's JavaScript track</a></h3>
../workspace/src/on-demand/index.html:    <h2>NodeJS: JavaScript for the back-end</h2>
../workspace/src/on-demand/index.html:      Now that you have completed the section on JavaScript and jQuery, you should be somewhat introduced to the JavaScript
../workspace/src/on-demand/index.html:      JavaScript deals more with UI logic, and less with data and I/O (input/output). On the back-end side, we will be
../workspace/src/on-demand/index.html:      using JavaScript to talk to databases and other back-ends (APIs).
../workspace/src/on-demand/index.html:      In JavaScript, all these I/O operations happen <strong>asynchronously</strong>, almost like sending a message in
../workspace/src/on-demand/index.html:      a bottle. This section introduces you to some of the concepts that will come up when doing JavaScript on the
../workspace/src/on-demand/index.html:          <a target="_blank" href="http://javascriptissexy.com/understand-javascript-callback-functions-and-use-them/">Understanding
../workspace/src/on-demand/index.html:            JavaScript Callback Functions</a>
../workspace/src/on-demand/index.html:          <a target="_blank" href="https://functionwhatwhat.com/introduction-to-promises-in-javascript/">Introduction to Promises in
../workspace/src/on-demand/index.html:            JavaScript</a>
../workspace/src/assets/js/app-bundle.js:	 * jQuery JavaScript Library v1.11.3
../workspace/src/assets/js/app-bundle.js:		// http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context
../workspace/src/assets/js/app-bundle.js:								// http://javascript.nwbox.com/IEContentLoaded/
../workspace/src/assets/js/app-bundle.js:					// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
../workspace/src/assets/js/app-bundle.js:				json: "application/json, text/javascript"
../workspace/src/assets/js/app-bundle.js:			script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
../workspace/src/assets/js/app-bundle.js:	module.exports = "/** @jsx React.DOM *//*!\n * Parse JavaScript SDK\n * Version: 1.5.0\n * Built: Fri Jul 10 2015 17:05:46\n * http://parse.com\n *\n * Copyright 2015 Parse, LLC\n *\n * Includes: Underscore.js\n * Copyright 2009-2012 Jeremy Ashkenas, DocumentCloud Inc.\n * Released under the MIT license.\n */\n(function(root) {\n  root.Parse = root.Parse || {};\n  root.Parse.VERSION = \"js1.5.0\";\n}(this));\n//     Underscore.js 1.4.4\n//     http://underscorejs.org\n//     (c) 2009-2013 Jeremy Ashkenas, DocumentCloud Inc.\n//     Underscore may be freely distributed under the MIT license.\n\n(function() {\n\n  // Baseline setup\n  // --------------\n\n  // Establish the root object, `window` in the browser, or `global` on the server.\n  var root = this;\n\n  // Save the previous value of the `_` variable.\n  var previousUnderscore = root._;\n\n  // Establish the object that gets returned to break out of a loop iteration.\n  var breaker = {};\n\n  // Save bytes in the minified (but not gzipped) version:\n  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;\n\n  // Create quick reference variables for speed access to core prototypes.\n  var push             = ArrayProto.push,\n      slice            = ArrayProto.slice,\n      concat           = ArrayProto.concat,\n      toString         = ObjProto.toString,\n      hasOwnProperty   = ObjProto.hasOwnProperty;\n\n  // All **ECMAScript 5** native function implementations that we hope to use\n  // are declared here.\n  var\n    nativeForEach      = ArrayProto.forEach,\n    nativeMap          = ArrayProto.map,\n    nativeReduce       = ArrayProto.reduce,\n    nativeReduceRight  = ArrayProto.reduceRight,\n    nativeFilter       = ArrayProto.filter,\n    nativeEvery        = ArrayProto.every,\n    nativeSome         = ArrayProto.some,\n    nativeIndexOf      = ArrayProto.indexOf,\n    nativeLastIndexOf  = ArrayProto.lastIndexOf,\n    nativeIsArray      = Array.isArray,\n    nativeKeys         = Object.keys,\n    nativeBind         = FuncProto.bind;\n\n  // Create a safe reference to the Underscore object for use below.\n  var _ = function(obj) {\n    if (obj instanceof _) return obj;\n    if (!(this instanceof _)) return new _(obj);\n    this._wrapped = obj;\n  };\n\n  // Export the Underscore object for **Node.js**, with\n  // backwards-compatibility for the old `require()` API. If we're in\n  // the browser, add `_` as a global object via a string identifier,\n  // for Closure Compiler \"advanced\" mode.\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = _;\n    }\n    exports._ = _;\n  } else {\n    root._ = _;\n  }\n\n  // Current version.\n  _.VERSION = '1.4.4';\n\n  // Collection Functions\n  // --------------------\n\n  // The cornerstone, an `each` implementation, aka `forEach`.\n  // Handles objects with the built-in `forEach`, arrays, and raw objects.\n  // Delegates to **ECMAScript 5**'s native `forEach` if available.\n  var each = _.each = _.forEach = function(obj, iterator, context) {\n    if (obj == null) return;\n    if (nativeForEach && obj.forEach === nativeForEach) {\n      obj.forEach(iterator, context);\n    } else if (obj.length === +obj.length) {\n      for (var i = 0, l = obj.length; i < l; i++) {\n        if (iterator.call(context, obj[i], i, obj) === breaker) return;\n      }\n    } else {\n      for (var key in obj) {\n        if (_.has(obj, key)) {\n          if (iterator.call(context, obj[key], key, obj) === breaker) return;\n        }\n      }\n    }\n  };\n\n  // Return the results of applying the iterator to each element.\n  // Delegates to **ECMAScript 5**'s native `map` if available.\n  _.map = _.collect = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);\n    each(obj, function(value, index, list) {\n      results[results.length] = iterator.call(context, value, index, list);\n    });\n    return results;\n  };\n\n  var reduceError = 'Reduce of empty array with no initial value';\n\n  // **Reduce** builds up a single result from a list of values, aka `inject`,\n  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.\n  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {\n    var initial = arguments.length > 2;\n    if (obj == null) obj = [];\n    if (nativeReduce && obj.reduce === nativeReduce) {\n      if (context) iterator = _.bind(iterator, context);\n      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);\n    }\n    each(obj, function(value, index, list) {\n      if (!initial) {\n        memo = value;\n        initial = true;\n      } else {\n        memo = iterator.call(context, memo, value, index, list);\n      }\n    });\n    if (!initial) throw new TypeError(reduceError);\n    return memo;\n  };\n\n  // The right-associative version of reduce, also known as `foldr`.\n  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.\n  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {\n    var initial = arguments.length > 2;\n    if (obj == null) obj = [];\n    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {\n      if (context) iterator = _.bind(iterator, context);\n      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);\n    }\n    var length = obj.length;\n    if (length !== +length) {\n      var keys = _.keys(obj);\n      length = keys.length;\n    }\n    each(obj, function(value, index, list) {\n      index = keys ? keys[--length] : --length;\n      if (!initial) {\n        memo = obj[index];\n        initial = true;\n      } else {\n        memo = iterator.call(context, memo, obj[index], index, list);\n      }\n    });\n    if (!initial) throw new TypeError(reduceError);\n    return memo;\n  };\n\n  // Return the first value which passes a truth test. Aliased as `detect`.\n  _.find = _.detect = function(obj, iterator, context) {\n    var result;\n    any(obj, function(value, index, list) {\n      if (iterator.call(context, value, index, list)) {\n        result = value;\n        return true;\n      }\n    });\n    return result;\n  };\n\n  // Return all the elements that pass a truth test.\n  // Delegates to **ECMAScript 5**'s native `filter` if available.\n  // Aliased as `select`.\n  _.filter = _.select = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);\n    each(obj, function(value, index, list) {\n      if (iterator.call(context, value, index, list)) results[results.length] = value;\n    });\n    return results;\n  };\n\n  // Return all the elements for which a truth test fails.\n  _.reject = function(obj, iterator, context) {\n    return _.filter(obj, function(value, index, list) {\n      return !iterator.call(context, value, index, list);\n    }, context);\n  };\n\n  // Determine whether all of the elements match a truth test.\n  // Delegates to **ECMAScript 5**'s native `every` if available.\n  // Aliased as `all`.\n  _.every = _.all = function(obj, iterator, context) {\n    iterator || (iterator = _.identity);\n    var result = true;\n    if (obj == null) return result;\n    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);\n    each(obj, function(value, index, list) {\n      if (!(result = result && iterator.call(context, value, index, list))) return breaker;\n    });\n    return !!result;\n  };\n\n  // Determine if at least one element in the object matches a truth test.\n  // Delegates to **ECMAScript 5**'s native `some` if available.\n  // Aliased as `any`.\n  var any = _.some = _.any = function(obj, iterator, context) {\n    iterator || (iterator = _.identity);\n    var result = false;\n    if (obj == null) return result;\n    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);\n    each(obj, function(value, index, list) {\n      if (result || (result = iterator.call(context, value, index, list))) return breaker;\n    });\n    return !!result;\n  };\n\n  // Determine if the array or object contains a given value (using `===`).\n  // Aliased as `include`.\n  _.contains = _.include = function(obj, target) {\n    if (obj == null) return false;\n    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;\n    return any(obj, function(value) {\n      return value === target;\n    });\n  };\n\n  // Invoke a method (with arguments) on every item in a collection.\n  _.invoke = function(obj, method) {\n    var args = slice.call(arguments, 2);\n    var isFunc = _.isFunction(method);\n    return _.map(obj, function(value) {\n      return (isFunc ? method : value[method]).apply(value, args);\n    });\n  };\n\n  // Convenience version of a common use case of `map`: fetching a property.\n  _.pluck = function(obj, key) {\n    return _.map(obj, function(value){ return value[key]; });\n  };\n\n  // Convenience version of a common use case of `filter`: selecting only objects\n  // containing specific `key:value` pairs.\n  _.where = function(obj, attrs, first) {\n    if (_.isEmpty(attrs)) return first ? null : [];\n    return _[first ? 'find' : 'filter'](obj, function(value) {\n      for (var key in attrs) {\n        if (attrs[key] !== value[key]) return false;\n      }\n      return true;\n    });\n  };\n\n  // Convenience version of a common use case of `find`: getting the first object\n  // containing specific `key:value` pairs.\n  _.findWhere = function(obj, attrs) {\n    return _.where(obj, attrs, true);\n  };\n\n  // Return the maximum element or (element-based computation).\n  // Can't optimize arrays of integers longer than 65,535 elements.\n  // See: https://bugs.webkit.org/show_bug.cgi?id=80797\n  _.max = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {\n      return Math.max.apply(Math, obj);\n    }\n    if (!iterator && _.isEmpty(obj)) return -Infinity;\n    var result = {computed : -Infinity, value: -Infinity};\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      computed >= result.computed && (result = {value : value, computed : computed});\n    });\n    return result.value;\n  };\n\n  // Return the minimum element (or element-based computation).\n  _.min = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {\n      return Math.min.apply(Math, obj);\n    }\n    if (!iterator && _.isEmpty(obj)) return Infinity;\n    var result = {computed : Infinity, value: Infinity};\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      computed < result.computed && (result = {value : value, computed : computed});\n    });\n    return result.value;\n  };\n\n  // Shuffle an array.\n  _.shuffle = function(obj) {\n    var rand;\n    var index = 0;\n    var shuffled = [];\n    each(obj, function(value) {\n      rand = _.random(index++);\n      shuffled[index - 1] = shuffled[rand];\n      shuffled[rand] = value;\n    });\n    return shuffled;\n  };\n\n  // An internal function to generate lookup iterators.\n  var lookupIterator = function(value) {\n    return _.isFunction(value) ? value : function(obj){ return obj[value]; };\n  };\n\n  // Sort the object's values by a criterion produced by an iterator.\n  _.sortBy = function(obj, value, context) {\n    var iterator = lookupIterator(value);\n    return _.pluck(_.map(obj, function(value, index, list) {\n      return {\n        value : value,\n        index : index,\n        criteria : iterator.call(context, value, index, list)\n      };\n    }).sort(function(left, right) {\n      var a = left.criteria;\n      var b = right.criteria;\n      if (a !== b) {\n        if (a > b || a === void 0) return 1;\n        if (a < b || b === void 0) return -1;\n      }\n      return left.index < right.index ? -1 : 1;\n    }), 'value');\n  };\n\n  // An internal function used for aggregate \"group by\" operations.\n  var group = function(obj, value, context, behavior) {\n    var result = {};\n    var iterator = lookupIterator(value || _.identity);\n    each(obj, function(value, index) {\n      var key = iterator.call(context, value, index, obj);\n      behavior(result, key, value);\n    });\n    return result;\n  };\n\n  // Groups the object's values by a criterion. Pass either a string attribute\n  // to group by, or a function that returns the criterion.\n  _.groupBy = function(obj, value, context) {\n    return group(obj, value, context, function(result, key, value) {\n      (_.has(result, key) ? result[key] : (result[key] = [])).push(value);\n    });\n  };\n\n  // Counts instances of an object that group by a certain criterion. Pass\n  // either a string attribute to count by, or a function that returns the\n  // criterion.\n  _.countBy = function(obj, value, context) {\n    return group(obj, value, context, function(result, key) {\n      if (!_.has(result, key)) result[key] = 0;\n      result[key]++;\n    });\n  };\n\n  // Use a comparator function to figure out the smallest index at which\n  // an object should be inserted so as to maintain order. Uses binary search.\n  _.sortedIndex = function(array, obj, iterator, context) {\n    iterator = iterator == null ? _.identity : lookupIterator(iterator);\n    var value = iterator.call(context, obj);\n    var low = 0, high = array.length;\n    while (low < high) {\n      var mid = (low + high) >>> 1;\n      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;\n    }\n    return low;\n  };\n\n  // Safely convert anything iterable into a real, live array.\n  _.toArray = function(obj) {\n    if (!obj) return [];\n    if (_.isArray(obj)) return slice.call(obj);\n    if (obj.length === +obj.length) return _.map(obj, _.identity);\n    return _.values(obj);\n  };\n\n  // Return the number of elements in an object.\n  _.size = function(obj) {\n    if (obj == null) return 0;\n    return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;\n  };\n\n  // Array Functions\n  // ---------------\n\n  // Get the first element of an array. Passing **n** will return the first N\n  // values in the array. Aliased as `head` and `take`. The **guard** check\n  // allows it to work with `_.map`.\n  _.first = _.head = _.take = function(array, n, guard) {\n    if (array == null) return void 0;\n    return (n != null) && !guard ? slice.call(array, 0, n) : array[0];\n  };\n\n  // Returns everything but the last entry of the array. Especially useful on\n  // the arguments object. Passing **n** will return all the values in\n  // the array, excluding the last N. The **guard** check allows it to work with\n  // `_.map`.\n  _.initial = function(array, n, guard) {\n    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));\n  };\n\n  // Get the last element of an array. Passing **n** will return the last N\n  // values in the array. The **guard** check allows it to work with `_.map`.\n  _.last = function(array, n, guard) {\n    if (array == null) return void 0;\n    if ((n != null) && !guard) {\n      return slice.call(array, Math.max(array.length - n, 0));\n    } else {\n      return array[array.length - 1];\n    }\n  };\n\n  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.\n  // Especially useful on the arguments object. Passing an **n** will return\n  // the rest N values in the array. The **guard**\n  // check allows it to work with `_.map`.\n  _.rest = _.tail = _.drop = function(array, n, guard) {\n    return slice.call(array, (n == null) || guard ? 1 : n);\n  };\n\n  // Trim out all falsy values from an array.\n  _.compact = function(array) {\n    return _.filter(array, _.identity);\n  };\n\n  // Internal implementation of a recursive `flatten` function.\n  var flatten = function(input, shallow, output) {\n    each(input, function(value) {\n      if (_.isArray(value)) {\n        shallow ? push.apply(output, value) : flatten(value, shallow, output);\n      } else {\n        output.push(value);\n      }\n    });\n    return output;\n  };\n\n  // Return a completely flattened version of an array.\n  _.flatten = function(array, shallow) {\n    return flatten(array, shallow, []);\n  };\n\n  // Return a version of the array that does not contain the specified value(s).\n  _.without = function(array) {\n    return _.difference(array, slice.call(arguments, 1));\n  };\n\n  // Produce a duplicate-free version of the array. If the array has already\n  // been sorted, you have the option of using a faster algorithm.\n  // Aliased as `unique`.\n  _.uniq = _.unique = function(array, isSorted, iterator, context) {\n    if (_.isFunction(isSorted)) {\n      context = iterator;\n      iterator = isSorted;\n      isSorted = false;\n    }\n    var initial = iterator ? _.map(array, iterator, context) : array;\n    var results = [];\n    var seen = [];\n    each(initial, function(value, index) {\n      if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {\n        seen.push(value);\n        results.push(array[index]);\n      }\n    });\n    return results;\n  };\n\n  // Produce an array that contains the union: each distinct element from all of\n  // the passed-in arrays.\n  _.union = function() {\n    return _.uniq(concat.apply(ArrayProto, arguments));\n  };\n\n  // Produce an array that contains every item shared between all the\n  // passed-in arrays.\n  _.intersection = function(array) {\n    var rest = slice.call(arguments, 1);\n    return _.filter(_.uniq(array), function(item) {\n      return _.every(rest, function(other) {\n        return _.indexOf(other, item) >= 0;\n      });\n    });\n  };\n\n  // Take the difference between one array and a number of other arrays.\n  // Only the elements present in just the first array will remain.\n  _.difference = function(array) {\n    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));\n    return _.filter(array, function(value){ return !_.contains(rest, value); });\n  };\n\n  // Zip together multiple lists into a single array -- elements that share\n  // an index go together.\n  _.zip = function() {\n    var args = slice.call(arguments);\n    var length = _.max(_.pluck(args, 'length'));\n    var results = new Array(length);\n    for (var i = 0; i < length; i++) {\n      results[i] = _.pluck(args, \"\" + i);\n    }\n    return results;\n  };\n\n  // Converts lists into objects. Pass either a single array of `[key, value]`\n  // pairs, or two parallel arrays of the same length -- one of keys, and one of\n  // the corresponding values.\n  _.object = function(list, values) {\n    if (list == null) return {};\n    var result = {};\n    for (var i = 0, l = list.length; i < l; i++) {\n      if (values) {\n        result[list[i]] = values[i];\n      } else {\n        result[list[i][0]] = list[i][1];\n      }\n    }\n    return result;\n  };\n\n  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),\n  // we need this function. Return the position of the first occurrence of an\n  // item in an array, or -1 if the item is not included in the array.\n  // Delegates to **ECMAScript 5**'s native `indexOf` if available.\n  // If the array is large and already in sort order, pass `true`\n  // for **isSorted** to use binary search.\n  _.indexOf = function(array, item, isSorted) {\n    if (array == null) return -1;\n    var i = 0, l = array.length;\n    if (isSorted) {\n      if (typeof isSorted == 'number') {\n        i = (isSorted < 0 ? Math.max(0, l + isSorted) : isSorted);\n      } else {\n        i = _.sortedIndex(array, item);\n        return array[i] === item ? i : -1;\n      }\n    }\n    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);\n    for (; i < l; i++) if (array[i] === item) return i;\n    return -1;\n  };\n\n  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.\n  _.lastIndexOf = function(array, item, from) {\n    if (array == null) return -1;\n    var hasIndex = from != null;\n    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {\n      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);\n    }\n    var i = (hasIndex ? from : array.length);\n    while (i--) if (array[i] === item) return i;\n    return -1;\n  };\n\n  // Generate an integer Array containing an arithmetic progression. A port of\n  // the native Python `range()` function. See\n  // [the Python documentation](http://docs.python.org/library/functions.html#range).\n  _.range = function(start, stop, step) {\n    if (arguments.length <= 1) {\n      stop = start || 0;\n      start = 0;\n    }\n    step = arguments[2] || 1;\n\n    var len = Math.max(Math.ceil((stop - start) / step), 0);\n    var idx = 0;\n    var range = new Array(len);\n\n    while(idx < len) {\n      range[idx++] = start;\n      start += step;\n    }\n\n    return range;\n  };\n\n  // Function (ahem) Functions\n  // ------------------\n\n  // Create a function bound to a given object (assigning `this`, and arguments,\n  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if\n  // available.\n  _.bind = function(func, context) {\n    if (func.bind === nativeBind && nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));\n    var args = slice.call(arguments, 2);\n    return function() {\n      return func.apply(context, args.concat(slice.call(arguments)));\n    };\n  };\n\n  // Partially apply a function by creating a version that has had some of its\n  // arguments pre-filled, without changing its dynamic `this` context.\n  _.partial = function(func) {\n    var args = slice.call(arguments, 1);\n    return function() {\n      return func.apply(this, args.concat(slice.call(arguments)));\n    };\n  };\n\n  // Bind all of an object's methods to that object. Useful for ensuring that\n  // all callbacks defined on an object belong to it.\n  _.bindAll = function(obj) {\n    var funcs = slice.call(arguments, 1);\n    if (funcs.length === 0) funcs = _.functions(obj);\n    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });\n    return obj;\n  };\n\n  // Memoize an expensive function by storing its results.\n  _.memoize = function(func, hasher) {\n    var memo = {};\n    hasher || (hasher = _.identity);\n    return function() {\n      var key = hasher.apply(this, arguments);\n      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));\n    };\n  };\n\n  // Delays a function for the given number of milliseconds, and then calls\n  // it with the arguments supplied.\n  _.delay = function(func, wait) {\n    var args = slice.call(arguments, 2);\n    return setTimeout(function(){ return func.apply(null, args); }, wait);\n  };\n\n  // Defers a function, scheduling it to run after the current call stack has\n  // cleared.\n  _.defer = function(func) {\n    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));\n  };\n\n  // Returns a function, that, when invoked, will only be triggered at most once\n  // during a given window of time.\n  _.throttle = function(func, wait) {\n    var context, args, timeout, result;\n    var previous = 0;\n    var later = function() {\n      previous = new Date;\n      timeout = null;\n      result = func.apply(context, args);\n    };\n    return function() {\n      var now = new Date;\n      var remaining = wait - (now - previous);\n      context = this;\n      args = arguments;\n      if (remaining <= 0) {\n        clearTimeout(timeout);\n        timeout = null;\n        previous = now;\n        result = func.apply(context, args);\n      } else if (!timeout) {\n        timeout = setTimeout(later, remaining);\n      }\n      return result;\n    };\n  };\n\n  // Returns a function, that, as long as it continues to be invoked, will not\n  // be triggered. The function will be called after it stops being called for\n  // N milliseconds. If `immediate` is passed, trigger the function on the\n  // leading edge, instead of the trailing.\n  _.debounce = function(func, wait, immediate) {\n    var timeout, result;\n    return function() {\n      var context = this, args = arguments;\n      var later = function() {\n        timeout = null;\n        if (!immediate) result = func.apply(context, args);\n      };\n      var callNow = immediate && !timeout;\n      clearTimeout(timeout);\n      timeout = setTimeout(later, wait);\n      if (callNow) result = func.apply(context, args);\n      return result;\n    };\n  };\n\n  // Returns a function that will be executed at most one time, no matter how\n  // often you call it. Useful for lazy initialization.\n  _.once = function(func) {\n    var ran = false, memo;\n    return function() {\n      if (ran) return memo;\n      ran = true;\n      memo = func.apply(this, arguments);\n      func = null;\n      return memo;\n    };\n  };\n\n  // Returns the first function passed as an argument to the second,\n  // allowing you to adjust arguments, run code before and after, and\n  // conditionally execute the original function.\n  _.wrap = function(func, wrapper) {\n    return function() {\n      var args = [func];\n      push.apply(args, arguments);\n      return wrapper.apply(this, args);\n    };\n  };\n\n  // Returns a function that is the composition of a list of functions, each\n  // consuming the return value of the function that follows.\n  _.compose = function() {\n    var funcs = arguments;\n    return function() {\n      var args = arguments;\n      for (var i = funcs.length - 1; i >= 0; i--) {\n        args = [funcs[i].apply(this, args)];\n      }\n      return args[0];\n    };\n  };\n\n  // Returns a function that will only be executed after being called N times.\n  _.after = function(times, func) {\n    if (times <= 0) return func();\n    return function() {\n      if (--times < 1) {\n        return func.apply(this, arguments);\n      }\n    };\n  };\n\n  // Object Functions\n  // ----------------\n\n  // Retrieve the names of an object's properties.\n  // Delegates to **ECMAScript 5**'s native `Object.keys`\n  _.keys = nativeKeys || function(obj) {\n    if (obj !== Object(obj)) throw new TypeError('Invalid object');\n    var keys = [];\n    for (var key in obj) if (_.has(obj, key)) keys[keys.length] = key;\n    return keys;\n  };\n\n  // Retrieve the values of an object's properties.\n  _.values = function(obj) {\n    var values = [];\n    for (var key in obj) if (_.has(obj, key)) values.push(obj[key]);\n    return values;\n  };\n\n  // Convert an object into a list of `[key, value]` pairs.\n  _.pairs = function(obj) {\n    var pairs = [];\n    for (var key in obj) if (_.has(obj, key)) pairs.push([key, obj[key]]);\n    return pairs;\n  };\n\n  // Invert the keys and values of an object. The values must be serializable.\n  _.invert = function(obj) {\n    var result = {};\n    for (var key in obj) if (_.has(obj, key)) result[obj[key]] = key;\n    return result;\n  };\n\n  // Return a sorted list of the function names available on the object.\n  // Aliased as `methods`\n  _.functions = _.methods = function(obj) {\n    var names = [];\n    for (var key in obj) {\n      if (_.isFunction(obj[key])) names.push(key);\n    }\n    return names.sort();\n  };\n\n  // Extend a given object with all the properties in passed-in object(s).\n  _.extend = function(obj) {\n    each(slice.call(arguments, 1), function(source) {\n      if (source) {\n        for (var prop in source) {\n          obj[prop] = source[prop];\n        }\n      }\n    });\n    return obj;\n  };\n\n  // Return a copy of the object only containing the whitelisted properties.\n  _.pick = function(obj) {\n    var copy = {};\n    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));\n    each(keys, function(key) {\n      if (key in obj) copy[key] = obj[key];\n    });\n    return copy;\n  };\n\n   // Return a copy of the object without the blacklisted properties.\n  _.omit = function(obj) {\n    var copy = {};\n    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));\n    for (var key in obj) {\n      if (!_.contains(keys, key)) copy[key] = obj[key];\n    }\n    return copy;\n  };\n\n  // Fill in a given object with default properties.\n  _.defaults = function(obj) {\n    each(slice.call(arguments, 1), function(source) {\n      if (source) {\n        for (var prop in source) {\n          if (obj[prop] == null) obj[prop] = source[prop];\n        }\n      }\n    });\n    return obj;\n  };\n\n  // Create a (shallow-cloned) duplicate of an object.\n  _.clone = function(obj) {\n    if (!_.isObject(obj)) return obj;\n    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);\n  };\n\n  // Invokes interceptor with the obj, and then returns obj.\n  // The primary purpose of this method is to \"tap into\" a method chain, in\n  // order to perform operations on intermediate results within the chain.\n  _.tap = function(obj, interceptor) {\n    interceptor(obj);\n    return obj;\n  };\n\n  // Internal recursive comparison function for `isEqual`.\n  var eq = function(a, b, aStack, bStack) {\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\n    // See the Harmony `egal` proposal: http://wiki.ecmascript.org/doku.php?id=harmony:egal.\n    if (a === b) return a !== 0 || 1 / a == 1 / b;\n    // A strict comparison is necessary because `null == undefined`.\n    if (a == null || b == null) return a === b;\n    // Unwrap any wrapped objects.\n    if (a instanceof _) a = a._wrapped;\n    if (b instanceof _) b = b._wrapped;\n    // Compare `[[Class]]` names.\n    var className = toString.call(a);\n    if (className != toString.call(b)) return false;\n    switch (className) {\n      // Strings, numbers, dates, and booleans are compared by value.\n      case '[object String]':\n        // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n        // equivalent to `new String(\"5\")`.\n        return a == String(b);\n      case '[object Number]':\n        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for\n        // other numeric values.\n        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);\n      case '[object Date]':\n      case '[object Boolean]':\n        // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n        // millisecond representations. Note that invalid dates with millisecond representations\n        // of `NaN` are not equivalent.\n        return +a == +b;\n      // RegExps are compared by their source patterns and flags.\n      case '[object RegExp]':\n        return a.source == b.source &&\n               a.global == b.global &&\n               a.multiline == b.multiline &&\n               a.ignoreCase == b.ignoreCase;\n    }\n    if (typeof a != 'object' || typeof b != 'object') return false;\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n    var length = aStack.length;\n    while (length--) {\n      // Linear search. Performance is inversely proportional to the number of\n      // unique nested structures.\n      if (aStack[length] == a) return bStack[length] == b;\n    }\n    // Add the first object to the stack of traversed objects.\n    aStack.push(a);\n    bStack.push(b);\n    var size = 0, result = true;\n    // Recursively compare objects and arrays.\n    if (className == '[object Array]') {\n      // Compare array lengths to determine if a deep comparison is necessary.\n      size = a.length;\n      result = size == b.length;\n      if (result) {\n        // Deep compare the contents, ignoring non-numeric properties.\n        while (size--) {\n          if (!(result = eq(a[size], b[size], aStack, bStack))) break;\n        }\n      }\n    } else {\n      // Objects with different constructors are not equivalent, but `Object`s\n      // from different frames are.\n      var aCtor = a.constructor, bCtor = b.constructor;\n      if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&\n                               _.isFunction(bCtor) && (bCtor instanceof bCtor))) {\n        return false;\n      }\n      // Deep compare objects.\n      for (var key in a) {\n        if (_.has(a, key)) {\n          // Count the expected number of properties.\n          size++;\n          // Deep compare each member.\n          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;\n        }\n      }\n      // Ensure that both objects contain the same number of properties.\n      if (result) {\n        for (key in b) {\n          if (_.has(b, key) && !(size--)) break;\n        }\n        result = !size;\n      }\n    }\n    // Remove the first object from the stack of traversed objects.\n    aStack.pop();\n    bStack.pop();\n    return result;\n  };\n\n  // Perform a deep comparison to check if two objects are equal.\n  _.isEqual = function(a, b) {\n    return eq(a, b, [], []);\n  };\n\n  // Is a given array, string, or object empty?\n  // An \"empty\" object has no enumerable own-properties.\n  _.isEmpty = function(obj) {\n    if (obj == null) return true;\n    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;\n    for (var key in obj) if (_.has(obj, key)) return false;\n    return true;\n  };\n\n  // Is a given value a DOM element?\n  _.isElement = function(obj) {\n    return !!(obj && obj.nodeType === 1);\n  };\n\n  // Is a given value an array?\n  // Delegates to ECMA5's native Array.isArray\n  _.isArray = nativeIsArray || function(obj) {\n    return toString.call(obj) == '[object Array]';\n  };\n\n  // Is a given variable an object?\n  _.isObject = function(obj) {\n    return obj === Object(obj);\n  };\n\n  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.\n  each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {\n    _['is' + name] = function(obj) {\n      return toString.call(obj) == '[object ' + name + ']';\n    };\n  });\n\n  // Define a fallback version of the method in browsers (ahem, IE), where\n  // there isn't any inspectable \"Arguments\" type.\n  if (!_.isArguments(arguments)) {\n    _.isArguments = function(obj) {\n      return !!(obj && _.has(obj, 'callee'));\n    };\n  }\n\n  // Optimize `isFunction` if appropriate.\n  if (typeof (/./) !== 'function') {\n    _.isFunction = function(obj) {\n      return typeof obj === 'function';\n    };\n  }\n\n  // Is a given object a finite number?\n  _.isFinite = function(obj) {\n    return isFinite(obj) && !isNaN(parseFloat(obj));\n  };\n\n  // Is the given value `NaN`? (NaN is the only number which does not equal itself).\n  _.isNaN = function(obj) {\n    return _.isNumber(obj) && obj != +obj;\n  };\n\n  // Is a given value a boolean?\n  _.isBoolean = function(obj) {\n    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\n  };\n\n  // Is a given value equal to null?\n  _.isNull = function(obj) {\n    return obj === null;\n  };\n\n  // Is a given variable undefined?\n  _.isUndefined = function(obj) {\n    return obj === void 0;\n  };\n\n  // Shortcut function for checking if an object has a given property directly\n  // on itself (in other words, not on a prototype).\n  _.has = function(obj, key) {\n    return hasOwnProperty.call(obj, key);\n  };\n\n  // Utility Functions\n  // -----------------\n\n  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its\n  // previous owner. Returns a reference to the Underscore object.\n  _.noConflict = function() {\n    root._ = previousUnderscore;\n    return this;\n  };\n\n  // Keep the identity function around for default iterators.\n  _.identity = function(value) {\n    return value;\n  };\n\n  // Run a function **n** times.\n  _.times = function(n, iterator, context) {\n    var accum = Array(n);\n    for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);\n    return accum;\n  };\n\n  // Return a random integer between min and max (inclusive).\n  _.random = function(min, max) {\n    if (max == null) {\n      max = min;\n      min = 0;\n    }\n    return min + Math.floor(Math.random() * (max - min + 1));\n  };\n\n  // List of HTML entities for escaping.\n  var entityMap = {\n    escape: {\n      '&': '&amp;',\n      '<': '&lt;',\n      '>': '&gt;',\n      '\"': '&quot;',\n      \"'\": '&#x27;',\n      '/': '&#x2F;'\n    }\n  };\n  entityMap.unescape = _.invert(entityMap.escape);\n\n  // Regexes containing the keys and values listed immediately above.\n  var entityRegexes = {\n    escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),\n    unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')\n  };\n\n  // Functions for escaping and unescaping strings to/from HTML interpolation.\n  _.each(['escape', 'unescape'], function(method) {\n    _[method] = function(string) {\n      if (string == null) return '';\n      return ('' + string).replace(entityRegexes[method], function(match) {\n        return entityMap[method][match];\n      });\n    };\n  });\n\n  // If the value of the named property is a function then invoke it;\n  // otherwise, return it.\n  _.result = function(object, property) {\n    if (object == null) return null;\n    var value = object[property];\n    return _.isFunction(value) ? value.call(object) : value;\n  };\n\n  // Add your own custom functions to the Underscore object.\n  _.mixin = function(obj) {\n    each(_.functions(obj), function(name){\n      var func = _[name] = obj[name];\n      _.prototype[name] = function() {\n        var args = [this._wrapped];\n        push.apply(args, arguments);\n        return result.call(this, func.apply(_, args));\n      };\n    });\n  };\n\n  // Generate a unique integer id (unique within the entire client session).\n  // Useful for temporary DOM ids.\n  var idCounter = 0;\n  _.uniqueId = function(prefix) {\n    var id = ++idCounter + '';\n    return prefix ? prefix + id : id;\n  };\n\n  // By default, Underscore uses ERB-style template delimiters, change the\n  // following template settings to use alternative delimiters.\n  _.templateSettings = {\n    evaluate    : /<%([\\s\\S]+?)%>/g,\n    interpolate : /<%=([\\s\\S]+?)%>/g,\n    escape      : /<%-([\\s\\S]+?)%>/g\n  };\n\n  // When customizing `templateSettings`, if you don't want to define an\n  // interpolation, evaluation or escaping regex, we need one that is\n  // guaranteed not to match.\n  var noMatch = /(.)^/;\n\n  // Certain characters need to be escaped so that they can be put into a\n  // string literal.\n  var escapes = {\n    \"'\":      \"'\",\n    '\\\\':     '\\\\',\n    '\\r':     'r',\n    '\\n':     'n',\n    '\\t':     't',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n  };\n\n  var escaper = /\\\\|'|\\r|\\n|\\t|\\u2028|\\u2029/g;\n\n  // JavaScript micro-templating, similar to John Resig's implementation.\n  // Underscore templating handles arbitrary delimiters, preserves whitespace,\n  // and correctly escapes quotes within interpolated code.\n  _.template = function(text, data, settings) {\n    var render;\n    settings = _.defaults({}, settings, _.templateSettings);\n\n    // Combine delimiters into one regular expression via alternation.\n    var matcher = new RegExp([\n      (settings.escape || noMatch).source,\n      (settings.interpolate || noMatch).source,\n      (settings.evaluate || noMatch).source\n    ].join('|') + '|$', 'g');\n\n    // Compile the template source, escaping string literals appropriately.\n    var index = 0;\n    var source = \"__p+='\";\n    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {\n      source += text.slice(index, offset)\n        .replace(escaper, function(match) { return '\\\\' + escapes[match]; });\n\n      if (escape) {\n        source += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\";\n      }\n      if (interpolate) {\n        source += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\";\n      }\n      if (evaluate) {\n        source += \"';\\n\" + evaluate + \"\\n__p+='\";\n      }\n      index = offset + match.length;\n      return match;\n    });\n    source += \"';\\n\";\n\n    // If a variable is not specified, place data values in local scope.\n    if (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\n\n    source = \"var __t,__p='',__j=Array.prototype.join,\" +\n      \"print=function(){__p+=__j.call(arguments,'');};\\n\" +\n      source + \"return __p;\\n\";\n\n    try {\n      render = new Function(settings.variable || 'obj', '_', source);\n    } catch (e) {\n      e.source = source;\n      throw e;\n    }\n\n    if (data) return render(data, _);\n    var template = function(data) {\n      return render.call(this, data, _);\n    };\n\n    // Provide the compiled function source as a convenience for precompilation.\n    template.source = 'function(' + (settings.variable || 'obj') + '){\\n' + source + '}';\n\n    return template;\n  };\n\n  // Add a \"chain\" function, which will delegate to the wrapper.\n  _.chain = function(obj) {\n    return _(obj).chain();\n  };\n\n  // OOP\n  // ---------------\n  // If Underscore is called as a function, it returns a wrapped object that\n  // can be used OO-style. This wrapper holds altered versions of all the\n  // underscore functions. Wrapped objects may be chained.\n\n  // Helper function to continue chaining intermediate results.\n  var result = function(obj) {\n    return this._chain ? _(obj).chain() : obj;\n  };\n\n  // Add all of the Underscore functions to the wrapper object.\n  _.mixin(_);\n\n  // Add all mutator Array functions to the wrapper.\n  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      var obj = this._wrapped;\n      method.apply(obj, arguments);\n      if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];\n      return result.call(this, obj);\n    };\n  });\n\n  // Add all accessor Array functions to the wrapper.\n  each(['concat', 'join', 'slice'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      return result.call(this, method.apply(this._wrapped, arguments));\n    };\n  });\n\n  _.extend(_.prototype, {\n\n    // Start chaining a wrapped Underscore object.\n    chain: function() {\n      this._chain = true;\n      return this;\n    },\n\n    // Extracts the result from a wrapped and chained object.\n    value: function() {\n      return this._wrapped;\n    }\n\n  });\n\n}).call(this);\n\n/*global _: false, $: false, localStorage: false, process: true,\n  XMLHttpRequest: false, XDomainRequest: false, exports: false,\n  require: false, setTimeout: true */\n(function(root) {\n  root.Parse = root.Parse || {};\n  /**\n   * Contains all Parse API classes and functions.\n   * @name Parse\n   * @namespace\n   *\n   * Contains all Parse API classes and functions.\n   */\n  var Parse = root.Parse;\n\n  var req = typeof(require) === 'function' ? require : null;\n  // Load references to other dependencies\n  if (typeof(XMLHttpRequest) !== 'undefined') {\n    Parse.XMLHttpRequest = XMLHttpRequest;\n  } else if (typeof(require) === 'function' &&\n      typeof(require.ensure) === 'undefined') {\n    Parse.XMLHttpRequest = req('xmlhttprequest').XMLHttpRequest;\n  }\n  // Import Parse's local copy of underscore.\n  if (typeof(exports) !== 'undefined' && exports._) {\n    // We're running in a CommonJS environment\n    Parse._ = exports._.noConflict();\n    exports.Parse = Parse;\n  } else {\n    Parse._ = _.noConflict();\n  }\n\n  // If jQuery or Zepto has been included, grab a reference to it.\n  if (typeof($) !== \"undefined\") {\n    Parse.$ = $;\n  }\n\n  // Helpers\n  // -------\n\n  // Shared empty constructor function to aid in prototype-chain creation.\n  var EmptyConstructor = function() {};\n\n  // TODO: fix this so that ParseObjects aren't all called \"child\" in debugger.\n  // Helper function to correctly set up the prototype chain, for subclasses.\n  // Similar to `goog.inherits`, but uses a hash of prototype properties and\n  // class properties to be extended.\n  var inherits = function(parent, protoProps, staticProps) {\n    var child;\n\n    // The constructor function for the new subclass is either defined by you\n    // (the \"constructor\" property in your `extend` definition), or defaulted\n    // by us to simply call the parent's constructor.\n    if (protoProps && protoProps.hasOwnProperty('constructor')) {\n      child = protoProps.constructor;\n    } else {\n      /** @ignore */\n      child = function(){ parent.apply(this, arguments); };\n    }\n\n    // Inherit class (static) properties from parent.\n    Parse._.extend(child, parent);\n\n    // Set the prototype chain to inherit from `parent`, without calling\n    // `parent`'s constructor function.\n    EmptyConstructor.prototype = parent.prototype;\n    child.prototype = new EmptyConstructor();\n\n    // Add prototype properties (instance properties) to the subclass,\n    // if supplied.\n    if (protoProps) {\n      Parse._.extend(child.prototype, protoProps);\n    }\n\n    // Add static properties to the constructor function, if supplied.\n    if (staticProps) {\n      Parse._.extend(child, staticProps);\n    }\n\n    // Correctly set child's `prototype.constructor`.\n    child.prototype.constructor = child;\n\n    // Set a convenience property in case the parent's prototype is\n    // needed later.\n    child.__super__ = parent.prototype;\n\n    return child;\n  };\n\n  // Set the server for Parse to talk to.\n  Parse.serverURL = \"https://api.parse.com\";\n\n  // Check whether we are running in Node.js.\n  if (typeof(process) !== \"undefined\" &&\n      process.versions &&\n      process.versions.node) {\n    Parse._isNode = true;\n  }\n\n  /**\n   * Call this method first to set up your authentication tokens for Parse.\n   * You can get your keys from the Data Browser on parse.com.\n   * @param {String} applicationId Your Parse Application ID.\n   * @param {String} javaScriptKey Your Parse JavaScript Key.\n   * @param {String} masterKey (optional) Your Parse Master Key. (Node.js only!)\n   */\n  Parse.initialize = function(applicationId, javaScriptKey, masterKey) {\n    if (masterKey) {\n      throw \"Parse.initialize() was passed a Master Key, which is only \" +\n        \"allowed from within Node.js.\";\n    }\n    Parse._initialize(applicationId, javaScriptKey);\n  };\n\n  /**\n   * Call this method first to set up master authentication tokens for Parse.\n   * This method is for Parse's own private use.\n   * @param {String} applicationId Your Parse Application ID.\n   * @param {String} javaScriptKey Your Parse JavaScript Key.\n   * @param {String} masterKey Your Parse Master Key.\n   */\n  Parse._initialize = function(applicationId, javaScriptKey, masterKey) {\n    Parse.applicationId = applicationId;\n    Parse.javaScriptKey = javaScriptKey;\n    Parse.masterKey = masterKey;\n    Parse._useMasterKey = false;\n  };\n\n  // If we're running in node.js, allow using the master key.\n  if (Parse._isNode) {\n    Parse.initialize = Parse._initialize;\n\n    Parse.Cloud = Parse.Cloud || {};\n    /**\n     * Switches the Parse SDK to using the Master key.  The Master key grants\n     * priveleged access to the data in Parse and can be used to bypass ACLs and\n     * other restrictions that are applied to the client SDKs.\n     * <p><strong><em>Available in Cloud Code and Node.js only.</em></strong>\n     * </p>\n     */\n    Parse.Cloud.useMasterKey = function() {\n      Parse._useMasterKey = true;\n    };\n  }\n\n  /**\n   * Returns prefix for Storage keys used by this instance of Parse.\n   * @param {String} path The relative suffix to append to it.\n   *     null or undefined is treated as the empty string.\n   * @return {String} The full key name.\n   */\n  Parse._getParsePath = function(path) {\n    if (!Parse.applicationId) {\n      throw \"You need to call Parse.initialize before using Parse.\";\n    }\n    if (!path) {\n      path = \"\";\n    }\n    if (!Parse._.isString(path)) {\n      throw \"Tried to get a Storage path that wasn't a String.\";\n    }\n    if (path[0] === \"/\") {\n      path = path.substring(1);\n    }\n    return \"Parse/\" + Parse.applicationId + \"/\" + path;\n  };\n\n  /**\n   * Returns a Promise that is resolved with the unique string for this app on\n   * this machine.\n   * Gets reset when Storage is cleared.\n   */\n  Parse._installationId = null;\n  Parse._getInstallationId = function() {\n    // See if it's cached in RAM.\n    if (Parse._installationId) {\n      return Parse.Promise.as(Parse._installationId);\n    }\n\n    // Try to get it from Storage.\n    var path = Parse._getParsePath(\"installationId\");\n    return (Parse.Storage.getItemAsync(path)\n      .then(function(value) {\n        Parse._installationId = value;\n\n        if (!Parse._installationId || Parse._installationId === \"\") {\n          // It wasn't in Storage, so create a new one.\n          var hexOctet = function() {\n            return (\n              Math.floor((1+Math.random())*0x10000).toString(16).substring(1)\n            );\n          };\n          Parse._installationId = (\n            hexOctet() + hexOctet() + \"-\" +\n            hexOctet() + \"-\" +\n            hexOctet() + \"-\" +\n            hexOctet() + \"-\" +\n            hexOctet() + hexOctet() + hexOctet());\n          return Parse.Storage.setItemAsync(path, Parse._installationId);\n        }\n\n        return Parse.Promise.as(Parse._installationId);\n      })\n    );\n  };\n\n  Parse._parseDate = function(iso8601) {\n    var regexp = new RegExp(\n      \"^([0-9]{1,4})-([0-9]{1,2})-([0-9]{1,2})\" + \"T\" +\n      \"([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2})\" +\n      \"(.([0-9]+))?\" + \"Z$\");\n    var match = regexp.exec(iso8601);\n    if (!match) {\n      return null;\n    }\n\n    var year = match[1] || 0;\n    var month = (match[2] || 1) - 1;\n    var day = match[3] || 0;\n    var hour = match[4] || 0;\n    var minute = match[5] || 0;\n    var second = match[6] || 0;\n    var milli = match[8] || 0;\n\n    return new Date(Date.UTC(year, month, day, hour, minute, second, milli));\n  };\n\n  Parse._ajaxIE8 = function(method, url, data) {\n    var promise = new Parse.Promise();\n    var xdr = new XDomainRequest();\n    xdr.onload = function() {\n      var response;\n      try {\n        response = JSON.parse(xdr.responseText);\n      } catch (e) {\n        promise.reject(e);\n      }\n      if (response) {\n        promise.resolve(response);\n      }\n    };\n    xdr.onerror = xdr.ontimeout = function() {\n      // Let's fake a real error message.\n      var fakeResponse = {\n        responseText: JSON.stringify({\n          code: Parse.Error.X_DOMAIN_REQUEST,\n          error: \"IE's XDomainRequest does not supply error info.\"\n        })\n      };\n      promise.reject(fakeResponse);\n    };\n    xdr.onprogress = function() {};\n    xdr.open(method, url);\n    xdr.send(data);\n    return promise;\n  };\n\n  Parse._useXDomainRequest = function() {\n    if (typeof(XDomainRequest) !== \"undefined\") {\n      // We're in IE 8+.\n      if ('withCredentials' in new XMLHttpRequest()) {\n        // We're in IE 10+.\n        return false;\n      }\n      return true;\n    }\n    return false;\n  };\n\n  // TODO(klimt): Get rid of success/error usage in website.\n  Parse._ajax = function(method, url, data, success, error) {\n    var options = {\n      success: success,\n      error: error\n    };\n\n    if (Parse._useXDomainRequest()) {\n      return Parse._ajaxIE8(method, url, data)._thenRunCallbacks(options);\n    }\n\n    var promise = new Parse.Promise();\n    var attempts = 0;\n\n    var dispatch = function() {\n      var handled = false;\n      var xhr = new Parse.XMLHttpRequest();\n\n      xhr.onreadystatechange = function() {\n        if (xhr.readyState === 4) {\n          if (handled) {\n            return;\n          }\n          handled = true;\n\n          if (xhr.status >= 200 && xhr.status < 300) {\n            var response;\n            try {\n              response = JSON.parse(xhr.responseText);\n            } catch (e) {\n              promise.reject(e);\n            }\n            if (response) {\n              promise.resolve(response, xhr.status, xhr);\n            }\n          } else if (xhr.status >= 500) { // Retry on 5XX\n            if (++attempts < 5) {\n              // Exponentially-growing delay\n              var delay = Math.round(\n                Math.random() * 125 * Math.pow(2, attempts)\n              );\n              setTimeout(dispatch, delay);\n            } else {\n              // After 5 retries, fail\n              promise.reject(xhr);\n            }\n          } else {\n            promise.reject(xhr);\n          }\n        }\n      };\n\n      xhr.open(method, url, true);\n      xhr.setRequestHeader('Content-Type', 'text/plain');  // avoid pre-flight.\n      if (Parse._isNode) {\n        // Add a special user agent just for request from node.js.\n        xhr.setRequestHeader(\"User-Agent\",\n                             \"Parse/\" + Parse.VERSION +\n                             \" (NodeJS \" + process.versions.node + \")\");\n      }\n      xhr.send(data);\n    };\n\n    dispatch();\n    return promise._thenRunCallbacks(options); \n  };\n\n  // A self-propagating extend function.\n  Parse._extend = function(protoProps, classProps) {\n    var child = inherits(this, protoProps, classProps);\n    child.extend = this.extend;\n    return child;\n  };\n\n  /**\n   * Options:\n   *   route: is classes, users, login, etc.\n   *   objectId: null if there is no associated objectId.\n   *   method: the http method for the REST API.\n   *   dataObject: the payload as an object, or null if there is none.\n   *   useMasterKey: overrides whether to use the master key if set.\n   * @ignore\n   */\n  Parse._request = function(options) {\n    var route = options.route;\n    var className = options.className;\n    var objectId = options.objectId;\n    var method = options.method;\n    var useMasterKey = options.useMasterKey;\n    var sessionToken = options.sessionToken;\n    var dataObject = options.data;\n\n    if (!Parse.applicationId) {\n      throw \"You must specify your applicationId using Parse.initialize.\";\n    }\n\n    if (!Parse.javaScriptKey && !Parse.masterKey) {\n      throw \"You must specify a key using Parse.initialize.\";\n    }\n\n    // TODO: We can remove this check later, but it's useful for development.\n    if (route !== \"batch\" &&\n        route !== \"classes\" &&\n        route !== \"events\" &&\n        route !== \"files\" &&\n        route !== \"functions\" &&\n        route !== \"login\" &&\n        route !== \"logout\" &&\n        route !== \"push\" &&\n        route !== \"requestPasswordReset\" &&\n        route !== \"rest_verify_analytics\" &&\n        route !== \"users\" &&\n        route !== \"jobs\" &&\n        route !== \"config\" &&\n        route !== \"sessions\" &&\n        route !== \"upgradeToRevocableSession\") {\n      throw \"Bad route: '\" + route + \"'.\";\n    }\n\n    var url = Parse.serverURL;\n    if (url.charAt(url.length - 1) !== \"/\") {\n      url += \"/\";\n    }\n    url += \"1/\" + route;\n    if (className) {\n      url += \"/\" + className;\n    }\n    if (objectId) {\n      url += \"/\" + objectId;\n    }\n\n    dataObject = Parse._.clone(dataObject || {});\n    if (method !== \"POST\") {\n      dataObject._method = method;\n      method = \"POST\";\n    }\n\n    if (Parse._.isUndefined(useMasterKey)) {\n      useMasterKey = Parse._useMasterKey;\n    }\n\n    dataObject._ApplicationId = Parse.applicationId;\n    if (!useMasterKey) {\n      dataObject._JavaScriptKey = Parse.javaScriptKey;\n    } else if (!Parse.masterKey) {\n      throw new Error('Cannot use the Master Key, it has not been provided.');\n    } else {\n      dataObject._MasterKey = Parse.masterKey;\n    }\n\n    dataObject._ClientVersion = Parse.VERSION;\n\n    return Parse._getInstallationId().then(function(iid) {\n      dataObject._InstallationId = iid;\n\n      if (sessionToken) {\n        return Parse.Promise.as({ _sessionToken: sessionToken });\n      }\n      if (!Parse.User._canUseCurrentUser()) {\n        return Parse.Promise.as(null);\n      }\n\n      return Parse.User._currentAsync();\n    }).then(function(currentUser) {\n      if (currentUser && currentUser._sessionToken) {\n        dataObject._SessionToken = currentUser._sessionToken;\n      }\n\n      if (Parse.User._isRevocableSessionEnabled) {\n        dataObject._RevocableSession = '1';\n      }\n\n      var data = JSON.stringify(dataObject);\n\n      return Parse._ajax(method, url, data);\n    }).then(null, function(response) {\n      // Transform the error into an instance of Parse.Error by trying to parse\n      // the error string as JSON.\n      var error;\n      if (response && response.responseText) {\n        try {\n          var errorJSON = JSON.parse(response.responseText);\n          error = new Parse.Error(errorJSON.code, errorJSON.error);\n        } catch (e) {\n          // If we fail to parse the error text, that's okay.\n          error = new Parse.Error(\n              Parse.Error.INVALID_JSON,\n              \"Received an error with invalid JSON from Parse: \" +\n                  response.responseText);\n        }\n      } else {\n        error = new Parse.Error(\n            Parse.Error.CONNECTION_FAILED,\n            \"XMLHttpRequest failed: \" + JSON.stringify(response));\n      }\n      // By explicitly returning a rejected Promise, this will work with\n      // either jQuery or Promises/A semantics.\n      return Parse.Promise.error(error);\n    });\n  };\n\n  // Helper function to get a value from a Backbone object as a property\n  // or as a function.\n  Parse._getValue = function(object, prop) {\n    if (!(object && object[prop])) {\n      return null;\n    }\n    return Parse._.isFunction(object[prop]) ? object[prop]() : object[prop];\n  };\n\n  /**\n   * Converts a value in a Parse Object into the appropriate representation.\n   * This is the JS equivalent of Java's Parse.maybeReferenceAndEncode(Object)\n   * if seenObjects is falsey. Otherwise any Parse.Objects not in\n   * seenObjects will be fully embedded rather than encoded\n   * as a pointer.  This array will be used to prevent going into an infinite\n   * loop because we have circular references.  If seenObjects\n   * is set, then none of the Parse Objects that are serialized can be dirty.\n   */\n  Parse._encode = function(value, seenObjects, disallowObjects) {\n    var _ = Parse._;\n    if (value instanceof Parse.Object) {\n      if (disallowObjects) {\n        throw \"Parse.Objects not allowed here\";\n      }\n      if (!seenObjects || _.include(seenObjects, value) || !value._hasData) {\n        return value._toPointer();\n      }\n      if (!value.dirty()) {\n        seenObjects = seenObjects.concat(value);\n        return Parse._encode(value._toFullJSON(seenObjects),\n                             seenObjects,\n                             disallowObjects);\n      }\n      throw \"Tried to save an object with a pointer to a new, unsaved object.\";\n    }\n    if (value instanceof Parse.ACL) {\n      return value.toJSON();\n    }\n    if (_.isDate(value)) {\n      if (isNaN(value)) {\n        throw new Error('Cannot encode invalid Date');\n      }\n      return { \"__type\": \"Date\", \"iso\": value.toJSON() };\n    }\n    if (value instanceof Parse.GeoPoint) {\n      return value.toJSON();\n    }\n    if (_.isArray(value)) {\n      return _.map(value, function(x) {\n        return Parse._encode(x, seenObjects, disallowObjects);\n      });\n    }\n    if (_.isRegExp(value)) {\n      return value.source;\n    }\n    if (value instanceof Parse.Relation) {\n      return value.toJSON();\n    }\n    if (value instanceof Parse.Op) {\n      return value.toJSON();\n    }\n    if (value instanceof Parse.File) {\n      if (!value.url()) {\n        throw \"Tried to save an object containing an unsaved file.\";\n      }\n      return {\n        __type: \"File\",\n        name: value.name(),\n        url: value.url()\n      };\n    }\n    if (_.isObject(value)) {\n      var output = {};\n      Parse._objectEach(value, function(v, k) {\n        output[k] = Parse._encode(v, seenObjects, disallowObjects);\n      });\n      return output;\n    }\n    return value;\n  };\n\n  /**\n   * The inverse function of Parse._encode.\n   * TODO: make decode not mutate value.\n   */\n  Parse._decode = function(key, value) {\n    var _ = Parse._;\n    if (!_.isObject(value)) {\n      return value;\n    }\n    if (_.isArray(value)) {\n      Parse._arrayEach(value, function(v, k) {\n        value[k] = Parse._decode(k, v);\n      });\n      return value;\n    }\n    if (value instanceof Parse.Object) {\n      return value;\n    }\n    if (value instanceof Parse.File) {\n      return value;\n    }\n    if (value instanceof Parse.Op) {\n      return value;\n    }\n    if (value.__op) {\n      return Parse.Op._decode(value);\n    }\n    if (value.__type === \"Pointer\" && value.className) {\n      var pointer = Parse.Object._create(value.className);\n      pointer._finishFetch({ objectId: value.objectId }, false);\n      return pointer;\n    }\n    if (value.__type === \"Object\" && value.className) {\n      // It's an Object included in a query result.\n      var className = value.className;\n      delete value.__type;\n      delete value.className;\n      var object = Parse.Object._create(className);\n      object._finishFetch(value, true);\n      return object;\n    }\n    if (value.__type === \"Date\") {\n      return Parse._parseDate(value.iso);\n    }\n    if (value.__type === \"GeoPoint\") {\n      return new Parse.GeoPoint({\n        latitude: value.latitude,\n        longitude: value.longitude\n      });\n    }\n    if (key === \"ACL\") {\n      if (value instanceof Parse.ACL) {\n        return value;\n      }\n      return new Parse.ACL(value);\n    }\n    if (value.__type === \"Relation\") {\n      var relation = new Parse.Relation(null, key);\n      relation.targetClassName = value.className;\n      return relation;\n    }\n    if (value.__type === \"File\") {\n      var file = new Parse.File(value.name);\n      file._url = value.url;\n      return file;\n    }\n    Parse._objectEach(value, function(v, k) {\n      value[k] = Parse._decode(k, v);\n    });\n    return value;\n  };\n\n  Parse._arrayEach = Parse._.each;\n\n  /**\n   * Does a deep traversal of every item in object, calling func on every one.\n   * @param {Object} object The object or array to traverse deeply.\n   * @param {Function} func The function to call for every item. It will\n   *     be passed the item as an argument. If it returns a truthy value, that\n   *     value will replace the item in its parent container.\n   * @returns {} the result of calling func on the top-level object itself.\n   */\n  Parse._traverse = function(object, func, seen) {\n    if (object instanceof Parse.Object) {\n      seen = seen || [];\n      if (Parse._.indexOf(seen, object) >= 0) {\n        // We've already visited this object in this call.\n        return;\n      }\n      seen.push(object);\n      Parse._traverse(object.attributes, func, seen);\n      return func(object);\n    }\n    if (object instanceof Parse.Relation || object instanceof Parse.File) {\n      // Nothing needs to be done, but we don't want to recurse into the\n      // object's parent infinitely, so we catch this case.\n      return func(object);\n    }\n    if (Parse._.isArray(object)) {\n      Parse._.each(object, function(child, index) {\n        var newChild = Parse._traverse(child, func, seen);\n        if (newChild) {\n          object[index] = newChild;\n        }\n      });\n      return func(object);\n    }\n    if (Parse._.isObject(object)) {\n      Parse._each(object, function(child, key) {\n        var newChild = Parse._traverse(child, func, seen);\n        if (newChild) {\n          object[key] = newChild;\n        }\n      });\n      return func(object);\n    }\n    return func(object);\n  };\n\n  /**\n   * This is like _.each, except:\n   * * it doesn't work for so-called array-like objects,\n   * * it does work for dictionaries with a \"length\" attribute.\n   */\n  Parse._objectEach = Parse._each = function(obj, callback) {\n    var _ = Parse._;\n    if (_.isObject(obj)) {\n      _.each(_.keys(obj), function(key) {\n        callback(obj[key], key);\n      });\n    } else {\n      _.each(obj, callback);\n    }\n  };\n\n  // Helper function to check null or undefined.\n  Parse._isNullOrUndefined = function(x) {\n    return Parse._.isNull(x) || Parse._.isUndefined(x);\n  };\n}(this));\n\n/* global require: false, localStorage: false */\n(function(root) {\n  root.Parse = root.Parse || {};\n  var Parse = root.Parse;\n  \n  var Storage = {\n    async: false,\n  };\n\n  var hasLocalStorage = (typeof localStorage !== 'undefined');\n  if (hasLocalStorage) {\n    try {\n      localStorage.setItem('supported', true);\n      localStorage.removeItem('supported');\n    } catch(e) {\n      hasLocalStorage = false;\n    }\n  }\n  if (hasLocalStorage) {\n    Storage.getItem = function(path) {\n      return localStorage.getItem(path);\n    };\n\n    Storage.setItem = function(path, value) {\n      return localStorage.setItem(path, value);\n    };\n\n    Storage.removeItem = function(path) {\n      return localStorage.removeItem(path);\n    };\n\n    Storage.clear = function() {\n      return localStorage.clear();\n    };\n  } else if (typeof require === 'function') {\n    var AsyncStorage;\n    try {\n      AsyncStorage = eval(\"require('AsyncStorage')\"); // jshint ignore:line\n\n      Storage.async = true;\n\n      Storage.getItemAsync = function(path) {\n        var p = new Parse.Promise();\n        AsyncStorage.getItem(path, function(err, value) {\n          if (err) {\n            p.reject(err);\n          } else {\n            p.resolve(value);\n          }\n        });\n        return p;\n      };\n\n      Storage.setItemAsync = function(path, value) {\n        var p = new Parse.Promise();\n        AsyncStorage.setItem(path, value, function(err) {\n          if (err) {\n            p.reject(err);\n          } else {\n            p.resolve(value);\n          }\n        });\n        return p;\n      };\n\n      Storage.removeItemAsync = function(path) {\n        var p = new Parse.Promise();\n        AsyncStorage.removeItem(path, function(err) {\n          if (err) {\n            p.reject(err);\n          } else {\n            p.resolve();\n          }\n        });\n        return p;\n      };\n\n      Storage.clear = function() {\n        AsyncStorage.clear();\n      };\n    } catch (e) { }\n  }\n  if (!Storage.async && !Storage.getItem) {\n    var memMap = Storage.inMemoryMap = {};\n    Storage.getItem = function(path) {\n      if (memMap.hasOwnProperty(path)) {\n        return memMap[path];\n      }\n      return null;\n    };\n\n    Storage.setItem = function(path, value) {\n      memMap[path] = String(value);\n    };\n\n    Storage.removeItem = function(path) {\n      delete memMap[path];\n    };\n\n    Storage.clear = function() {\n      for (var key in memMap) {\n        if (memMap.hasOwnProperty(key)) {\n          delete memMap[key];\n        }\n      }\n    };\n  }\n\n  // We can use synchronous methods from async scenarios, but not vice-versa\n  if (!Storage.async) {\n    Storage.getItemAsync = function(path) {\n      return Parse.Promise.as(\n        Storage.getItem(path)\n      );\n    };\n\n    Storage.setItemAsync = function(path, value) {\n      Storage.setItem(path, value);\n      return Parse.Promise.as(value);\n    };\n\n    Storage.removeItemAsync = function(path) {\n      return Parse.Promise.as(\n        Storage.removeItem(path)\n      );\n    };\n  }\n\n  Parse.Storage = Storage;\n\n})(this);\n\n(function(root) {\n  root.Parse = root.Parse || {};\n  var Parse = root.Parse;\n  var _ = Parse._;\n\n  /**\n   * @namespace Provides an interface to Parse's logging and analytics backend.\n   */\n  Parse.Analytics = Parse.Analytics || {};\n\n  _.extend(Parse.Analytics, /** @lends Parse.Analytics */ {\n    /**\n     * Tracks the occurrence of a custom event with additional dimensions.\n     * Parse will store a data point at the time of invocation with the given\n     * event name.\n     *\n     * Dimensions will allow segmentation of the occurrences of this custom\n     * event. Keys and values should be {@code String}s, and will throw\n     * otherwise.\n     *\n     * To track a user signup along with additional metadata, consider the\n     * following:\n     * <pre>\n     * var dimensions = {\n     *  gender: 'm',\n     *  source: 'web',\n     *  dayType: 'weekend'\n     * };\n     * Parse.Analytics.track('signup', dimensions);\n     * </pre>\n     *\n     * There is a default limit of 8 dimensions per event tracked.\n     *\n     * @param {String} name The name of the custom event to report to Parse as\n     * having happened.\n     * @param {Object} dimensions The dictionary of information by which to\n     * segment this event.\n     * @param {Object} options A Backbone-style callback object.\n     * @return {Parse.Promise} A promise that is resolved when the round-trip\n     * to the server completes.\n     */\n    track: function(name, dimensions, options) {\n      name = name || '';\n      name = name.replace(/^\\s*/, '');\n      name = name.replace(/\\s*$/, '');\n      if (name.length === 0) {\n        throw 'A name for the custom event must be provided';\n      }\n\n      _.each(dimensions, function(val, key) {\n        if (!_.isString(key) || !_.isString(val)) {\n          throw 'track() dimensions expects keys and values of type \"string\".';\n        }\n      });\n\n      options = options || {};\n      return Parse._request({\n        route: 'events',\n        className: name,\n        method: 'POST',\n        data: { dimensions: dimensions }\n      })._thenRunCallbacks(options);\n    }\n  });\n}(this));\n\n(function(root) {\n  root.Parse = root.Parse || {};\n  var Parse = root.Parse;\n  var _ = Parse._;\n\n  /**\n   * @class Parse.Config is a local representation of configuration data that\n   * can be set from the Parse dashboard.\n   */\n  Parse.Config = function() {\n    this.attributes = {};\n    this._escapedAttributes = {};\n  };\n\n  /**\n   * Retrieves the most recently-fetched configuration object, either from\n   * memory or from local storage if necessary.\n   *\n   * @return {Parse.Config} The most recently-fetched Parse.Config if it\n   *     exists, else an empty Parse.Config.\n   */\n  Parse.Config.current = function() {\n    if (Parse.Config._currentConfig) {\n      return Parse.Config._currentConfig;\n    }\n\n    var config = new Parse.Config();\n\n    if (Parse.Storage.async) {\n      return config;\n    }\n\n    var configData = Parse.Storage.getItem(Parse._getParsePath(\n          Parse.Config._CURRENT_CONFIG_KEY));\n\n    if (configData) {  \n      config._finishFetch(JSON.parse(configData));\n      Parse.Config._currentConfig = config;\n    }\n    return config;\n  };\n\n  /**\n   * Gets a new configuration object from the server.\n   * @param {Object} options A Backbone-style options object.\n   * Valid options are:<ul>\n   *   <li>success: Function to call when the get completes successfully.\n   *   <li>error: Function to call when the get fails.\n   * </ul>\n   * @return {Parse.Promise} A promise that is resolved with a newly-created\n   *     configuration object when the get completes.\n   */\n  Parse.Config.get = function(options) {\n    options = options || {};\n\n    var request = Parse._request({\n      route: \"config\",\n      method: \"GET\",\n    });\n\n    return request.then(function(response) {\n      if (!response || !response.params) {\n        var errorObject = new Parse.Error(\n          Parse.Error.INVALID_JSON,\n          \"Config JSON response invalid.\");\n        return Parse.Promise.error(errorObject);\n      }\n\n      var config = new Parse.Config();\n      config._finishFetch(response);\n      Parse.Config._currentConfig = config;\n      return config;\n    })._thenRunCallbacks(options);\n  };\n\n  Parse.Config.prototype = {\n\n    /**\n     * Gets the HTML-escaped value of an attribute.\n     */\n    escape: function(attr) {\n      var html = this._escapedAttributes[attr];\n      if (html) {\n        return html;\n      }\n      var val = this.attributes[attr];\n      var escaped;\n      if (Parse._isNullOrUndefined(val)) {\n        escaped = '';\n      } else {\n        escaped = _.escape(val.toString());\n      }\n      this._escapedAttributes[attr] = escaped;\n      return escaped;\n    },\n\n    /**\n     * Gets the value of an attribute.\n     * @param {String} attr The name of an attribute.\n     */\n    get: function(attr) {\n      return this.attributes[attr];\n    },\n\n    _finishFetch: function(serverData) {\n      this.attributes = Parse._decode(null, _.clone(serverData.params));\n      if (!Parse.Storage.async) {\n        // We only provide local caching of config with synchronous Storage\n        Parse.Storage.setItem(\n            Parse._getParsePath(Parse.Config._CURRENT_CONFIG_KEY),\n            JSON.stringify(serverData));\n      }\n    }\n  };\n\n  Parse.Config._currentConfig = null;\n\n  Parse.Config._CURRENT_CONFIG_KEY = \"currentConfig\";\n\n}(this));\n\n\n(function(root) {\n  root.Parse = root.Parse || {};\n  var Parse = root.Parse;\n  var _ = Parse._;\n\n  /**\n   * Constructs a new Parse.Error object with the given code and message.\n   * @param {Number} code An error code constant from <code>Parse.Error</code>.\n   * @param {String} message A detailed description of the error.\n   * @class\n   *\n   * <p>Class used for all objects passed to error callbacks.</p>\n   */\n  Parse.Error = function(code, message) {\n    this.code = code;\n    this.message = message;\n  };\n\n  _.extend(Parse.Error, /** @lends Parse.Error */ {\n    /**\n     * Error code indicating some error other than those enumerated here.\n     * @constant\n     */\n    OTHER_CAUSE: -1,\n\n    /**\n     * Error code indicating that something has gone wrong with the server.\n     * If you get this error code, it is Parse's fault. Contact us at \n     * https://parse.com/help\n     * @constant\n     */\n    INTERNAL_SERVER_ERROR: 1,\n\n    /**\n     * Error code indicating the connection to the Parse servers failed.\n     * @constant\n     */\n    CONNECTION_FAILED: 100,\n\n    /**\n     * Error code indicating the specified object doesn't exist.\n     * @constant\n     */\n    OBJECT_NOT_FOUND: 101,\n\n    /**\n     * Error code indicating you tried to query with a datatype that doesn't\n     * support it, like exact matching an array or object.\n     * @constant\n     */\n    INVALID_QUERY: 102,\n\n    /**\n     * Error code indicating a missing or invalid classname. Classnames are\n     * case-sensitive. They must start with a letter, and a-zA-Z0-9_ are the\n     * only valid characters.\n     * @constant\n     */\n    INVALID_CLASS_NAME: 103,\n\n    /**\n     * Error code indicating an unspecified object id.\n     * @constant\n     */\n    MISSING_OBJECT_ID: 104,\n\n    /**\n     * Error code indicating an invalid key name. Keys are case-sensitive. They\n     * must start with a letter, and a-zA-Z0-9_ are the only valid characters.\n     * @constant\n     */\n    INVALID_KEY_NAME: 105,\n\n    /**\n     * Error code indicating a malformed pointer. You should not see this unless\n     * you have been mucking about changing internal Parse code.\n     * @constant\n     */\n    INVALID_POINTER: 106,\n\n    /**\n     * Error code indicating that badly formed JSON was received upstream. This\n     * either indicates you have done something unusual with modifying how\n     * things encode to JSON, or the network is failing badly.\n     * @constant\n     */\n    INVALID_JSON: 107,\n\n    /**\n     * Error code indicating that the feature you tried to access is only\n     * available internally for testing purposes.\n     * @constant\n     */\n    COMMAND_UNAVAILABLE: 108,\n\n    /**\n     * You must call Parse.initialize before using the Parse library.\n     * @constant\n     */\n    NOT_INITIALIZED: 109,\n\n    /**\n     * Error code indicating that a field was set to an inconsistent type.\n     * @constant\n     */\n    INCORRECT_TYPE: 111,\n\n    /**\n     * Error code indicating an invalid channel name. A channel name is either\n     * an empty string (the broadcast channel) or contains only a-zA-Z0-9_\n     * characters and starts with a letter.\n     * @constant\n     */\n    INVALID_CHANNEL_NAME: 112,\n\n    /**\n     * Error code indicating that push is misconfigured.\n     * @constant\n     */\n    PUSH_MISCONFIGURED: 115,\n\n    /**\n     * Error code indicating that the object is too large.\n     * @constant\n     */\n    OBJECT_TOO_LARGE: 116,\n\n    /**\n     * Error code indicating that the operation isn't allowed for clients.\n     * @constant\n     */\n    OPERATION_FORBIDDEN: 119,\n\n    /**\n     * Error code indicating the result was not found in the cache.\n     * @constant\n     */\n    CACHE_MISS: 120,\n\n    /**\n     * Error code indicating that an invalid key was used in a nested\n     * JSONObject.\n     * @constant\n     */\n    INVALID_NESTED_KEY: 121,\n\n    /**\n     * Error code indicating that an invalid filename was used for ParseFile.\n     * A valid file name contains only a-zA-Z0-9_. characters and is between 1\n     * and 128 characters.\n     * @constant\n     */\n    INVALID_FILE_NAME: 122,\n\n    /**\n     * Error code indicating an invalid ACL was provided.\n     * @constant\n     */\n    INVALID_ACL: 123,\n\n    /**\n     * Error code indicating that the request timed out on the server. Typically\n     * this indicates that the request is too expensive to run.\n     * @constant\n     */\n    TIMEOUT: 124,\n\n    /**\n     * Error code indicating that the email address was invalid.\n     * @constant\n     */\n    INVALID_EMAIL_ADDRESS: 125,\n\n    /**\n     * Error code indicating a missing content type.\n     * @constant\n     */\n    MISSING_CONTENT_TYPE: 126,\n\n    /**\n     * Error code indicating a missing content length.\n     * @constant\n     */\n    MISSING_CONTENT_LENGTH: 127,\n\n    /**\n     * Error code indicating an invalid content length.\n     * @constant\n     */\n    INVALID_CONTENT_LENGTH: 128,\n\n    /**\n     * Error code indicating a file that was too large.\n     * @constant\n     */\n    FILE_TOO_LARGE: 129,\n\n    /**\n     * Error code indicating an error saving a file.\n     * @constant\n     */\n    FILE_SAVE_ERROR: 130,\n\n    /**\n     * Error code indicating that a unique field was given a value that is\n     * already taken.\n     * @constant\n     */\n    DUPLICATE_VALUE: 137,\n\n    /**\n     * Error code indicating that a role's name is invalid.\n     * @constant\n     */\n    INVALID_ROLE_NAME: 139,\n\n    /**\n     * Error code indicating that an application quota was exceeded.  Upgrade to\n     * resolve.\n     * @constant\n     */\n    EXCEEDED_QUOTA: 140,\n\n    /**\n     * Error code indicating that a Cloud Code script failed.\n     * @constant\n     */\n    SCRIPT_FAILED: 141,\n\n    /**\n     * Error code indicating that a Cloud Code validation failed.\n     * @constant\n     */\n    VALIDATION_ERROR: 142,\n\n    /**\n     * Error code indicating that invalid image data was provided.\n     * @constant\n     */\n    INVALID_IMAGE_DATA: 150,\n\n    /**\n     * Error code indicating an unsaved file.\n     * @constant\n     */\n    UNSAVED_FILE_ERROR: 151,\n\n    /**\n     * Error code indicating an invalid push time.\n     */\n    INVALID_PUSH_TIME_ERROR: 152,\n\n    /**\n     * Error code indicating an error deleting a file.\n     * @constant\n     */\n    FILE_DELETE_ERROR: 153,\n\n    /**\n     * Error code indicating that the application has exceeded its request\n     * limit.\n     * @constant\n     */\n    REQUEST_LIMIT_EXCEEDED: 155,\n\n    /**\n     * Error code indicating an invalid event name.\n     */\n    INVALID_EVENT_NAME: 160,\n\n    /**\n     * Error code indicating that the username is missing or empty.\n     * @constant\n     */\n    USERNAME_MISSING: 200,\n\n    /**\n     * Error code indicating that the password is missing or empty.\n     * @constant\n     */\n    PASSWORD_MISSING: 201,\n\n    /**\n     * Error code indicating that the username has already been taken.\n     * @constant\n     */\n    USERNAME_TAKEN: 202,\n\n    /**\n     * Error code indicating that the email has already been taken.\n     * @constant\n     */\n    EMAIL_TAKEN: 203,\n\n    /**\n     * Error code indicating that the email is missing, but must be specified.\n     * @constant\n     */\n    EMAIL_MISSING: 204,\n\n    /**\n     * Error code indicating that a user with the specified email was not found.\n     * @constant\n     */\n    EMAIL_NOT_FOUND: 205,\n\n    /**\n     * Error code indicating that a user object without a valid session could\n     * not be altered.\n     * @constant\n     */\n    SESSION_MISSING: 206,\n\n    /**\n     * Error code indicating that a user can only be created through signup.\n     * @constant\n     */\n    MUST_CREATE_USER_THROUGH_SIGNUP: 207,\n\n    /**\n     * Error code indicating that an an account being linked is already linked\n     * to another user.\n     * @constant\n     */\n    ACCOUNT_ALREADY_LINKED: 208,\n\n    /**\n     * Error code indicating that the current session token is invalid.\n     * @constant\n     */\n    INVALID_SESSION_TOKEN: 209,\n\n    /**\n     * Error code indicating that a user cannot be linked to an account because\n     * that account's id could not be found.\n     * @constant\n     */\n    LINKED_ID_MISSING: 250,\n\n    /**\n     * Error code indicating that a user with a linked (e.g. Facebook) account\n     * has an invalid session.\n     * @constant\n     */\n    INVALID_LINKED_SESSION: 251,\n\n    /**\n     * Error code indicating that a service being linked (e.g. Facebook or\n     * Twitter) is unsupported.\n     * @constant\n     */\n    UNSUPPORTED_SERVICE: 252,\n\n    /**\n     * Error code indicating that there were multiple errors. Aggregate errors\n     * have an \"errors\" property, which is an array of error objects with more\n     * detail about each error that occurred.\n     * @constant\n     */\n    AGGREGATE_ERROR: 600,\n\n    /**\n     * Error code indicating the client was unable to read an input file.\n     * @constant\n     */\n    FILE_READ_ERROR: 601,\n\n    /**\n     * Error code indicating a real error code is unavailable because\n     * we had to use an XDomainRequest object to allow CORS requests in\n     * Internet Explorer, which strips the body from HTTP responses that have\n     * a non-2XX status code.\n     * @constant\n     */\n    X_DOMAIN_REQUEST: 602\n  });\n\n}(this));\n\n/*global _: false */\n(function() {\n  var root = this;\n  var Parse = (root.Parse || (root.Parse = {}));\n  var eventSplitter = /\\s+/;\n  var slice = Array.prototype.slice;\n\n  /**\n   * @class\n   *\n   * <p>Parse.Events is a fork of Backbone's Events module, provided for your\n   * convenience.</p>\n   *\n   * <p>A module that can be mixed in to any object in order to provide\n   * it with custom events. You may bind callback functions to an event\n   * with `on`, or remove these functions with `off`.\n   * Triggering an event fires all callbacks in the order that `on` was\n   * called.\n   *\n   * <pre>\n   *     var object = {};\n   *     _.extend(object, Parse.Events);\n   *     object.on('expand', function(){ alert('expanded'); });\n   *     object.trigger('expand');</pre></p>\n   *\n   * <p>For more information, see the\n   * <a href=\"http://documentcloud.github.com/backbone/#Events\">Backbone\n   * documentation</a>.</p>\n   */\n  Parse.Events = {\n    /**\n     * Bind one or more space separated events, `events`, to a `callback`\n     * function. Passing `\"all\"` will bind the callback to all events fired.\n     */\n    on: function(events, callback, context) {\n\n      var calls, event, node, tail, list;\n      if (!callback) {\n        return this;\n      }\n      events = events.split(eventSplitter);\n      calls = this._callbacks || (this._callbacks = {});\n\n      // Create an immutable callback list, allowing traversal during\n      // modification.  The tail is an empty object that will always be used\n      // as the next node.\n      event = events.shift();\n      while (event) {\n        list = calls[event];\n        node = list ? list.tail : {};\n        node.next = tail = {};\n        node.context = context;\n        node.callback = callback;\n        calls[event] = {tail: tail, next: list ? list.next : node};\n        event = events.shift();\n      }\n\n      return this;\n    },\n\n    /**\n     * Remove one or many callbacks. If `context` is null, removes all callbacks\n     * with that function. If `callback` is null, removes all callbacks for the\n     * event. If `events` is null, removes all bound callbacks for all events.\n     */\n    off: function(events, callback, context) {\n      var event, calls, node, tail, cb, ctx;\n\n      // No events, or removing *all* events.\n      if (!(calls = this._callbacks)) {\n        return;\n      }\n      if (!(events || callback || context)) {\n        delete this._callbacks;\n        return this;\n      }\n\n      // Loop through the listed events and contexts, splicing them out of the\n      // linked list of callbacks if appropriate.\n      events = events ? events.split(eventSplitter) : Object.keys(calls);\n      event = events.shift();\n      while (event) {\n        node = calls[event];\n        delete calls[event];\n        if (!node || !(callback || context)) {\n          event = events.shift();\n          continue;\n        }\n        // Create a new list, omitting the indicated callbacks.\n        tail = node.tail;\n        node = node.next;\n        while (node !== tail) {\n          cb = node.callback;\n          ctx = node.context;\n          if ((callback && cb !== callback) || (context && ctx !== context)) {\n            this.on(event, cb, ctx);\n          }\n          node = node.next;\n        }\n        event = events.shift();\n      }\n\n      return this;\n    },\n\n    /**\n     * Trigger one or many events, firing all bound callbacks. Callbacks are\n     * passed the same arguments as `trigger` is, apart from the event name\n     * (unless you're listening on `\"all\"`, which will cause your callback to\n     * receive the true name of the event as the first argument).\n     */\n    trigger: function(events) {\n      var event, node, calls, tail, args, all, rest;\n      if (!(calls = this._callbacks)) {\n        return this;\n      }\n      all = calls.all;\n      events = events.split(eventSplitter);\n      rest = slice.call(arguments, 1);\n\n      // For each event, walk through the linked list of callbacks twice,\n      // first to trigger the event, then to trigger any `\"all\"` callbacks.\n      event = events.shift();\n      while (event) {\n        node = calls[event];\n        if (node) {\n          tail = node.tail;\n          while ((node = node.next) !== tail) {\n            node.callback.apply(node.context || this, rest);\n          }\n        }\n        node = all;\n        if (node) {\n          tail = node.tail;\n          args = [event].concat(rest);\n          while ((node = node.next) !== tail) {\n            node.callback.apply(node.context || this, args);\n          }\n        }\n        event = events.shift();\n      }\n\n      return this;\n    }\n  };  \n\n  /**\n   * @function\n   */\n  Parse.Events.bind = Parse.Events.on;\n\n  /**\n   * @function\n   */\n  Parse.Events.unbind = Parse.Events.off;\n}.call(this));\n\n\n/*global navigator: false */\n(function(root) {\n  root.Parse = root.Parse || {};\n  var Parse = root.Parse;\n  var _ = Parse._;\n\n  /**\n   * Creates a new GeoPoint with any of the following forms:<br>\n   *   <pre>\n   *   new GeoPoint(otherGeoPoint)\n   *   new GeoPoint(30, 30)\n   *   new GeoPoint([30, 30])\n   *   new GeoPoint({latitude: 30, longitude: 30})\n   *   new GeoPoint()  // defaults to (0, 0)\n   *   </pre>\n   * @class\n   *\n   * <p>Represents a latitude / longitude point that may be associated\n   * with a key in a ParseObject or used as a reference point for geo queries.\n   * This allows proximity-based queries on the key.</p>\n   *\n   * <p>Only one key in a class may contain a GeoPoint.</p>\n   *\n   * <p>Example:<pre>\n   *   var point = new Parse.GeoPoint(30.0, -20.0);\n   *   var object = new Parse.Object(\"PlaceObject\");\n   *   object.set(\"location\", point);\n   *   object.save();</pre></p>\n   */\n  Parse.GeoPoint = function(arg1, arg2) {\n    if (_.isArray(arg1)) {\n      Parse.GeoPoint._validate(arg1[0], arg1[1]);\n      this.latitude = arg1[0];\n      this.longitude = arg1[1];\n    } else if (_.isObject(arg1)) {\n      Parse.GeoPoint._validate(arg1.latitude, arg1.longitude);\n      this.latitude = arg1.latitude;\n      this.longitude = arg1.longitude;\n    } else if (_.isNumber(arg1) && _.isNumber(arg2)) {\n      Parse.GeoPoint._validate(arg1, arg2);\n      this.latitude = arg1;\n      this.longitude = arg2;\n    } else {\n      this.latitude = 0;\n      this.longitude = 0;\n    }\n\n    // Add properties so that anyone using Webkit or Mozilla will get an error\n    // if they try to set values that are out of bounds.\n    var self = this;\n    if (this.__defineGetter__ && this.__defineSetter__) {\n      // Use _latitude and _longitude to actually store the values, and add\n      // getters and setters for latitude and longitude.\n      this._latitude = this.latitude;\n      this._longitude = this.longitude;\n      this.__defineGetter__(\"latitude\", function() {\n        return self._latitude;\n      });\n      this.__defineGetter__(\"longitude\", function() {\n        return self._longitude;\n      });\n      this.__defineSetter__(\"latitude\", function(val) {\n        Parse.GeoPoint._validate(val, self.longitude);\n        self._latitude = val;\n      });\n      this.__defineSetter__(\"longitude\", function(val) {\n        Parse.GeoPoint._validate(self.latitude, val);\n        self._longitude = val;\n      });\n    }\n  };\n\n  /**\n   * @lends Parse.GeoPoint.prototype\n   * @property {float} latitude North-south portion of the coordinate, in range\n   *   [-90, 90].  Throws an exception if set out of range in a modern browser.\n   * @property {float} longitude East-west portion of the coordinate, in range\n   *   [-180, 180].  Throws if set out of range in a modern browser.\n   */\n\n  /**\n   * Throws an exception if the given lat-long is out of bounds.\n   */\n  Parse.GeoPoint._validate = function(latitude, longitude) {\n    if (latitude < -90.0) {\n      throw \"Parse.GeoPoint latitude \" + latitude + \" < -90.0.\";\n    }\n    if (latitude > 90.0) {\n      throw \"Parse.GeoPoint latitude \" + latitude + \" > 90.0.\";\n    }\n    if (longitude < -180.0) {\n      throw \"Parse.GeoPoint longitude \" + longitude + \" < -180.0.\";\n    }\n    if (longitude > 180.0) {\n      throw \"Parse.GeoPoint longitude \" + longitude + \" > 180.0.\";\n    }\n  };\n\n  /**\n   * Creates a GeoPoint with the user's current location, if available.\n   * Calls options.success with a new GeoPoint instance or calls options.error.\n   * @param {Object} options An object with success and error callbacks.\n   */\n  Parse.GeoPoint.current = function(options) {\n    var promise = new Parse.Promise();\n    navigator.geolocation.getCurrentPosition(function(location) {\n      promise.resolve(new Parse.GeoPoint({\n        latitude: location.coords.latitude,\n        longitude: location.coords.longitude\n      }));\n\n    }, function(error) {\n      promise.reject(error);\n    });\n\n    return promise._thenRunCallbacks(options);\n  };\n\n  Parse.GeoPoint.prototype = {\n    /**\n     * Returns a JSON representation of the GeoPoint, suitable for Parse.\n     * @return {Object}\n     */\n    toJSON: function() {\n      Parse.GeoPoint._validate(this.latitude, this.longitude);\n      return {\n        \"__type\": \"GeoPoint\",\n        latitude: this.latitude,\n        longitude: this.longitude\n      };\n    },\n\n    /**\n     * Returns the distance from this GeoPoint to another in radians.\n     * @param {Parse.GeoPoint} point the other Parse.GeoPoint.\n     * @return {Number}\n     */\n    radiansTo: function(point) {\n      var d2r = Math.PI / 180.0;\n      var lat1rad = this.latitude * d2r;\n      var long1rad = this.longitude * d2r;\n      var lat2rad = point.latitude * d2r;\n      var long2rad = point.longitude * d2r;\n      var deltaLat = lat1rad - lat2rad;\n      var deltaLong = long1rad - long2rad;\n      var sinDeltaLatDiv2 = Math.sin(deltaLat / 2);\n      var sinDeltaLongDiv2 = Math.sin(deltaLong / 2);\n      // Square of half the straight line chord distance between both points.\n      var a = ((sinDeltaLatDiv2 * sinDeltaLatDiv2) +\n               (Math.cos(lat1rad) * Math.cos(lat2rad) *\n                sinDeltaLongDiv2 * sinDeltaLongDiv2));\n      a = Math.min(1.0, a);\n      return 2 * Math.asin(Math.sqrt(a));\n    },\n\n    /**\n     * Returns the distance from this GeoPoint to another in kilometers.\n     * @param {Parse.GeoPoint} point the other Parse.GeoPoint.\n     * @return {Number}\n     */\n    kilometersTo: function(point) {\n      return this.radiansTo(point) * 6371.0;\n    },\n\n    /**\n     * Returns the distance from this GeoPoint to another in miles.\n     * @param {Parse.GeoPoint} point the other Parse.GeoPoint.\n     * @return {Number}\n     */\n    milesTo: function(point) {\n      return this.radiansTo(point) * 3958.8;\n    }\n  };\n}(this));\n\n/*global navigator: false */\n(function(root) {\n  root.Parse = root.Parse || {};\n  var Parse = root.Parse;\n  var _ = Parse._;\n\n  var PUBLIC_KEY = \"*\";\n\n  /**\n   * Creates a new ACL.\n   * If no argument is given, the ACL has no permissions for anyone.\n   * If the argument is a Parse.User, the ACL will have read and write\n   *   permission for only that user.\n   * If the argument is any other JSON object, that object will be interpretted\n   *   as a serialized ACL created with toJSON().\n   * @see Parse.Object#setACL\n   * @class\n   *\n   * <p>An ACL, or Access Control List can be added to any\n   * <code>Parse.Object</code> to restrict access to only a subset of users\n   * of your application.</p>\n   */\n  Parse.ACL = function(arg1) {\n    var self = this;\n    self.permissionsById = {};\n    if (_.isObject(arg1)) {\n      if (arg1 instanceof Parse.User) {\n        self.setReadAccess(arg1, true);\n        self.setWriteAccess(arg1, true);\n      } else {\n        if (_.isFunction(arg1)) {\n          throw \"Parse.ACL() called with a function.  Did you forget ()?\";\n        }\n        Parse._objectEach(arg1, function(accessList, userId) {\n          if (!_.isString(userId)) {\n            throw \"Tried to create an ACL with an invalid userId.\";\n          }\n          self.permissionsById[userId] = {};\n          Parse._objectEach(accessList, function(allowed, permission) {\n            if (permission !== \"read\" && permission !== \"write\") {\n              throw \"Tried to create an ACL with an invalid permission type.\";\n            }\n            if (!_.isBoolean(allowed)) {\n              throw \"Tried to create an ACL with an invalid permission value.\";\n            }\n            self.permissionsById[userId][permission] = allowed;\n          });\n        });\n      }\n    }\n  };\n\n  /**\n   * Returns a JSON-encoded version of the ACL.\n   * @return {Object}\n   */\n  Parse.ACL.prototype.toJSON = function() {\n    return _.clone(this.permissionsById);\n  };\n\n  Parse.ACL.prototype._setAccess = function(accessType, userId, allowed) {\n    if (userId instanceof Parse.User) {\n      userId = userId.id;\n    } else if (userId instanceof Parse.Role) {\n      userId = \"role:\" + userId.getName();\n    }\n    if (!_.isString(userId)) {\n      throw \"userId must be a string.\";\n    }\n    if (!_.isBoolean(allowed)) {\n      throw \"allowed must be either true or false.\";\n    }\n    var permissions = this.permissionsById[userId];\n    if (!permissions) {\n      if (!allowed) {\n        // The user already doesn't have this permission, so no action needed.\n        return;\n      } else {\n        permissions = {};\n        this.permissionsById[userId] = permissions;\n      }\n    }\n\n    if (allowed) {\n      this.permissionsById[userId][accessType] = true;\n    } else {\n      delete permissions[accessType];\n      if (_.isEmpty(permissions)) {\n        delete permissions[userId];\n      }\n    }\n  };\n\n  Parse.ACL.prototype._getAccess = function(accessType, userId) {\n    if (userId instanceof Parse.User) {\n      userId = userId.id;\n    } else if (userId instanceof Parse.Role) {\n      userId = \"role:\" + userId.getName();\n    }\n    var permissions = this.permissionsById[userId];\n    if (!permissions) {\n      return false;\n    }\n    return permissions[accessType] ? true : false;\n  };\n\n  /**\n   * Set whether the given user is allowed to read this object.\n   * @param userId An instance of Parse.User or its objectId.\n   * @param {Boolean} allowed Whether that user should have read access.\n   */\n  Parse.ACL.prototype.setReadAccess = function(userId, allowed) {\n    this._setAccess(\"read\", userId, allowed);\n  };\n\n  /**\n   * Get whether the given user id is *explicitly* allowed to read this object.\n   * Even if this returns false, the user may still be able to access it if\n   * getPublicReadAccess returns true or a role that the user belongs to has\n   * write access.\n   * @param userId An instance of Parse.User or its objectId, or a Parse.Role.\n   * @return {Boolean}\n   */\n  Parse.ACL.prototype.getReadAccess = function(userId) {\n    return this._getAccess(\"read\", userId);\n  };\n\n  /**\n   * Set whether the given user id is allowed to write this object.\n   * @param userId An instance of Parse.User or its objectId, or a Parse.Role..\n   * @param {Boolean} allowed Whether that user should have write access.\n   */\n  Parse.ACL.prototype.setWriteAccess = function(userId, allowed) {\n    this._setAccess(\"write\", userId, allowed);\n  };\n\n  /**\n   * Get whether the given user id is *explicitly* allowed to write this object.\n   * Even if this returns false, the user may still be able to write it if\n   * getPublicWriteAccess returns true or a role that the user belongs to has\n   * write access.\n   * @param userId An instance of Parse.User or its objectId, or a Parse.Role.\n   * @return {Boolean}\n   */\n  Parse.ACL.prototype.getWriteAccess = function(userId) {\n    return this._getAccess(\"write\", userId);\n  };\n\n  /**\n   * Set whether the public is allowed to read this object.\n   * @param {Boolean} allowed\n   */\n  Parse.ACL.prototype.setPublicReadAccess = function(allowed) {\n    this.setReadAccess(PUBLIC_KEY, allowed);\n  };\n\n  /**\n   * Get whether the public is allowed to read this object.\n   * @return {Boolean}\n   */\n  Parse.ACL.prototype.getPublicReadAccess = function() {\n    return this.getReadAccess(PUBLIC_KEY);\n  };\n\n  /**\n   * Set whether the public is allowed to write this object.\n   * @param {Boolean} allowed\n   */\n  Parse.ACL.prototype.setPublicWriteAccess = function(allowed) {\n    this.setWriteAccess(PUBLIC_KEY, allowed);\n  };\n\n  /**\n   * Get whether the public is allowed to write this object.\n   * @return {Boolean}\n   */\n  Parse.ACL.prototype.getPublicWriteAccess = function() {\n    return this.getWriteAccess(PUBLIC_KEY);\n  };\n  \n  /**\n   * Get whether users belonging to the given role are allowed\n   * to read this object. Even if this returns false, the role may\n   * still be able to write it if a parent role has read access.\n   * \n   * @param role The name of the role, or a Parse.Role object.\n   * @return {Boolean} true if the role has read access. false otherwise.\n   * @throws {String} If role is neither a Parse.Role nor a String.\n   */\n  Parse.ACL.prototype.getRoleReadAccess = function(role) {\n    if (role instanceof Parse.Role) {\n      // Normalize to the String name\n      role = role.getName();\n    }\n    if (_.isString(role)) {\n      return this.getReadAccess(\"role:\" + role);\n    }\n    throw \"role must be a Parse.Role or a String\";\n  };\n  \n  /**\n   * Get whether users belonging to the given role are allowed\n   * to write this object. Even if this returns false, the role may\n   * still be able to write it if a parent role has write access.\n   * \n   * @param role The name of the role, or a Parse.Role object.\n   * @return {Boolean} true if the role has write access. false otherwise.\n   * @throws {String} If role is neither a Parse.Role nor a String.\n   */\n  Parse.ACL.prototype.getRoleWriteAccess = function(role) {\n    if (role instanceof Parse.Role) {\n      // Normalize to the String name\n      role = role.getName();\n    }\n    if (_.isString(role)) {\n      return this.getWriteAccess(\"role:\" + role);\n    }\n    throw \"role must be a Parse.Role or a String\";\n  };\n  \n  /**\n   * Set whether users belonging to the given role are allowed\n   * to read this object.\n   * \n   * @param role The name of the role, or a Parse.Role object.\n   * @param {Boolean} allowed Whether the given role can read this object.\n   * @throws {String} If role is neither a Parse.Role nor a String.\n   */\n  Parse.ACL.prototype.setRoleReadAccess = function(role, allowed) {\n    if (role instanceof Parse.Role) {\n      // Normalize to the String name\n      role = role.getName();\n    }\n    if (_.isString(role)) {\n      this.setReadAccess(\"role:\" + role, allowed);\n      return;\n    }\n    throw \"role must be a Parse.Role or a String\";\n  };\n  \n  /**\n   * Set whether users belonging to the given role are allowed\n   * to write this object.\n   * \n   * @param role The name of the role, or a Parse.Role object.\n   * @param {Boolean} allowed Whether the given role can write this object.\n   * @throws {String} If role is neither a Parse.Role nor a String.\n   */\n  Parse.ACL.prototype.setRoleWriteAccess = function(role, allowed) {\n    if (role instanceof Parse.Role) {\n      // Normalize to the String name\n      role = role.getName();\n    }\n    if (_.isString(role)) {\n      this.setWriteAccess(\"role:\" + role, allowed);\n      return;\n    }\n    throw \"role must be a Parse.Role or a String\";\n  };\n\n}(this));\n\n(function(root) {\n  root.Parse = root.Parse || {};\n  var Parse = root.Parse;\n  var _ = Parse._;\n\n  /**\n   * @class\n   * A Parse.Op is an atomic operation that can be applied to a field in a\n   * Parse.Object. For example, calling <code>object.set(\"foo\", \"bar\")</code>\n   * is an example of a Parse.Op.Set. Calling <code>object.unset(\"foo\")</code>\n   * is a Parse.Op.Unset. These operations are stored in a Parse.Object and\n   * sent to the server as part of <code>object.save()</code> operations.\n   * Instances of Parse.Op should be immutable.\n   *\n   * You should not create subclasses of Parse.Op or instantiate Parse.Op\n   * directly.\n   */\n  Parse.Op = function() {\n    this._initialize.apply(this, arguments);\n  };\n\n  Parse.Op.prototype = {\n    _initialize: function() {}\n  };\n\n  _.extend(Parse.Op, {\n    /**\n     * To create a new Op, call Parse.Op._extend();\n     */\n    _extend: Parse._extend,\n\n    // A map of __op string to decoder function.\n    _opDecoderMap: {},\n\n    /**\n     * Registers a function to convert a json object with an __op field into an\n     * instance of a subclass of Parse.Op.\n     */\n    _registerDecoder: function(opName, decoder) {\n      Parse.Op._opDecoderMap[opName] = decoder;\n    },\n\n    /**\n     * Converts a json object into an instance of a subclass of Parse.Op.\n     */\n    _decode: function(json) {\n      var decoder = Parse.Op._opDecoderMap[json.__op];\n      if (decoder) {\n        return decoder(json);\n      } else {\n        return undefined;\n      }\n    }\n  });\n\n  /*\n   * Add a handler for Batch ops.\n   */\n  Parse.Op._registerDecoder(\"Batch\", function(json) {\n    var op = null;\n    Parse._arrayEach(json.ops, function(nextOp) {\n      nextOp = Parse.Op._decode(nextOp);\n      op = nextOp._mergeWithPrevious(op);\n    });\n    return op;\n  });\n\n  /**\n   * @class\n   * A Set operation indicates that either the field was changed using\n   * Parse.Object.set, or it is a mutable container that was detected as being\n   * changed.\n   */\n  Parse.Op.Set = Parse.Op._extend(/** @lends Parse.Op.Set.prototype */ {\n    _initialize: function(value) {\n      this._value = value;\n    },\n\n    /**\n     * Returns the new value of this field after the set.\n     */\n    value: function() {\n      return this._value;\n    },\n\n    /**\n     * Returns a JSON version of the operation suitable for sending to Parse.\n     * @return {Object}\n     */\n    toJSON: function() {\n      return Parse._encode(this.value());\n    },\n\n    _mergeWithPrevious: function(previous) {\n      return this;\n    },\n\n    _estimate: function(oldValue) {\n      return this.value();\n    }\n  });\n\n  /**\n   * A sentinel value that is returned by Parse.Op.Unset._estimate to\n   * indicate the field should be deleted. Basically, if you find _UNSET as a\n   * value in your object, you should remove that key.\n   */\n  Parse.Op._UNSET = {};\n\n  /**\n   * @class\n   * An Unset operation indicates that this field has been deleted from the\n   * object.\n   */\n  Parse.Op.Unset = Parse.Op._extend(/** @lends Parse.Op.Unset.prototype */ {\n    /**\n     * Returns a JSON version of the operation suitable for sending to Parse.\n     * @return {Object}\n     */\n    toJSON: function() {\n      return { __op: \"Delete\" };\n    },\n\n    _mergeWithPrevious: function(previous) {\n      return this;\n    },\n\n    _estimate: function(oldValue) {\n      return Parse.Op._UNSET;\n    }\n  });\n\n  Parse.Op._registerDecoder(\"Delete\", function(json) {\n    return new Parse.Op.Unset();\n  });\n\n  /**\n   * @class\n   * An Increment is an atomic operation where the numeric value for the field\n   * will be increased by a given amount.\n   */\n  Parse.Op.Increment = Parse.Op._extend(\n      /** @lends Parse.Op.Increment.prototype */ {\n\n    _initialize: function(amount) {\n      this._amount = amount;\n    },\n\n    /**\n     * Returns the amount to increment by.\n     * @return {Number} the amount to increment by.\n     */\n    amount: function() {\n      return this._amount;\n    },\n\n    /**\n     * Returns a JSON version of the operation suitable for sending to Parse.\n     * @return {Object}\n     */\n    toJSON: function() {\n      return { __op: \"Increment\", amount: this._amount };\n    },\n\n    _mergeWithPrevious: function(previous) {\n      if (!previous) {\n        return this;\n      } else if (previous instanceof Parse.Op.Unset) {\n        return new Parse.Op.Set(this.amount());\n      } else if (previous instanceof Parse.Op.Set) {\n        return new Parse.Op.Set(previous.value() + this.amount());\n      } else if (previous instanceof Parse.Op.Increment) {\n        return new Parse.Op.Increment(this.amount() + previous.amount());\n      } else {\n        throw \"Op is invalid after previous op.\";\n      }\n    },\n\n    _estimate: function(oldValue) {\n      if (!oldValue) {\n        return this.amount();\n      }\n      return oldValue + this.amount();\n    }\n  });\n\n  Parse.Op._registerDecoder(\"Increment\", function(json) {\n    return new Parse.Op.Increment(json.amount);\n  });\n\n  /**\n   * @class\n   * Add is an atomic operation where the given objects will be appended to the\n   * array that is stored in this field.\n   */\n  Parse.Op.Add = Parse.Op._extend(/** @lends Parse.Op.Add.prototype */ {\n    _initialize: function(objects) {\n      this._objects = objects;\n    },\n\n    /**\n     * Returns the objects to be added to the array.\n     * @return {Array} The objects to be added to the array.\n     */\n    objects: function() {\n      return this._objects;\n    },\n\n    /**\n     * Returns a JSON version of the operation suitable for sending to Parse.\n     * @return {Object}\n     */\n    toJSON: function() {\n      return { __op: \"Add\", objects: Parse._encode(this.objects()) };\n    },\n\n    _mergeWithPrevious: function(previous) {\n      if (!previous) {\n        return this;\n      } else if (previous instanceof Parse.Op.Unset) {\n        return new Parse.Op.Set(this.objects());\n      } else if (previous instanceof Parse.Op.Set) {\n        return new Parse.Op.Set(this._estimate(previous.value()));\n      } else if (previous instanceof Parse.Op.Add) {\n        return new Parse.Op.Add(previous.objects().concat(this.objects()));\n      } else {\n        throw \"Op is invalid after previous op.\";\n      }\n    },\n\n    _estimate: function(oldValue) {\n      if (!oldValue) {\n        return _.clone(this.objects());\n      } else {\n        return oldValue.concat(this.objects());\n      }\n    }\n  });\n\n  Parse.Op._registerDecoder(\"Add\", function(json) {\n    return new Parse.Op.Add(Parse._decode(undefined, json.objects));\n  });\n\n  /**\n   * @class\n   * AddUnique is an atomic operation where the given items will be appended to\n   * the array that is stored in this field only if they were not already\n   * present in the array.\n   */\n  Parse.Op.AddUnique = Parse.Op._extend(\n      /** @lends Parse.Op.AddUnique.prototype */ {\n\n    _initialize: function(objects) {\n      this._objects = _.uniq(objects);\n    },\n\n    /**\n     * Returns the objects to be added to the array.\n     * @return {Array} The objects to be added to the array.\n     */\n    objects: function() {\n      return this._objects;\n    },\n\n    /**\n     * Returns a JSON version of the operation suitable for sending to Parse.\n     * @return {Object}\n     */\n    toJSON: function() {\n      return { __op: \"AddUnique\", objects: Parse._encode(this.objects()) };\n    },\n\n    _mergeWithPrevious: function(previous) {\n      if (!previous) {\n        return this;\n      } else if (previous instanceof Parse.Op.Unset) {\n        return new Parse.Op.Set(this.objects());\n      } else if (previous instanceof Parse.Op.Set) {\n        return new Parse.Op.Set(this._estimate(previous.value()));\n      } else if (previous instanceof Parse.Op.AddUnique) {\n        return new Parse.Op.AddUnique(this._estimate(previous.objects()));\n      } else {\n        throw \"Op is invalid after previous op.\";\n      }\n    },\n\n    _estimate: function(oldValue) {\n      if (!oldValue) {\n        return _.clone(this.objects());\n      } else {\n        // We can't just take the _.uniq(_.union(...)) of oldValue and\n        // this.objects, because the uniqueness may not apply to oldValue\n        // (especially if the oldValue was set via .set())\n        var newValue = _.clone(oldValue);\n        Parse._arrayEach(this.objects(), function(obj) {\n          if (obj instanceof Parse.Object && obj.id) {\n            var matchingObj = _.find(newValue, function(anObj) {\n              return (anObj instanceof Parse.Object) && (anObj.id === obj.id);\n            });\n            if (!matchingObj) {\n              newValue.push(obj);\n            } else {\n              var index = _.indexOf(newValue, matchingObj);\n              newValue[index] = obj;\n            }\n          } else if (!_.contains(newValue, obj)) {\n            newValue.push(obj);\n          }\n        });\n        return newValue;\n      }\n    }\n  });\n\n  Parse.Op._registerDecoder(\"AddUnique\", function(json) {\n    return new Parse.Op.AddUnique(Parse._decode(undefined, json.objects));\n  });\n\n  /**\n   * @class\n   * Remove is an atomic operation where the given objects will be removed from\n   * the array that is stored in this field.\n   */\n  Parse.Op.Remove = Parse.Op._extend(/** @lends Parse.Op.Remove.prototype */ {\n    _initialize: function(objects) {\n      this._objects = _.uniq(objects);\n    },\n\n    /**\n     * Returns the objects to be removed from the array.\n     * @return {Array} The objects to be removed from the array.\n     */\n    objects: function() {\n      return this._objects;\n    },\n\n    /**\n     * Returns a JSON version of the operation suitable for sending to Parse.\n     * @return {Object}\n     */\n    toJSON: function() {\n      return { __op: \"Remove\", objects: Parse._encode(this.objects()) };\n    },\n\n    _mergeWithPrevious: function(previous) {\n      if (!previous) {\n        return this;\n      } else if (previous instanceof Parse.Op.Unset) {\n        return previous;\n      } else if (previous instanceof Parse.Op.Set) {\n        return new Parse.Op.Set(this._estimate(previous.value()));\n      } else if (previous instanceof Parse.Op.Remove) {\n        return new Parse.Op.Remove(_.union(previous.objects(), this.objects()));\n      } else {\n        throw \"Op is invalid after previous op.\";\n      }\n    },\n\n    _estimate: function(oldValue) {\n      if (!oldValue) {\n        return [];\n      } else {\n        var newValue = _.difference(oldValue, this.objects());\n        // If there are saved Parse Objects being removed, also remove them.\n        Parse._arrayEach(this.objects(), function(obj) {\n          if (obj instanceof Parse.Object && obj.id) {\n            newValue = _.reject(newValue, function(other) {\n              return (other instanceof Parse.Object) && (other.id === obj.id);\n            });\n          }\n        });\n        return newValue;\n      }\n    }\n  });\n\n  Parse.Op._registerDecoder(\"Remove\", function(json) {\n    return new Parse.Op.Remove(Parse._decode(undefined, json.objects));\n  });\n\n  /**\n   * @class\n   * A Relation operation indicates that the field is an instance of\n   * Parse.Relation, and objects are being added to, or removed from, that\n   * relation.\n   */\n  Parse.Op.Relation = Parse.Op._extend(\n      /** @lends Parse.Op.Relation.prototype */ {\n\n    _initialize: function(adds, removes) {\n      this._targetClassName = null;\n\n      var self = this;\n\n      var pointerToId = function(object) {\n        if (object instanceof Parse.Object) {\n          if (!object.id) {\n            throw \"You can't add an unsaved Parse.Object to a relation.\";\n          }\n          if (!self._targetClassName) {\n            self._targetClassName = object.className;\n          }\n          if (self._targetClassName !== object.className) {\n            throw \"Tried to create a Parse.Relation with 2 different types: \" +\n                  self._targetClassName + \" and \" + object.className + \".\";\n          }\n          return object.id;\n        }\n        return object;\n      };\n\n      this.relationsToAdd = _.uniq(_.map(adds, pointerToId));\n      this.relationsToRemove = _.uniq(_.map(removes, pointerToId));\n    },\n\n    /**\n     * Returns an array of unfetched Parse.Object that are being added to the\n     * relation.\n     * @return {Array}\n     */\n    added: function() {\n      var self = this;\n      return _.map(this.relationsToAdd, function(objectId) {\n        var object = Parse.Object._create(self._targetClassName);\n        object.id = objectId;\n        return object;\n      });\n    },\n\n    /**\n     * Returns an array of unfetched Parse.Object that are being removed from\n     * the relation.\n     * @return {Array}\n     */\n    removed: function() {\n      var self = this;\n      return _.map(this.relationsToRemove, function(objectId) {\n        var object = Parse.Object._create(self._targetClassName);\n        object.id = objectId;\n        return object;\n      });\n    },\n\n    /**\n     * Returns a JSON version of the operation suitable for sending to Parse.\n     * @return {Object}\n     */\n    toJSON: function() {\n      var adds = null;\n      var removes = null;\n      var self = this;\n      var idToPointer = function(id) {\n        return { __type: 'Pointer',\n                 className: self._targetClassName,\n                 objectId: id };\n      };\n      var pointers = null;\n      if (this.relationsToAdd.length > 0) {\n        pointers = _.map(this.relationsToAdd, idToPointer);\n        adds = { \"__op\": \"AddRelation\", \"objects\": pointers };\n      }\n\n      if (this.relationsToRemove.length > 0) {\n        pointers = _.map(this.relationsToRemove, idToPointer);\n        removes = { \"__op\": \"RemoveRelation\", \"objects\": pointers };\n      }\n\n      if (adds && removes) {\n        return { \"__op\": \"Batch\", \"ops\": [adds, removes]};\n      }\n\n      return adds || removes || {};\n    },\n\n    _mergeWithPrevious: function(previous) {\n      if (!previous) {\n        return this;\n      } else if (previous instanceof Parse.Op.Unset) {\n        throw \"You can't modify a relation after deleting it.\";\n      } else if (previous instanceof Parse.Op.Relation) {\n        if (previous._targetClassName &&\n            previous._targetClassName !== this._targetClassName) {\n          throw \"Related object must be of class \" + previous._targetClassName +\n              \", but \" + this._targetClassName + \" was passed in.\";\n        }\n        var newAdd = _.union(_.difference(previous.relationsToAdd,\n                                          this.relationsToRemove),\n                             this.relationsToAdd);\n        var newRemove = _.union(_.difference(previous.relationsToRemove,\n                                             this.relationsToAdd),\n                                this.relationsToRemove);\n\n        var newRelation = new Parse.Op.Relation(newAdd, newRemove);\n        newRelation._targetClassName = this._targetClassName;\n        return newRelation;\n      } else {\n        throw \"Op is invalid after previous op.\";\n      }\n    },\n\n    _estimate: function(oldValue, object, key) {\n      if (!oldValue) {\n        var relation = new Parse.Relation(object, key);\n        relation.targetClassName = this._targetClassName;\n      } else if (oldValue instanceof Parse.Relation) {\n        if (this._targetClassName) {\n          if (oldValue.targetClassName) {\n            if (oldValue.targetClassName !== this._targetClassName) {\n              throw \"Related object must be a \" + oldValue.targetClassName +\n                  \", but a \" + this._targetClassName + \" was passed in.\";\n            }\n          } else {\n            oldValue.targetClassName = this._targetClassName;\n          }\n        }\n        return oldValue;\n      } else {\n        throw \"Op is invalid after previous op.\";\n      }\n    }\n  });\n\n  Parse.Op._registerDecoder(\"AddRelation\", function(json) {\n    return new Parse.Op.Relation(Parse._decode(undefined, json.objects), []);\n  });\n  Parse.Op._registerDecoder(\"RemoveRelation\", function(json) {\n    return new Parse.Op.Relation([], Parse._decode(undefined, json.objects));\n  });\n\n}(this));\n\n(function(root) {\n  root.Parse = root.Parse || {};\n  var Parse = root.Parse;\n  var _ = Parse._;\n\n  /**\n   * Creates a new Relation for the given parent object and key. This\n   * constructor should rarely be used directly, but rather created by\n   * Parse.Object.relation.\n   * @param {Parse.Object} parent The parent of this relation.\n   * @param {String} key The key for this relation on the parent.\n   * @see Parse.Object#relation\n   * @class\n   *\n   * <p>\n   * A class that is used to access all of the children of a many-to-many\n   * relationship.  Each instance of Parse.Relation is associated with a\n   * particular parent object and key.\n   * </p>\n   */\n  Parse.Relation = function(parent, key) {\n    this.parent = parent;\n    this.key = key;\n    this.targetClassName = null;\n  };\n\n  Parse.Relation.prototype = {\n    /**\n     * Makes sure that this relation has the right parent and key.\n     */\n    _ensureParentAndKey: function(parent, key) {\n      this.parent = this.parent || parent;\n      this.key = this.key || key;\n      if (this.parent !== parent) {\n        throw \"Internal Error. Relation retrieved from two different Objects.\";\n      }\n      if (this.key !== key) {\n        throw \"Internal Error. Relation retrieved from two different keys.\";\n      }\n    },\n\n    /**\n     * Adds a Parse.Object or an array of Parse.Objects to the relation.\n     * @param {} objects The item or items to add.\n     */\n    add: function(objects) {\n      if (!_.isArray(objects)) {\n        objects = [objects];\n      }\n\n      var change = new Parse.Op.Relation(objects, []);\n      this.parent.set(this.key, change);\n      this.targetClassName = change._targetClassName;\n    },\n\n    /**\n     * Removes a Parse.Object or an array of Parse.Objects from this relation.\n     * @param {} objects The item or items to remove.\n     */\n    remove: function(objects) {\n      if (!_.isArray(objects)) {\n        objects = [objects];\n      }\n\n      var change = new Parse.Op.Relation([], objects);\n      this.parent.set(this.key, change);\n      this.targetClassName = change._targetClassName;\n    },\n\n    /**\n     * Returns a JSON version of the object suitable for saving to disk.\n     * @return {Object}\n     */\n    toJSON: function() {\n      return { \"__type\": \"Relation\", \"className\": this.targetClassName };\n    },\n\n    /**\n     * Returns a Parse.Query that is limited to objects in this\n     * relation.\n     * @return {Parse.Query}\n     */\n    query: function() {\n      var targetClass;\n      var query;\n      if (!this.targetClassName) {\n        targetClass = Parse.Object._getSubclass(this.parent.className);\n        query = new Parse.Query(targetClass);\n        query._extraOptions.redirectClassNameForKey = this.key;\n      } else {\n        targetClass = Parse.Object._getSubclass(this.targetClassName);\n        query = new Parse.Query(targetClass);\n      }\n      query._addCondition(\"$relatedTo\", \"object\", this.parent._toPointer());\n      query._addCondition(\"$relatedTo\", \"key\", this.key);\n\n      return query;\n    }\n  };\n}(this));\n\n/*global window: false, process: false */\n(function(root) {\n  root.Parse = root.Parse || {};\n  var Parse = root.Parse;\n  var _ = Parse._;\n\n  /**\n   * A Promise is returned by async methods as a hook to provide callbacks to be\n   * called when the async task is fulfilled.\n   *\n   * <p>Typical usage would be like:<pre>\n   *    query.find().then(function(results) {\n   *      results[0].set(\"foo\", \"bar\");\n   *      return results[0].saveAsync();\n   *    }).then(function(result) {\n   *      console.log(\"Updated \" + result.id);\n   *    });\n   * </pre></p>\n   *\n   * @see Parse.Promise.prototype.then\n   * @class\n   */\n  Parse.Promise = function() {\n    this._resolved = false;\n    this._rejected = false;\n    this._resolvedCallbacks = [];\n    this._rejectedCallbacks = [];\n  };\n\n  _.extend(Parse.Promise, /** @lends Parse.Promise */ {\n\n    _isPromisesAPlusCompliant: false,\n\n    /**\n     * Returns true iff the given object fulfils the Promise interface.\n     * @return {Boolean}\n     */\n    is: function(promise) {\n      return promise && promise.then && _.isFunction(promise.then);\n    },\n\n    /**\n     * Returns a new promise that is resolved with a given value.\n     * @return {Parse.Promise} the new promise.\n     */\n    as: function() {\n      var promise = new Parse.Promise();\n      promise.resolve.apply(promise, arguments);\n      return promise;\n    },\n\n    /**\n     * Returns a new promise that is rejected with a given error.\n     * @return {Parse.Promise} the new promise.\n     */\n    error: function() {\n      var promise = new Parse.Promise();\n      promise.reject.apply(promise, arguments);\n      return promise;\n    },\n\n    /**\n     * Returns a new promise that is fulfilled when all of the input promises\n     * are resolved. If any promise in the list fails, then the returned promise\n     * will fail with the last error. If they all succeed, then the returned\n     * promise will succeed, with the results being the results of all the input\n     * promises. For example: <pre>\n     *   var p1 = Parse.Promise.as(1);\n     *   var p2 = Parse.Promise.as(2);\n     *   var p3 = Parse.Promise.as(3);\n     *\n     *   Parse.Promise.when(p1, p2, p3).then(function(r1, r2, r3) {\n     *     console.log(r1);  // prints 1\n     *     console.log(r2);  // prints 2\n     *     console.log(r3);  // prints 3\n     *   });</pre>\n     *\n     * The input promises can also be specified as an array: <pre>\n     *   var promises = [p1, p2, p3];\n     *   Parse.Promise.when(promises).then(function(r1, r2, r3) {\n     *     console.log(r1);  // prints 1\n     *     console.log(r2);  // prints 2\n     *     console.log(r3);  // prints 3\n     *   });\n     * </pre>\n     * @param {Array} promises a list of promises to wait for.\n     * @return {Parse.Promise} the new promise.\n     */\n    when: function(promises) {\n      // Allow passing in Promises as separate arguments instead of an Array.\n      var objects;\n      if (promises && Parse._isNullOrUndefined(promises.length)) {\n        objects = arguments;\n      } else {\n        objects = promises;\n      }\n\n      var total = objects.length;\n      var hadError = false;\n      var results = [];\n      var errors = [];\n      results.length = objects.length;\n      errors.length = objects.length;\n\n      if (total === 0) {\n        return Parse.Promise.as.apply(this, results);\n      }\n\n      var promise = new Parse.Promise();\n\n      var resolveOne = function() {\n        total = total - 1;\n        if (total === 0) {\n          if (hadError) {\n            promise.reject(errors);\n          } else {\n            promise.resolve.apply(promise, results);\n          }\n        }\n      };\n\n      Parse._arrayEach(objects, function(object, i) {\n        if (Parse.Promise.is(object)) {\n          object.then(function(result) {\n            results[i] = result;\n            resolveOne();\n          }, function(error) {\n            errors[i] = error;\n            hadError = true;\n            resolveOne();\n          });\n        } else {\n          results[i] = object;\n          resolveOne();\n        }\n      });\n\n      return promise;\n    },\n\n    /**\n     * Runs the given asyncFunction repeatedly, as long as the predicate\n     * function returns a truthy value. Stops repeating if asyncFunction returns\n     * a rejected promise.\n     * @param {Function} predicate should return false when ready to stop.\n     * @param {Function} asyncFunction should return a Promise.\n     */\n    _continueWhile: function(predicate, asyncFunction) {\n      if (predicate()) {\n        return asyncFunction().then(function() {\n          return Parse.Promise._continueWhile(predicate, asyncFunction);\n        });\n      }\n      return Parse.Promise.as();\n    }\n  });\n\n  _.extend(Parse.Promise.prototype, /** @lends Parse.Promise.prototype */ {\n\n    /**\n     * Marks this promise as fulfilled, firing any callbacks waiting on it.\n     * @param {Object} result the result to pass to the callbacks.\n     */\n    resolve: function(result) {\n      if (this._resolved || this._rejected) {\n        throw \"A promise was resolved even though it had already been \" +\n          (this._resolved ? \"resolved\" : \"rejected\") + \".\";\n      }\n      this._resolved = true;\n      this._result = arguments;\n      var results = arguments;\n      Parse._arrayEach(this._resolvedCallbacks, function(resolvedCallback) {\n        resolvedCallback.apply(this, results);\n      });\n      this._resolvedCallbacks = [];\n      this._rejectedCallbacks = [];\n    },\n\n    /**\n     * Marks this promise as fulfilled, firing any callbacks waiting on it.\n     * @param {Object} error the error to pass to the callbacks.\n     */\n    reject: function(error) {\n      if (this._resolved || this._rejected) {\n        throw \"A promise was rejected even though it had already been \" +\n          (this._resolved ? \"resolved\" : \"rejected\") + \".\";\n      }\n      this._rejected = true;\n      this._error = error;\n      Parse._arrayEach(this._rejectedCallbacks, function(rejectedCallback) {\n        rejectedCallback(error);\n      });\n      this._resolvedCallbacks = [];\n      this._rejectedCallbacks = [];\n    },\n\n    /**\n     * Adds callbacks to be called when this promise is fulfilled. Returns a new\n     * Promise that will be fulfilled when the callback is complete. It allows\n     * chaining. If the callback itself returns a Promise, then the one returned\n     * by \"then\" will not be fulfilled until that one returned by the callback\n     * is fulfilled.\n     * @param {Function} resolvedCallback Function that is called when this\n     * Promise is resolved. Once the callback is complete, then the Promise\n     * returned by \"then\" will also be fulfilled.\n     * @param {Function} rejectedCallback Function that is called when this\n     * Promise is rejected with an error. Once the callback is complete, then\n     * the promise returned by \"then\" with be resolved successfully. If\n     * rejectedCallback is null, or it returns a rejected Promise, then the\n     * Promise returned by \"then\" will be rejected with that error.\n     * @return {Parse.Promise} A new Promise that will be fulfilled after this\n     * Promise is fulfilled and either callback has completed. If the callback\n     * returned a Promise, then this Promise will not be fulfilled until that\n     * one is.\n     */\n    then: function(resolvedCallback, rejectedCallback) {\n      var promise = new Parse.Promise();\n\n      var wrappedResolvedCallback = function() {\n        var result = arguments;\n        if (resolvedCallback) {\n          if (Parse.Promise._isPromisesAPlusCompliant) {\n            try {\n              result = [resolvedCallback.apply(this, result)];\n            } catch (e) {\n              result = [Parse.Promise.error(e)];\n            }\n          } else {\n            result = [resolvedCallback.apply(this, result)];\n          }\n        }\n        if (result.length === 1 && Parse.Promise.is(result[0])) {\n          result[0].then(function() {\n            promise.resolve.apply(promise, arguments);\n          }, function(error) {\n            promise.reject(error);\n          });\n        } else {\n          promise.resolve.apply(promise, result);\n        }\n      };\n\n      var wrappedRejectedCallback = function(error) {\n        var result = [];\n        if (rejectedCallback) {\n          if (Parse.Promise._isPromisesAPlusCompliant) {\n            try {\n              result = [rejectedCallback(error)];\n            } catch (e) {\n              result = [Parse.Promise.error(e)];\n            }\n          } else {\n            result = [rejectedCallback(error)];\n          }\n          if (result.length === 1 && Parse.Promise.is(result[0])) {\n            result[0].then(function() {\n              promise.resolve.apply(promise, arguments);\n            }, function(error) {\n              promise.reject(error);\n            });\n          } else {\n            if (Parse.Promise._isPromisesAPlusCompliant) {\n              promise.resolve.apply(promise, result);\n            } else {\n              promise.reject(result[0]);\n            }\n          }\n        } else {\n          promise.reject(error);\n        }\n      };\n\n      var runLater = function(func) {\n        func.call();\n      };\n      if (Parse.Promise._isPromisesAPlusCompliant) {\n        if (typeof(window) !== 'undefined' && window.setTimeout) {\n          runLater = function(func) {\n            window.setTimeout(func, 0);\n          };\n        } else if (typeof(process) !== 'undefined' && process.nextTick) {\n          runLater = function(func) {\n            process.nextTick(func);\n          };\n        }\n      }\n\n      var self = this;\n      if (this._resolved) {\n        runLater(function() {\n          wrappedResolvedCallback.apply(self, self._result);\n        });\n      } else if (this._rejected) {\n        runLater(function() {\n          wrappedRejectedCallback(self._error);\n        });\n      } else {\n        this._resolvedCallbacks.push(wrappedResolvedCallback);\n        this._rejectedCallbacks.push(wrappedRejectedCallback);\n      }\n\n      return promise;\n    },\n\n    /**\n     * Add handlers to be called when the promise \n     * is either resolved or rejected\n     */\n    always: function(callback) {\n      return this.then(callback, callback);\n    },\n\n    /**\n     * Add handlers to be called when the Promise object is resolved\n     */\n    done: function(callback) {\n      return this.then(callback);\n    },\n\n    /**\n     * Add handlers to be called when the Promise object is rejected\n     */\n    fail: function(callback) {\n      return this.then(null, callback);\n    },\n\n    /**\n     * Run the given callbacks after this promise is fulfilled.\n     * @param optionsOrCallback {} A Backbone-style options callback, or a\n     * callback function. If this is an options object and contains a \"model\"\n     * attributes, that will be passed to error callbacks as the first argument.\n     * @param model {} If truthy, this will be passed as the first result of\n     * error callbacks. This is for Backbone-compatability.\n     * @return {Parse.Promise} A promise that will be resolved after the\n     * callbacks are run, with the same result as this.\n     */\n    _thenRunCallbacks: function(optionsOrCallback, model) {\n      var options;\n      if (_.isFunction(optionsOrCallback)) {\n        var callback = optionsOrCallback;\n        options = {\n          success: function(result) {\n            callback(result, null);\n          },\n          error: function(error) {\n            callback(null, error);\n          }\n        };\n      } else {\n        options = _.clone(optionsOrCallback);\n      }\n      options = options || {};\n\n      return this.then(function(result) {\n        if (options.success) {\n          options.success.apply(this, arguments);\n        } else if (model) {\n          // When there's no callback, a sync event should be triggered.\n          model.trigger('sync', model, result, options);\n        }\n        return Parse.Promise.as.apply(Parse.Promise, arguments);\n      }, function(error) {\n        if (options.error) {\n          if (!_.isUndefined(model)) {\n            options.error(model, error);\n          } else {\n            options.error(error);\n          }\n        } else if (model) {\n          // When there's no error callback, an error event should be triggered.\n          model.trigger('error', model, error, options);\n        }\n        // By explicitly returning a rejected Promise, this will work with\n        // either jQuery or Promises/A semantics.\n        return Parse.Promise.error(error);\n      });\n    },\n\n    /**\n     * Adds a callback function that should be called regardless of whether\n     * this promise failed or succeeded. The callback will be given either the\n     * array of results for its first argument, or the error as its second,\n     * depending on whether this Promise was rejected or resolved. Returns a\n     * new Promise, like \"then\" would.\n     * @param {Function} continuation the callback.\n     */\n    _continueWith: function(continuation) {\n      return this.then(function() {\n        return continuation(arguments, null);\n      }, function(error) {\n        return continuation(null, error);\n      });\n    }\n\n  });\n\n}(this));\n\n/*jshint bitwise:false *//*global FileReader: true, File: true */\n(function(root) {\n  root.Parse = root.Parse || {};\n  var Parse = root.Parse;\n  var _ = Parse._;\n\n  var b64Digit = function(number) {\n    if (number < 26) {\n      return String.fromCharCode(65 + number);\n    }\n    if (number < 52) {\n      return String.fromCharCode(97 + (number - 26));\n    }\n    if (number < 62) {\n      return String.fromCharCode(48 + (number - 52));\n    }\n    if (number === 62) {\n      return \"+\";\n    }\n    if (number === 63) {\n      return \"/\";\n    }\n    throw \"Tried to encode large digit \" + number + \" in base64.\";\n  };\n\n  var encodeBase64 = function(array) {\n    var chunks = [];\n    chunks.length = Math.ceil(array.length / 3);\n    _.times(chunks.length, function(i) {\n      var b1 = array[i * 3];\n      var b2 = array[i * 3 + 1] || 0;\n      var b3 = array[i * 3 + 2] || 0;\n\n      var has2 = (i * 3 + 1) < array.length;\n      var has3 = (i * 3 + 2) < array.length;\n\n      chunks[i] = [\n        b64Digit((b1 >> 2) & 0x3F),\n        b64Digit(((b1 << 4) & 0x30) | ((b2 >> 4) & 0x0F)),\n        has2 ? b64Digit(((b2 << 2) & 0x3C) | ((b3 >> 6) & 0x03)) : \"=\",\n        has3 ? b64Digit(b3 & 0x3F) : \"=\"\n      ].join(\"\");\n    });\n    return chunks.join(\"\");\n  };\n\n  /**\n   * Reads a File using a FileReader.\n   * @param file {File} the File to read.\n   * @param type {String} (optional) the mimetype to override with.\n   * @return {Parse.Promise} A Promise that will be fulfilled with a\n   *     base64-encoded string of the data and its mime type.\n   */\n  var readAsync = function(file, type) {\n    var promise = new Parse.Promise();\n\n    if (typeof(FileReader) === \"undefined\") {\n      return Parse.Promise.error(new Parse.Error(\n          Parse.Error.FILE_READ_ERROR,\n          \"Attempted to use a FileReader on an unsupported browser.\"));\n    }\n\n    var reader = new FileReader();\n    reader.onloadend = function() {\n      if (reader.readyState !== 2) {\n        promise.reject(new Parse.Error(\n            Parse.Error.FILE_READ_ERROR,\n            \"Error reading file.\"));\n        return;\n      }\n\n      var dataURL = reader.result;\n      var matches = /^data:([^;]*);base64,(.*)$/.exec(dataURL);\n      if (!matches) {\n        promise.reject(new Parse.Error(\n            Parse.Error.FILE_READ_ERROR,\n            \"Unable to interpret data URL: \" + dataURL));\n        return;\n      }\n\n      promise.resolve(matches[2], type || matches[1]);\n    };\n    reader.readAsDataURL(file);\n    return promise;\n  };\n\n  /**\n   * A Parse.File is a local representation of a file that is saved to the Parse\n   * cloud.\n   * @class\n   * @param name {String} The file's name. This will be prefixed by a unique\n   *     value once the file has finished saving. The file name must begin with\n   *     an alphanumeric character, and consist of alphanumeric characters,\n   *     periods, spaces, underscores, or dashes.\n   * @param data {Array} The data for the file, as either:\n   *     1. an Array of byte value Numbers, or\n   *     2. an Object like { base64: \"...\" } with a base64-encoded String.\n   *     3. a File object selected with a file upload control. (3) only works\n   *        in Firefox 3.6+, Safari 6.0.2+, Chrome 7+, and IE 10+.\n   *        For example:<pre>\n   * var fileUploadControl = $(\"#profilePhotoFileUpload\")[0];\n   * if (fileUploadControl.files.length > 0) {\n   *   var file = fileUploadControl.files[0];\n   *   var name = \"photo.jpg\";\n   *   var parseFile = new Parse.File(name, file);\n   *   parseFile.save().then(function() {\n   *     // The file has been saved to Parse.\n   *   }, function(error) {\n   *     // The file either could not be read, or could not be saved to Parse.\n   *   });\n   * }</pre>\n   * @param type {String} Optional Content-Type header to use for the file. If\n   *     this is omitted, the content type will be inferred from the name's\n   *     extension.\n   */\n  Parse.File = function(name, data, type) {\n    this._name = name;\n\n    // Guess the content type from the extension if we need to.\n    var extension = /\\.([^.]*)$/.exec(name);\n    if (extension) {\n      extension = extension[1].toLowerCase();\n    }\n    var specifiedType = type || '';\n\n    if (_.isArray(data)) {\n      this._source = Parse.Promise.as(encodeBase64(data), specifiedType);\n    } else if (data && data.base64) {\n      // if it contains data uri, extract based64 and the type out of it.\n      /*jslint maxlen: 1000*/\n      var dataUriRegexp = /^data:([a-zA-Z]*\\/[a-zA-Z+.-]*);(charset=[a-zA-Z0-9\\-\\/\\s]*,)?base64,(\\S+)/;\n      /*jslint maxlen: 80*/\n\n      var matches = dataUriRegexp.exec(data.base64);\n      if (matches && matches.length > 0) {\n        // if data URI with charset, there will have 4 matches.\n        this._source = Parse.Promise.as(\n          (matches.length === 4 ? matches[3] : matches[2]), matches[1]\n        );\n      } else {\n        this._source = Parse.Promise.as(data.base64, specifiedType);\n      }\n    } else if (typeof(File) !== \"undefined\" && data instanceof File) {\n      this._source = readAsync(data, type);\n    } else if (_.isString(data)) {\n      throw \"Creating a Parse.File from a String is not yet supported.\";\n    }\n  };\n\n  Parse.File.prototype = {\n\n    /**\n     * Gets the name of the file. Before save is called, this is the filename\n     * given by the user. After save is called, that name gets prefixed with a\n     * unique identifier.\n     */\n    name: function() {\n      return this._name;\n    },\n\n    /**\n     * Gets the url of the file. It is only available after you save the file or\n     * after you get the file from a Parse.Object.\n     * @return {String}\n     */\n    url: function() {\n      return this._url;\n    },\n\n    /**\n     * Saves the file to the Parse cloud.\n     * @param {Object} options A Backbone-style options object.\n     * @return {Parse.Promise} Promise that is resolved when the save finishes.\n     */\n    save: function(options) {\n      options= options || {};\n\n      var self = this;\n      if (!self._previousSave) {\n        self._previousSave = self._source.then(function(base64, type) {\n          var data = {\n            base64: base64,\n            _ContentType: type\n          };\n          return Parse._request({\n            route: \"files\",\n            className: self._name,\n            method: 'POST',\n            data: data,\n            useMasterKey: options.useMasterKey\n          });\n\n        }).then(function(response) {\n          self._name = response.name;\n          self._url = response.url;\n          return self;\n        });\n      }\n      return self._previousSave._thenRunCallbacks(options);\n    }\n  };\n\n}(this));\n\n// Parse.Object is analogous to the Java ParseObject.\n// It also implements the same interface as a Backbone model.\n// TODO: multiple dispatch for callbacks\n(function(root) {\n  root.Parse = root.Parse || {};\n  var Parse = root.Parse;\n  var _ = Parse._;\n\n  /**\n   * Creates a new model with defined attributes. A client id (cid) is\n   * automatically generated and assigned for you.\n   *\n   * <p>You won't normally call this method directly.  It is recommended that\n   * you use a subclass of <code>Parse.Object</code> instead, created by calling\n   * <code>extend</code>.</p>\n   *\n   * <p>However, if you don't want to use a subclass, or aren't sure which\n   * subclass is appropriate, you can use this form:<pre>\n   *     var object = new Parse.Object(\"ClassName\");\n   * </pre>\n   * That is basically equivalent to:<pre>\n   *     var MyClass = Parse.Object.extend(\"ClassName\");\n   *     var object = new MyClass();\n   * </pre></p>\n   *\n   * @param {Object} attributes The initial set of data to store in the object.\n   * @param {Object} options A set of Backbone-like options for creating the\n   *     object.  The only option currently supported is \"collection\".\n   * @see Parse.Object.extend\n   *\n   * @class\n   *\n   * <p>The fundamental unit of Parse data, which implements the Backbone Model\n   * interface.</p>\n   */\n  Parse.Object = function(attributes, options) {\n    // Allow new Parse.Object(\"ClassName\") as a shortcut to _create.\n    if (_.isString(attributes)) {\n      return Parse.Object._create.apply(this, arguments);\n    }\n\n    attributes = attributes || {};\n    if (options && options.parse) {\n      attributes = this.parse(attributes);\n    }\n    var defaults = Parse._getValue(this, 'defaults');\n    if (defaults) {\n      attributes = _.extend({}, defaults, attributes);\n    }\n    if (options && options.collection) {\n      this.collection = options.collection;\n    }\n\n    this._serverData = {};  // The last known data for this object from cloud.\n    this._opSetQueue = [{}];  // List of sets of changes to the data.\n    this.attributes = {};  // The best estimate of this's current data.\n\n    this._hashedJSON = {};  // Hash of values of containers at last save.\n    this._escapedAttributes = {};\n    this.cid = _.uniqueId('c');\n    this.changed = {};\n    this._silent = {};\n    this._pending = {};\n    if (!this.set(attributes, {silent: true})) {\n      throw new Error(\"Can't create an invalid Parse.Object\");\n    }\n    this.changed = {};\n    this._silent = {};\n    this._pending = {};\n    this._hasData = true;\n    this._previousAttributes = _.clone(this.attributes);\n    this.initialize.apply(this, arguments);\n  };\n\n  /**\n   * The ID of this object, unique within its class.\n   * @name id\n   * @type String\n   * @field\n   * @memberOf Parse.Object.prototype\n   */\n\n  /**\n   * The first time this object was saved on the server.\n   * @name createdAt\n   * @type Date\n   * @field\n   * @memberOf Parse.Object.prototype\n   */\n\n  /**\n   * The last time this object was updated on the server.\n   * @name updatedAt\n   * @type Date\n   * @field\n   * @memberOf Parse.Object.prototype\n   */\n\n  /**\n   * Saves the given list of Parse.Object.\n   * If any error is encountered, stops and calls the error handler.\n   *\n   * <pre>\n   *   Parse.Object.saveAll([object1, object2, ...], {\n   *     success: function(list) {\n   *       // All the objects were saved.\n   *     },\n   *     error: function(error) {\n   *       // An error occurred while saving one of the objects.\n   *     },\n   *   });\n   * </pre>\n   *\n   * @param {Array} list A list of <code>Parse.Object</code>.\n   * @param {Object} options A Backbone-style callback object.\n   * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   * </ul>\n   */\n  Parse.Object.saveAll = function(list, options) {\n    options = options || {};\n    return Parse.Object._deepSaveAsync(list, {\n      useMasterKey: options.useMasterKey,\n      sessionToken: options.sessionToken\n    })._thenRunCallbacks(options);\n  };\n\n  /**\n   * Destroy the given list of models on the server if it was already persisted.\n   * Optimistically removes each model from its collection, if it has one.\n   * If `wait: true` is passed, waits for the server to respond before removal.\n   *\n   * <p>Unlike saveAll, if an error occurs while deleting an individual model,\n   * this method will continue trying to delete the rest of the models if\n   * possible, except in the case of a fatal error like a connection error.\n   *\n   * <p>In particular, the Parse.Error object returned in the case of error may\n   * be one of two types:\n   *\n   * <ul>\n   *   <li>A Parse.Error.AGGREGATE_ERROR. This object's \"errors\" property is an\n   *       array of other Parse.Error objects. Each error object in this array\n   *       has an \"object\" property that references the object that could not be\n   *       deleted (for instance, because that object could not be found).</li>\n   *   <li>A non-aggregate Parse.Error. This indicates a serious error that\n   *       caused the delete operation to be aborted partway through (for\n   *       instance, a connection failure in the middle of the delete).</li>\n   * </ul>\n   *\n   * <pre>\n   *   Parse.Object.destroyAll([object1, object2, ...], {\n   *     success: function() {\n   *       // All the objects were deleted.\n   *     },\n   *     error: function(error) {\n   *       // An error occurred while deleting one or more of the objects.\n   *       // If this is an aggregate error, then we can inspect each error\n   *       // object individually to determine the reason why a particular\n   *       // object was not deleted.\n   *       if (error.code == Parse.Error.AGGREGATE_ERROR) {\n   *         for (var i = 0; i < error.errors.length; i++) {\n   *           console.log(\"Couldn't delete \" + error.errors[i].object.id +\n   *             \"due to \" + error.errors[i].message);\n   *         }\n   *       } else {\n   *         console.log(\"Delete aborted because of \" + error.message);\n   *       }\n   *     },\n   *   });\n   * </pre>\n   *\n   * @param {Array} list A list of <code>Parse.Object</code>.\n   * @param {Object} options A Backbone-style callback object.\n   * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   * </ul>\n   * @return {Parse.Promise} A promise that is fulfilled when the destroyAll\n   *     completes.\n   */\n  Parse.Object.destroyAll = function(list, options) {\n    options = options || {};\n\n    var triggerDestroy = function(object) {\n      object.trigger('destroy', object, object.collection, options);\n    };\n\n    var errors = [];\n    var destroyBatch = function(batch) {\n      var promise = Parse.Promise.as();\n\n      if (batch.length > 0) {\n        promise = promise.then(function() {\n          return Parse._request({\n            route: \"batch\",\n            method: \"POST\",\n            useMasterKey: options.useMasterKey,\n            sessionToken: options.sessionToken,\n            data: {\n              requests: _.map(batch, function(object) {\n                return {\n                  method: \"DELETE\",\n                  path: \"/1/classes/\" + object.className + \"/\" + object.id\n                };\n              })\n            }\n          });\n        }).then(function(responses, status, xhr) {\n          Parse._arrayEach(batch, function(object, i) {\n            if (responses[i].success && options.wait) {\n              triggerDestroy(object);\n            } else if (responses[i].error) {\n              var error = new Parse.Error(responses[i].error.code,\n                                          responses[i].error.error);\n              error.object = object;\n\n              errors.push(error);\n            }\n          });\n        });\n      }\n\n      return promise;\n    };\n\n    var promise = Parse.Promise.as();\n    var batch = [];\n    Parse._arrayEach(list, function(object, i) {\n      if (!object.id || !options.wait) {\n        triggerDestroy(object);\n      }\n\n      if (object.id) {\n        batch.push(object);\n      }\n\n      if (batch.length === 20 || i+1 === list.length) {\n        var thisBatch = batch;\n        batch = [];\n\n        promise = promise.then(function() {\n          return destroyBatch(thisBatch);\n        });\n      }\n    });\n\n    return promise.then(function() {\n      if (errors.length === 0) {\n        return true;\n      } else {\n        var error = new Parse.Error(Parse.Error.AGGREGATE_ERROR,\n                                    \"Error deleting an object in destroyAll\");\n        error.errors = errors;\n\n        return Parse.Promise.error(error);\n      }\n    })._thenRunCallbacks(options);\n  };\n\n  /**\n   * Fetches the given list of Parse.Object.\n   * If any error is encountered, stops and calls the error handler.\n   *\n   * <pre>\n   *   Parse.Object.fetchAll([object1, object2, ...], {\n   *     success: function(list) {\n   *       // All the objects were fetched.\n   *     },\n   *     error: function(error) {\n   *       // An error occurred while fetching one of the objects.\n   *     },\n   *   });\n   * </pre>\n   *\n   * @param {Array} list A list of <code>Parse.Object</code>.\n   * @param {Object} options A Backbone-style callback object.\n   * Valid options are:<ul>\n   *   <li>success: A Backbone-style success callback.\n   *   <li>error: An Backbone-style error callback.\n   * </ul>\n   */\n  Parse.Object.fetchAll = function(list, options) {\n    return Parse.Object._fetchAll(\n      list,\n      true\n    )._thenRunCallbacks(options);\n  };\n\n  /**\n   * Fetches the given list of Parse.Object if needed.\n   * If any error is encountered, stops and calls the error handler.\n   *\n   * <pre>\n   *   Parse.Object.fetchAllIfNeeded([object1, ...], {\n   *     success: function(list) {\n   *       // Objects were fetched and updated.\n   *     },\n   *     error: function(error) {\n   *       // An error occurred while fetching one of the objects.\n   *     },\n   *   });\n   * </pre>\n   *\n   * @param {Array} list A list of <code>Parse.Object</code>.\n   * @param {Object} options A Backbone-style callback object.\n   * Valid options are:<ul>\n   *   <li>success: A Backbone-style success callback.\n   *   <li>error: An Backbone-style error callback.\n   * </ul>\n   */\n  Parse.Object.fetchAllIfNeeded = function(list, options) {\n    return Parse.Object._fetchAll(\n      list,\n      false\n    )._thenRunCallbacks(options);\n  };\n\n  // Attach all inheritable methods to the Parse.Object prototype.\n  _.extend(Parse.Object.prototype, Parse.Events,\n           /** @lends Parse.Object.prototype */ {\n    _existed: false,\n\n    /**\n     * Initialize is an empty function by default. Override it with your own\n     * initialization logic.\n     */\n    initialize: function(){},\n\n    /**\n     * Returns a JSON version of the object suitable for saving to Parse.\n     * @return {Object}\n     */\n    toJSON: function() {\n      var json = this._toFullJSON();\n      Parse._arrayEach([\"__type\", \"className\"],\n                       function(key) { delete json[key]; });\n      return json;\n    },\n\n    _toFullJSON: function(seenObjects) {\n      var json = _.clone(this.attributes);\n      Parse._objectEach(json, function(val, key) {\n        json[key] = Parse._encode(val, seenObjects);\n      });\n      Parse._objectEach(this._operations, function(val, key) {\n        json[key] = val;\n      });\n\n      if (_.has(this, \"id\")) {\n        json.objectId = this.id;\n      }\n      if (_.has(this, \"createdAt\")) {\n        if (_.isDate(this.createdAt)) {\n          json.createdAt = this.createdAt.toJSON();\n        } else {\n          json.createdAt = this.createdAt;\n        }\n      }\n\n      if (_.has(this, \"updatedAt\")) {\n        if (_.isDate(this.updatedAt)) {\n          json.updatedAt = this.updatedAt.toJSON();\n        } else {\n          json.updatedAt = this.updatedAt;\n        }\n      }\n      json.__type = \"Object\";\n      json.className = this.className;\n      return json;\n    },\n\n    /**\n     * Updates _hashedJSON to reflect the current state of this object.\n     * Adds any changed hash values to the set of pending changes.\n     */\n    _refreshCache: function() {\n      var self = this;\n      if (self._refreshingCache) {\n        return;\n      }\n      self._refreshingCache = true;\n      Parse._objectEach(this.attributes, function(value, key) {\n        if (value instanceof Parse.Object) {\n          value._refreshCache();\n        } else if (_.isObject(value)) {\n          var objectArray = false;\n          if (_.isArray(value)) {\n            // We don't cache arrays of Parse.Objects\n            _.each(value, function(arrVal) {\n              if (arrVal instanceof Parse.Object) {\n                objectArray = true;\n                arrVal._refreshCache();\n              }\n            });\n          }\n          if (!objectArray && self._resetCacheForKey(key)) {\n            self.set(key, new Parse.Op.Set(value), { silent: true });\n          }\n        }\n      });\n      delete self._refreshingCache;\n    },\n\n    /**\n     * Returns true if this object has been modified since its last\n     * save/refresh.  If an attribute is specified, it returns true only if that\n     * particular attribute has been modified since the last save/refresh.\n     * @param {String} attr An attribute name (optional).\n     * @return {Boolean}\n     */\n    dirty: function(attr) {\n      this._refreshCache();\n\n      var currentChanges = _.last(this._opSetQueue);\n\n      if (attr) {\n        return (currentChanges[attr] ? true : false);\n      }\n      if (!this.id) {\n        return true;\n      }\n      if (_.keys(currentChanges).length > 0) {\n        return true;\n      }\n      return false;\n    },\n\n    /**\n     * Returns an array of keys that have been modified since last save/refresh\n     * @return {Array of string}\n     */\n    dirtyKeys: function() {\n      return _.keys(_.last(this._opSetQueue));\n    },\n\n    /**\n     * Gets a Pointer referencing this Object.\n     */\n    _toPointer: function() {\n      if (!this.id) {\n        throw new Error(\"Can't serialize an unsaved Parse.Object\");\n      }\n      return { __type: \"Pointer\",\n               className: this.className,\n               objectId: this.id };\n    },\n\n    /**\n     * Gets the value of an attribute.\n     * @param {String} attr The string name of an attribute.\n     */\n    get: function(attr) {\n      return this.attributes[attr];\n    },\n\n    /**\n     * Gets a relation on the given class for the attribute.\n     * @param String attr The attribute to get the relation for.\n     */\n    relation: function(attr) {\n      var value = this.get(attr);\n      if (value) {\n        if (!(value instanceof Parse.Relation)) {\n          throw \"Called relation() on non-relation field \" + attr;\n        }\n        value._ensureParentAndKey(this, attr);\n        return value;\n      } else {\n        return new Parse.Relation(this, attr);\n      }\n    },\n\n    /**\n     * Gets the HTML-escaped value of an attribute.\n     */\n    escape: function(attr) {\n      var html = this._escapedAttributes[attr];\n      if (html) {\n        return html;\n      }\n      var val = this.attributes[attr];\n      var escaped;\n      if (Parse._isNullOrUndefined(val)) {\n        escaped = '';\n      } else {\n        escaped = _.escape(val.toString());\n      }\n      this._escapedAttributes[attr] = escaped;\n      return escaped;\n    },\n\n    /**\n     * Returns <code>true</code> if the attribute contains a value that is not\n     * null or undefined.\n     * @param {String} attr The string name of the attribute.\n     * @return {Boolean}\n     */\n    has: function(attr) {\n      return !Parse._isNullOrUndefined(this.attributes[attr]);\n    },\n\n    /**\n     * Pulls \"special\" fields like objectId, createdAt, etc. out of attrs\n     * and puts them on \"this\" directly.  Removes them from attrs.\n     * @param attrs - A dictionary with the data for this Parse.Object.\n     */\n    _mergeMagicFields: function(attrs) {\n      // Check for changes of magic fields.\n      var model = this;\n      var specialFields = [\"id\", \"objectId\", \"createdAt\", \"updatedAt\"];\n      Parse._arrayEach(specialFields, function(attr) {\n        if (attrs[attr]) {\n          if (attr === \"objectId\") {\n            model.id = attrs[attr];\n          } else if ((attr === \"createdAt\" || attr === \"updatedAt\") &&\n                     !_.isDate(attrs[attr])) {\n            model[attr] = Parse._parseDate(attrs[attr]);\n          } else {\n            model[attr] = attrs[attr];\n          }\n          delete attrs[attr];\n        }\n      });\n    },\n\n    /**\n     * Copies the given serverData to \"this\", refreshes attributes, and\n     * clears pending changes;\n     */\n    _copyServerData: function(serverData) {\n      // Copy server data\n      var tempServerData = {};\n      Parse._objectEach(serverData, function(value, key) {\n        tempServerData[key] = Parse._decode(key, value);\n      });\n      this._serverData = tempServerData;\n\n      // Refresh the attributes.\n      this._rebuildAllEstimatedData();\n\n      // TODO (bklimt): Revisit clearing operations, perhaps move to revert.\n      // Clear out any changes the user might have made previously.\n      this._refreshCache();\n      this._opSetQueue = [{}];\n\n      // Refresh the attributes again.\n      this._rebuildAllEstimatedData();\n    },\n\n    /**\n     * Merges another object's attributes into this object.\n     */\n    _mergeFromObject: function(other) {\n      if (!other) {\n        return;\n      }\n\n      // This does the inverse of _mergeMagicFields.\n      this.id = other.id;\n      this.createdAt = other.createdAt;\n      this.updatedAt = other.updatedAt;\n\n      this._copyServerData(other._serverData);\n\n      this._hasData = true;\n    },\n\n    /**\n     * Returns the json to be sent to the server.\n     */\n    _startSave: function() {\n      this._opSetQueue.push({});\n    },\n\n    /**\n     * Called when a save fails because of an error. Any changes that were part\n     * of the save need to be merged with changes made after the save. This\n     * might throw an exception is you do conflicting operations. For example,\n     * if you do:\n     *   object.set(\"foo\", \"bar\");\n     *   object.set(\"invalid field name\", \"baz\");\n     *   object.save();\n     *   object.increment(\"foo\");\n     * then this will throw when the save fails and the client tries to merge\n     * \"bar\" with the +1.\n     */\n    _cancelSave: function() {\n      var self = this;\n      var failedChanges = _.first(this._opSetQueue);\n      this._opSetQueue = _.rest(this._opSetQueue);\n      var nextChanges = _.first(this._opSetQueue);\n      Parse._objectEach(failedChanges, function(op, key) {\n        var op1 = failedChanges[key];\n        var op2 = nextChanges[key];\n        if (op1 && op2) {\n          nextChanges[key] = op2._mergeWithPrevious(op1);\n        } else if (op1) {\n          nextChanges[key] = op1;\n        }\n      });\n      this._saving = this._saving - 1;\n    },\n\n    /**\n     * Called when a save completes successfully. This merges the changes that\n     * were saved into the known server data, and overrides it with any data\n     * sent directly from the server.\n     */\n    _finishSave: function(serverData) {\n      // Grab a copy of any object referenced by this object. These instances\n      // may have already been fetched, and we don't want to lose their data.\n      // Note that doing it like this means we will unify separate copies of the\n      // same object, but that's a risk we have to take.\n      var fetchedObjects = {};\n      Parse._traverse(this.attributes, function(object) {\n        if (object instanceof Parse.Object && object.id && object._hasData) {\n          fetchedObjects[object.id] = object;\n        }\n      });\n\n      var savedChanges = _.first(this._opSetQueue);\n      this._opSetQueue = _.rest(this._opSetQueue);\n      this._applyOpSet(savedChanges, this._serverData);\n      this._mergeMagicFields(serverData);\n      var self = this;\n      Parse._objectEach(serverData, function(value, key) {\n        self._serverData[key] = Parse._decode(key, value);\n\n        // Look for any objects that might have become unfetched and fix them\n        // by replacing their values with the previously observed values.\n        var fetched = Parse._traverse(self._serverData[key], function(object) {\n          if (object instanceof Parse.Object && fetchedObjects[object.id]) {\n            return fetchedObjects[object.id];\n          }\n        });\n        if (fetched) {\n          self._serverData[key] = fetched;\n        }\n      });\n      this._rebuildAllEstimatedData();\n      this._saving = this._saving - 1;\n    },\n\n    /**\n     * Called when a fetch or login is complete to set the known server data to\n     * the given object.\n     */\n    _finishFetch: function(serverData, hasData) {\n      // TODO (bklimt): Revisit clearing operations, perhaps move to revert.\n      this._opSetQueue = [{}];\n\n      // Bring in all the new server data.\n      this._mergeMagicFields(serverData);\n      this._copyServerData(serverData);\n\n      this._hasData = hasData;\n    },\n\n    /**\n     * Applies the set of Parse.Op in opSet to the object target.\n     */\n    _applyOpSet: function(opSet, target) {\n      var self = this;\n      Parse._objectEach(opSet, function(change, key) {\n        target[key] = change._estimate(target[key], self, key);\n        if (target[key] === Parse.Op._UNSET) {\n          delete target[key];\n        }\n      });\n    },\n\n    /**\n     * Replaces the cached value for key with the current value.\n     * Returns true if the new value is different than the old value.\n     */\n    _resetCacheForKey: function(key) {\n      var value = this.attributes[key];\n      if (_.isObject(value) &&\n          !(value instanceof Parse.Object) &&\n          !(value instanceof Parse.File)) {\n        value = value.toJSON ? value.toJSON() : value;\n        var json = JSON.stringify(value);\n        if (this._hashedJSON[key] !== json) {\n          var wasSet = !!this._hashedJSON[key];\n          this._hashedJSON[key] = json;\n          return wasSet;\n        }\n      }\n      return false;\n    },\n\n    /**\n     * Populates attributes[key] by starting with the last known data from the\n     * server, and applying all of the local changes that have been made to that\n     * key since then.\n     */\n    _rebuildEstimatedDataForKey: function(key) {\n      var self = this;\n      delete this.attributes[key];\n      if (this._serverData[key]) {\n        this.attributes[key] = this._serverData[key];\n      }\n      Parse._arrayEach(this._opSetQueue, function(opSet) {\n        var op = opSet[key];\n        if (op) {\n          self.attributes[key] = op._estimate(self.attributes[key], self, key);\n          if (self.attributes[key] === Parse.Op._UNSET) {\n            delete self.attributes[key];\n          } else {\n            self._resetCacheForKey(key);\n          }\n        }\n      });\n    },\n\n    /**\n     * Populates attributes by starting with the last known data from the\n     * server, and applying all of the local changes that have been made since\n     * then.\n     */\n    _rebuildAllEstimatedData: function() {\n      var self = this;\n\n      var previousAttributes = _.clone(this.attributes);\n\n      this.attributes = _.clone(this._serverData);\n      Parse._arrayEach(this._opSetQueue, function(opSet) {\n        self._applyOpSet(opSet, self.attributes);\n        Parse._objectEach(opSet, function(op, key) {\n          self._resetCacheForKey(key);\n        });\n      });\n\n      // Trigger change events for anything that changed because of the fetch.\n      Parse._objectEach(previousAttributes, function(oldValue, key) {\n        if (self.attributes[key] !== oldValue) {\n          self.trigger('change:' + key, self, self.attributes[key], {});\n        }\n      });\n      Parse._objectEach(this.attributes, function(newValue, key) {\n        if (!_.has(previousAttributes, key)) {\n          self.trigger('change:' + key, self, newValue, {});\n        }\n      });\n    },\n\n    /**\n     * Sets a hash of model attributes on the object, firing\n     * <code>\"change\"</code> unless you choose to silence it.\n     *\n     * <p>You can call it with an object containing keys and values, or with one\n     * key and value.  For example:<pre>\n     *   gameTurn.set({\n     *     player: player1,\n     *     diceRoll: 2\n     *   }, {\n     *     error: function(gameTurnAgain, error) {\n     *       // The set failed validation.\n     *     }\n     *   });\n     *\n     *   game.set(\"currentPlayer\", player2, {\n     *     error: function(gameTurnAgain, error) {\n     *       // The set failed validation.\n     *     }\n     *   });\n     *\n     *   game.set(\"finished\", true);</pre></p>\n     *\n     * @param {String} key The key to set.\n     * @param {} value The value to give it.\n     * @param {Object} options A set of Backbone-like options for the set.\n     *     The only supported options are <code>silent</code>,\n     *     <code>error</code>, and <code>promise</code>.\n     * @return {Boolean} true if the set succeeded.\n     * @see Parse.Object#validate\n     * @see Parse.Error\n     */\n    set: function(key, value, options) {\n      var attrs, attr;\n      if (_.isObject(key) || Parse._isNullOrUndefined(key)) {\n        attrs = key;\n        Parse._objectEach(attrs, function(v, k) {\n          attrs[k] = Parse._decode(k, v);\n        });\n        options = value;\n      } else {\n        attrs = {};\n        attrs[key] = Parse._decode(key, value);\n      }\n\n      // Extract attributes and options.\n      options = options || {};\n      if (!attrs) {\n        return this;\n      }\n      if (attrs instanceof Parse.Object) {\n        attrs = attrs.attributes;\n      }\n\n      var self = this;\n      Parse._objectEach(attrs, function(unused_value, key) {\n        if (self.constructor.readOnlyAttributes &&\n          self.constructor.readOnlyAttributes[key]) {\n          throw new Error('Cannot modify readonly key: ' + key);\n        }\n      });\n\n      // If the unset option is used, every attribute should be a Unset.\n      if (options.unset) {\n        Parse._objectEach(attrs, function(unused_value, key) {\n          attrs[key] = new Parse.Op.Unset();\n        });\n      }\n\n      // Apply all the attributes to get the estimated values.\n      var dataToValidate = _.clone(attrs);\n      Parse._objectEach(dataToValidate, function(value, key) {\n        if (value instanceof Parse.Op) {\n          dataToValidate[key] = value._estimate(self.attributes[key],\n                                                self, key);\n          if (dataToValidate[key] === Parse.Op._UNSET) {\n            delete dataToValidate[key];\n          }\n        }\n      });\n\n      // Run validation.\n      if (!this._validate(attrs, options)) {\n        return false;\n      }\n\n      this._mergeMagicFields(attrs);\n\n      options.changes = {};\n      var escaped = this._escapedAttributes;\n      var prev = this._previousAttributes || {};\n\n      // Update attributes.\n      Parse._arrayEach(_.keys(attrs), function(attr) {\n        var val = attrs[attr];\n\n        // If this is a relation object we need to set the parent correctly,\n        // since the location where it was parsed does not have access to\n        // this object.\n        if (val instanceof Parse.Relation) {\n          val.parent = self;\n        }\n\n        if (!(val instanceof Parse.Op)) {\n          val = new Parse.Op.Set(val);\n        }\n\n        // See if this change will actually have any effect.\n        var isRealChange = true;\n        if (val instanceof Parse.Op.Set &&\n            _.isEqual(self.attributes[attr], val.value)) {\n          isRealChange = false;\n        }\n\n        if (isRealChange) {\n          delete escaped[attr];\n          if (options.silent) {\n            self._silent[attr] = true;\n          } else {\n            options.changes[attr] = true;\n          }\n        }\n\n        var currentChanges = _.last(self._opSetQueue);\n        currentChanges[attr] = val._mergeWithPrevious(currentChanges[attr]);\n        self._rebuildEstimatedDataForKey(attr);\n\n        if (isRealChange) {\n          self.changed[attr] = self.attributes[attr];\n          if (!options.silent) {\n            self._pending[attr] = true;\n          }\n        } else {\n          delete self.changed[attr];\n          delete self._pending[attr];\n        }\n      });\n\n      if (!options.silent) {\n        this.change(options);\n      }\n      return this;\n    },\n\n    /**\n     * Remove an attribute from the model, firing <code>\"change\"</code> unless\n     * you choose to silence it. This is a noop if the attribute doesn't\n     * exist.\n     */\n    unset: function(attr, options) {\n      options = options || {};\n      options.unset = true;\n      return this.set(attr, null, options);\n    },\n\n    /**\n     * Atomically increments the value of the given attribute the next time the\n     * object is saved. If no amount is specified, 1 is used by default.\n     *\n     * @param attr {String} The key.\n     * @param amount {Number} The amount to increment by.\n     */\n    increment: function(attr, amount) {\n      if (_.isUndefined(amount) || _.isNull(amount)) {\n        amount = 1;\n      }\n      return this.set(attr, new Parse.Op.Increment(amount));\n    },\n\n    /**\n     * Atomically add an object to the end of the array associated with a given\n     * key.\n     * @param attr {String} The key.\n     * @param item {} The item to add.\n     */\n    add: function(attr, item) {\n      return this.set(attr, new Parse.Op.Add([item]));\n    },\n\n    /**\n     * Atomically add an object to the array associated with a given key, only\n     * if it is not already present in the array. The position of the insert is\n     * not guaranteed.\n     *\n     * @param attr {String} The key.\n     * @param item {} The object to add.\n     */\n    addUnique: function(attr, item) {\n      return this.set(attr, new Parse.Op.AddUnique([item]));\n    },\n\n    /**\n     * Atomically remove all instances of an object from the array associated\n     * with a given key.\n     *\n     * @param attr {String} The key.\n     * @param item {} The object to remove.\n     */\n    remove: function(attr, item) {\n      return this.set(attr, new Parse.Op.Remove([item]));\n    },\n\n    /**\n     * Returns an instance of a subclass of Parse.Op describing what kind of\n     * modification has been performed on this field since the last time it was\n     * saved. For example, after calling object.increment(\"x\"), calling\n     * object.op(\"x\") would return an instance of Parse.Op.Increment.\n     *\n     * @param attr {String} The key.\n     * @returns {Parse.Op} The operation, or undefined if none.\n     */\n    op: function(attr) {\n      return _.last(this._opSetQueue)[attr];\n    },\n\n    /**\n     * Clear all attributes on the model, firing <code>\"change\"</code> unless\n     * you choose to silence it.\n     */\n    clear: function(options) {\n      options = options || {};\n      options.unset = true;\n      var keysToClear = _.extend(this.attributes, this._operations);\n      return this.set(keysToClear, options);\n    },\n\n    /**\n     * Returns a JSON-encoded set of operations to be sent with the next save\n     * request.\n     */\n    _getSaveJSON: function() {\n      var json = _.clone(_.first(this._opSetQueue));\n      Parse._objectEach(json, function(op, key) {\n        json[key] = op.toJSON();\n      });\n      return json;\n    },\n\n    /**\n     * Returns true if this object can be serialized for saving.\n     */\n    _canBeSerialized: function() {\n      return Parse.Object._canBeSerializedAsValue(this.attributes);\n    },\n\n    /**\n     * Fetch the model from the server. If the server's representation of the\n     * model differs from its current attributes, they will be overriden,\n     * triggering a <code>\"change\"</code> event.\n     *\n     * @param {Object} options A Backbone-style callback object.\n     * Valid options are:<ul>\n     *   <li>success: A Backbone-style success callback.\n     *   <li>error: An Backbone-style error callback.\n     *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n     *     be used for this request.\n     *   <li>sessionToken: A valid session token, used for making a request on\n     *       behalf of a specific user.\n     * </ul>\n     * @return {Parse.Promise} A promise that is fulfilled when the fetch\n     *     completes.\n     */\n    fetch: function(options) {\n      var self = this;\n      options = options || {};\n      var request = Parse._request({\n        method: 'GET',\n        route: \"classes\",\n        className: this.className,\n        objectId: this.id,\n        useMasterKey: options.useMasterKey,\n        sessionToken: options.sessionToken\n      });\n      return request.then(function(response, status, xhr) {\n        self._finishFetch(self.parse(response, status, xhr), true);\n        return self;\n      })._thenRunCallbacks(options, this);\n    },\n\n    /**\n     * Set a hash of model attributes, and save the model to the server.\n     * updatedAt will be updated when the request returns.\n     * You can either call it as:<pre>\n     *   object.save();</pre>\n     * or<pre>\n     *   object.save(null, options);</pre>\n     * or<pre>\n     *   object.save(attrs, options);</pre>\n     * or<pre>\n     *   object.save(key, value, options);</pre>\n     *\n     * For example, <pre>\n     *   gameTurn.save({\n     *     player: \"Jake Cutter\",\n     *     diceRoll: 2\n     *   }, {\n     *     success: function(gameTurnAgain) {\n     *       // The save was successful.\n     *     },\n     *     error: function(gameTurnAgain, error) {\n     *       // The save failed.  Error is an instance of Parse.Error.\n     *     }\n     *   });</pre>\n     * or with promises:<pre>\n     *   gameTurn.save({\n     *     player: \"Jake Cutter\",\n     *     diceRoll: 2\n     *   }).then(function(gameTurnAgain) {\n     *     // The save was successful.\n     *   }, function(error) {\n     *     // The save failed.  Error is an instance of Parse.Error.\n     *   });</pre>\n     *\n     * @param {Object} options A Backbone-style callback object.\n     * Valid options are:<ul>\n     *   <li>wait: Set to true to wait for the server to confirm a successful\n     *   save before modifying the attributes on the object.\n     *   <li>silent: Set to true to avoid firing the `set` event.\n     *   <li>success: A Backbone-style success callback.\n     *   <li>error: An Backbone-style error callback.\n     *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n     *     be used for this request.\n     *   <li>sessionToken: A valid session token, used for making a request on\n     *       behalf of a specific user.\n     * </ul>\n     * @return {Parse.Promise} A promise that is fulfilled when the save\n     *     completes.\n     * @see Parse.Error\n     */\n    save: function(arg1, arg2, arg3) {\n      var i, attrs, current, options, saved;\n      if (_.isObject(arg1) || Parse._isNullOrUndefined(arg1)) {\n        attrs = arg1;\n        options = arg2;\n      } else {\n        attrs = {};\n        attrs[arg1] = arg2;\n        options = arg3;\n      }\n\n      // Make save({ success: function() {} }) work.\n      if (!options && attrs) {\n        var extra_keys = _.reject(attrs, function(value, key) {\n          return _.include([\"success\", \"error\", \"wait\"], key);\n        });\n        if (extra_keys.length === 0) {\n          var all_functions = true;\n          if (_.has(attrs, \"success\") && !_.isFunction(attrs.success)) {\n            all_functions = false;\n          }\n          if (_.has(attrs, \"error\") && !_.isFunction(attrs.error)) {\n            all_functions = false;\n          }\n          if (all_functions) {\n            // This attrs object looks like it's really an options object,\n            // and there's no other options object, so let's just use it.\n            return this.save(null, attrs);\n          }\n        }\n      }\n\n      options = _.clone(options) || {};\n      if (options.wait) {\n        current = _.clone(this.attributes);\n      }\n\n      var setOptions = _.clone(options) || {};\n      if (setOptions.wait) {\n        setOptions.silent = true;\n      }\n      var setError;\n      setOptions.error = function(model, error) {\n        setError = error;\n      };\n      if (attrs && !this.set(attrs, setOptions)) {\n        return Parse.Promise.error(setError)._thenRunCallbacks(options, this);\n      }\n\n      var model = this;\n\n      // If there is any unsaved child, save it first.\n      model._refreshCache();\n\n      // TODO(klimt): Refactor this so that the save starts now, not later.\n\n      var unsavedChildren = [];\n      var unsavedFiles = [];\n      Parse.Object._findUnsavedChildren(model.attributes,\n                                        unsavedChildren,\n                                        unsavedFiles);\n      if (unsavedChildren.length + unsavedFiles.length > 0) {\n        return Parse.Object._deepSaveAsync(this.attributes, {\n          useMasterKey: options.useMasterKey,\n          sessionToken: options.sessionToken\n        }).then(function() {\n          return model.save(null, options);\n        }, function(error) {\n          return Parse.Promise.error(error)._thenRunCallbacks(options, model);\n        });\n      }\n\n      this._startSave();\n      this._saving = (this._saving || 0) + 1;\n\n      this._allPreviousSaves = this._allPreviousSaves || Parse.Promise.as();\n      this._allPreviousSaves = this._allPreviousSaves._continueWith(function() {\n        var method = model.id ? 'PUT' : 'POST';\n\n        var json = model._getSaveJSON();\n\n        var route = \"classes\";\n        var className = model.className;\n        if (model.className === \"_User\" && !model.id) {\n          // Special-case user sign-up.\n          route = \"users\";\n          className = null;\n        }\n        var request = Parse._request({\n          route: route,\n          className: className,\n          objectId: model.id,\n          method: method,\n          useMasterKey: options.useMasterKey,\n          sessionToken: options.sessionToken,\n          data: json\n        });\n\n        request = request.then(function(resp, status, xhr) {\n          var serverAttrs = model.parse(resp, status, xhr);\n          if (options.wait) {\n            serverAttrs = _.extend(attrs || {}, serverAttrs);\n          }\n          model._finishSave(serverAttrs);\n          if (options.wait) {\n            model.set(current, setOptions);\n          }\n          return model;\n\n        }, function(error) {\n          model._cancelSave();\n          return Parse.Promise.error(error);\n\n        })._thenRunCallbacks(options, model);\n\n        return request;\n      });\n      return this._allPreviousSaves;\n    },\n\n    /**\n     * Destroy this model on the server if it was already persisted.\n     * Optimistically removes the model from its collection, if it has one.\n     * If `wait: true` is passed, waits for the server to respond\n     * before removal.\n     *\n     * @param {Object} options A Backbone-style callback object.\n     * Valid options are:<ul>\n     *   <li>wait: Set to true to wait for the server to confirm successful\n     *   deletion of the object before triggering the `destroy` event.\n     *   <li>success: A Backbone-style success callback\n     *   <li>error: An Backbone-style error callback.\n     *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n     *     be used for this request.\n     *   <li>sessionToken: A valid session token, used for making a request on\n     *       behalf of a specific user.\n     * </ul>\n     * @return {Parse.Promise} A promise that is fulfilled when the destroy\n     *     completes.\n     */\n    destroy: function(options) {\n      options = options || {};\n      var model = this;\n\n      var triggerDestroy = function() {\n        model.trigger('destroy', model, model.collection, options);\n      };\n\n      if (!this.id) {\n        return triggerDestroy();\n      }\n\n      if (!options.wait) {\n        triggerDestroy();\n      }\n\n      var request = Parse._request({\n        route: \"classes\",\n        className: this.className,\n        objectId: this.id,\n        method: 'DELETE',\n        useMasterKey: options.useMasterKey,\n        sessionToken: options.sessionToken\n      });\n      return request.then(function() {\n        if (options.wait) {\n          triggerDestroy();\n        }\n        return model;\n      })._thenRunCallbacks(options, this);\n    },\n\n    /**\n     * Converts a response into the hash of attributes to be set on the model.\n     * @ignore\n     */\n    parse: function(resp, status, xhr) {\n      var output = _.clone(resp);\n      _([\"createdAt\", \"updatedAt\"]).each(function(key) {\n        if (output[key]) {\n          output[key] = Parse._parseDate(output[key]);\n        }\n      });\n      if (!output.updatedAt) {\n        output.updatedAt = output.createdAt;\n      }\n      if (status) {\n        this._existed = (status !== 201);\n      }\n      return output;\n    },\n\n    /**\n     * Creates a new model with identical attributes to this one.\n     * @return {Parse.Object}\n     */\n    clone: function() {\n      return new this.constructor(this.attributes);\n    },\n\n    /**\n     * Returns true if this object has never been saved to Parse.\n     * @return {Boolean}\n     */\n    isNew: function() {\n      return !this.id;\n    },\n\n    /**\n     * Call this method to manually fire a `\"change\"` event for this model and\n     * a `\"change:attribute\"` event for each changed attribute.\n     * Calling this will cause all objects observing the model to update.\n     */\n    change: function(options) {\n      options = options || {};\n      var changing = this._changing;\n      this._changing = true;\n\n      // Silent changes become pending changes.\n      var self = this;\n      Parse._objectEach(this._silent, function(attr) {\n        self._pending[attr] = true;\n      });\n\n      // Silent changes are triggered.\n      var changes = _.extend({}, options.changes, this._silent);\n      this._silent = {};\n      Parse._objectEach(changes, function(unused_value, attr) {\n        self.trigger('change:' + attr, self, self.get(attr), options);\n      });\n      if (changing) {\n        return this;\n      }\n\n      // This is to get around lint not letting us make a function in a loop.\n      var deleteChanged = function(value, attr) {\n        if (!self._pending[attr] && !self._silent[attr]) {\n          delete self.changed[attr];\n        }\n      };\n\n      // Continue firing `\"change\"` events while there are pending changes.\n      while (!_.isEmpty(this._pending)) {\n        this._pending = {};\n        this.trigger('change', this, options);\n        // Pending and silent changes still remain.\n        Parse._objectEach(this.changed, deleteChanged);\n        self._previousAttributes = _.clone(this.attributes);\n      }\n\n      this._changing = false;\n      return this;\n    },\n\n    /**\n     * Returns true if this object was created by the Parse server when the\n     * object might have already been there (e.g. in the case of a Facebook\n     * login)\n     */\n    existed: function() {\n      return this._existed;\n    },\n\n    /**\n     * Determine if the model has changed since the last <code>\"change\"</code>\n     * event.  If you specify an attribute name, determine if that attribute\n     * has changed.\n     * @param {String} attr Optional attribute name\n     * @return {Boolean}\n     */\n    hasChanged: function(attr) {\n      if (!arguments.length) {\n        return !_.isEmpty(this.changed);\n      }\n      return this.changed && _.has(this.changed, attr);\n    },\n\n    /**\n     * Returns an object containing all the attributes that have changed, or\n     * false if there are no changed attributes. Useful for determining what\n     * parts of a view need to be updated and/or what attributes need to be\n     * persisted to the server. Unset attributes will be set to undefined.\n     * You can also pass an attributes object to diff against the model,\n     * determining if there *would be* a change.\n     */\n    changedAttributes: function(diff) {\n      if (!diff) {\n        return this.hasChanged() ? _.clone(this.changed) : false;\n      }\n      var changed = {};\n      var old = this._previousAttributes;\n      Parse._objectEach(diff, function(diffVal, attr) {\n        if (!_.isEqual(old[attr], diffVal)) {\n          changed[attr] = diffVal;\n        }\n      });\n      return changed;\n    },\n\n    /**\n     * Gets the previous value of an attribute, recorded at the time the last\n     * <code>\"change\"</code> event was fired.\n     * @param {String} attr Name of the attribute to get.\n     */\n    previous: function(attr) {\n      if (!arguments.length || !this._previousAttributes) {\n        return null;\n      }\n      return this._previousAttributes[attr];\n    },\n\n    /**\n     * Gets all of the attributes of the model at the time of the previous\n     * <code>\"change\"</code> event.\n     * @return {Object}\n     */\n    previousAttributes: function() {\n      return _.clone(this._previousAttributes);\n    },\n\n    /**\n     * Checks if the model is currently in a valid state. It's only possible to\n     * get into an *invalid* state if you're using silent changes.\n     * @return {Boolean}\n     */\n    isValid: function() {\n      return !this.validate(this.attributes);\n    },\n\n    /**\n     * You should not call this function directly unless you subclass\n     * <code>Parse.Object</code>, in which case you can override this method\n     * to provide additional validation on <code>set</code> and\n     * <code>save</code>.  Your implementation should return\n     *\n     * @param {Object} attrs The current data to validate.\n     * @param {Object} options A Backbone-like options object.\n     * @return {} False if the data is valid.  An error object otherwise.\n     * @see Parse.Object#set\n     */\n    validate: function(attrs, options) {\n      if (_.has(attrs, \"ACL\") && !(attrs.ACL instanceof Parse.ACL)) {\n        return new Parse.Error(Parse.Error.OTHER_CAUSE,\n                               \"ACL must be a Parse.ACL.\");\n      }\n      var correct = true;\n      Parse._objectEach(attrs, function(unused_value, key) {\n        if (!(/^[A-Za-z][0-9A-Za-z_]*$/).test(key)) {\n          correct = false;\n        }\n      });\n      if (!correct) {\n        return new Parse.Error(Parse.Error.INVALID_KEY_NAME);\n      }\n      return false;\n    },\n\n    /**\n     * Run validation against a set of incoming attributes, returning `true`\n     * if all is well. If a specific `error` callback has been passed,\n     * call that instead of firing the general `\"error\"` event.\n     */\n    _validate: function(attrs, options) {\n      if (options.silent || !this.validate) {\n        return true;\n      }\n      attrs = _.extend({}, this.attributes, attrs);\n      var error = this.validate(attrs, options);\n      if (!error) {\n        return true;\n      }\n      if (options && options.error) {\n        options.error(this, error, options);\n      } else {\n        this.trigger('error', this, error, options);\n      }\n      return false;\n    },\n\n    /**\n     * Returns the ACL for this object.\n     * @returns {Parse.ACL} An instance of Parse.ACL.\n     * @see Parse.Object#get\n     */\n    getACL: function() {\n      return this.get(\"ACL\");\n    },\n\n    /**\n     * Sets the ACL to be used for this object.\n     * @param {Parse.ACL} acl An instance of Parse.ACL.\n     * @param {Object} options Optional Backbone-like options object to be\n     *     passed in to set.\n     * @return {Boolean} Whether the set passed validation.\n     * @see Parse.Object#set\n     */\n    setACL: function(acl, options) {\n      return this.set(\"ACL\", acl, options);\n    }\n\n  });\n\n  /**\n   * Returns the appropriate subclass for making new instances of the given\n   * className string.\n   */\n  Parse.Object._getSubclass = function(className) {\n    if (!_.isString(className)) {\n      throw \"Parse.Object._getSubclass requires a string argument.\";\n    }\n    var ObjectClass = Parse.Object._classMap[className];\n    if (!ObjectClass) {\n      ObjectClass = Parse.Object.extend(className);\n      Parse.Object._classMap[className] = ObjectClass;\n    }\n    return ObjectClass;\n  };\n\n  /**\n   * Creates an instance of a subclass of Parse.Object for the given classname.\n   */\n  Parse.Object._create = function(className, attributes, options) {\n    var ObjectClass = Parse.Object._getSubclass(className);\n    return new ObjectClass(attributes, options);\n  };\n\n  /**\n   * Returns a list of object ids given a list of objects.\n   */\n  Parse.Object._toObjectIdArray = function(list, omitObjectsWithData) {\n    if (list.length === 0) {\n      return Parse.Promise.as(list);\n    }\n\n    var error;\n    var className = list[0].className;\n    var objectIds = [];\n    for (var i = 0; i < list.length; i++) {\n      var object = list[i];\n      if (className !== object.className) {\n        error = new Parse.Error(Parse.Error.INVALID_CLASS_NAME,\n                                \"All objects should be of the same class\");\n        return Parse.Promise.error(error);\n      } else if (!object.id) {\n        error = new Parse.Error(Parse.Error.MISSING_OBJECT_ID,\n                                \"All objects must have an ID\");\n        return Parse.Promise.error(error);\n      } else if (omitObjectsWithData && object._hasData) {\n        continue;\n      }\n      objectIds.push(object.id);\n    }\n\n    return Parse.Promise.as(objectIds);\n  };\n\n  /**\n   * Updates a list of objects with fetched results.\n   */\n  Parse.Object._updateWithFetchedResults = function(list, fetched, forceFetch) {\n    var fetchedObjectsById = {};\n    Parse._arrayEach(fetched, function(object, i) {\n      fetchedObjectsById[object.id] = object;\n    });\n\n    for (var i = 0; i < list.length; i++) {\n      var object = list[i];\n      var fetchedObject = fetchedObjectsById[object.id];\n      if (!fetchedObject && forceFetch) {\n        var error = new Parse.Error(Parse.Error.OBJECT_NOT_FOUND,\n                                \"All objects must exist on the server\");\n        return Parse.Promise.error(error);\n      }\n\n      object._mergeFromObject(fetchedObject);\n    }\n\n    return Parse.Promise.as(list);\n  };\n\n  /**\n   * Fetches the objects given in list.  The forceFetch option will fetch all\n   * objects if true and ignore objects with data if false.\n   */\n  Parse.Object._fetchAll = function(list, forceFetch) {\n    if (list.length === 0) {\n      return Parse.Promise.as(list);\n    }\n\n    var omitObjectsWithData = !forceFetch;\n    return Parse.Object._toObjectIdArray(\n      list,\n      omitObjectsWithData\n    ).then(function(objectIds) {\n      var className = list[0].className;\n      var query = new Parse.Query(className);\n      query.containedIn(\"objectId\", objectIds);\n      query.limit = objectIds.length;\n      return query.find();\n    }).then(function(results) {\n      return Parse.Object._updateWithFetchedResults(\n        list,\n        results,\n        forceFetch\n      );\n    });\n  };\n\n  // Set up a map of className to class so that we can create new instances of\n  // Parse Objects from JSON automatically.\n  Parse.Object._classMap = {};\n\n  Parse.Object._extend = Parse._extend;\n\n  /**\n   * Creates a new subclass of Parse.Object for the given Parse class name.\n   *\n   * <p>Every extension of a Parse class will inherit from the most recent\n   * previous extension of that class. When a Parse.Object is automatically\n   * created by parsing JSON, it will use the most recent extension of that\n   * class.</p>\n   *\n   * <p>You should call either:<pre>\n   *     var MyClass = Parse.Object.extend(\"MyClass\", {\n   *         <i>Instance methods</i>,\n   *         initialize: function(attrs, options) {\n   *             this.someInstanceProperty = [],\n   *             <i>Other instance properties</i>\n   *         }\n   *     }, {\n   *         <i>Class properties</i>\n   *     });</pre>\n   * or, for Backbone compatibility:<pre>\n   *     var MyClass = Parse.Object.extend({\n   *         className: \"MyClass\",\n   *         <i>Instance methods</i>,\n   *         initialize: function(attrs, options) {\n   *             this.someInstanceProperty = [],\n   *             <i>Other instance properties</i>\n   *         }\n   *     }, {\n   *         <i>Class properties</i>\n   *     });</pre></p>\n   *\n   * @param {String} className The name of the Parse class backing this model.\n   * @param {Object} protoProps Instance properties to add to instances of the\n   *     class returned from this method.\n   * @param {Object} classProps Class properties to add the class returned from\n   *     this method.\n   * @return {Class} A new subclass of Parse.Object.\n   */\n  Parse.Object.extend = function(className, protoProps, classProps) {\n    // Handle the case with only two args.\n    if (!_.isString(className)) {\n      if (className && _.has(className, \"className\")) {\n        return Parse.Object.extend(className.className, className, protoProps);\n      } else {\n        throw new Error(\n            \"Parse.Object.extend's first argument should be the className.\");\n      }\n    }\n\n    // If someone tries to subclass \"User\", coerce it to the right type.\n    if (className === \"User\" && Parse.User._performUserRewrite) {\n      className = \"_User\";\n    }\n    protoProps = protoProps || {};\n    protoProps.className = className;\n\n    var NewClassObject = null;\n    if (_.has(Parse.Object._classMap, className)) {\n      var OldClassObject = Parse.Object._classMap[className];\n      // This new subclass has been told to extend both from \"this\" and from\n      // OldClassObject. This is multiple inheritance, which isn't supported.\n      // For now, let's just pick one.\n      NewClassObject = OldClassObject._extend(protoProps, classProps);\n    } else {\n      NewClassObject = this._extend(protoProps, classProps);\n    }\n    // Extending a subclass should reuse the classname automatically.\n    NewClassObject.extend = function(arg0) {\n      if (_.isString(arg0) || (arg0 && _.has(arg0, \"className\"))) {\n        return Parse.Object.extend.apply(NewClassObject, arguments);\n      }\n      var newArguments = [className].concat(Parse._.toArray(arguments));\n      return Parse.Object.extend.apply(NewClassObject, newArguments);\n    };\n\n    /**\n     * Creates a reference to a subclass of Parse.Object with the given id. This\n     * does not exist on Parse.Object, only on subclasses.\n     *\n     * <p>A shortcut for: <pre>\n     *  var Foo = Parse.Object.extend(\"Foo\");\n     *  var pointerToFoo = new Foo();\n     *  pointerToFoo.id = \"myObjectId\";\n     * </pre>\n     *\n     * @name createWithoutData\n     * @param {String} id The ID of the object to create a reference to.\n     * @return {Parse.Object} A Parse.Object reference.\n     * @function\n     * @memberOf Parse.Object\n     */\n    NewClassObject.createWithoutData = function(id) {\n      var obj = new NewClassObject();\n      obj.id = id;\n      return obj;\n    };\n\n    Parse.Object._classMap[className] = NewClassObject;\n    return NewClassObject;\n  };\n\n  Parse.Object._findUnsavedChildren = function(object, children, files) {\n    Parse._traverse(object, function(object) {\n      if (object instanceof Parse.Object) {\n        object._refreshCache();\n        if (object.dirty()) {\n          children.push(object);\n        }\n        return;\n      }\n\n      if (object instanceof Parse.File) {\n        if (!object.url()) {\n          files.push(object);\n        }\n        return;\n      }\n    });\n  };\n\n  Parse.Object._canBeSerializedAsValue = function(object) {\n    // TODO(klimt): We should rewrite _traverse so that it can be used here.\n    if (object instanceof Parse.Object) {\n      return !!object.id;\n    }\n    if (object instanceof Parse.File) {\n      // Don't recurse indefinitely into files.\n      return true;\n    }\n\n    var canBeSerializedAsValue = true;\n\n    if (_.isArray(object)) {\n      Parse._arrayEach(object, function(child) {\n        if (!Parse.Object._canBeSerializedAsValue(child)) {\n          canBeSerializedAsValue = false;\n        }\n      });\n    } else if (_.isObject(object)) {\n      Parse._objectEach(object, function(child) {\n        if (!Parse.Object._canBeSerializedAsValue(child)) {\n          canBeSerializedAsValue = false;\n        }\n      });\n    }\n    return canBeSerializedAsValue;\n  };\n\n  /**\n   * @param {Object} object The root object.\n   * @param {Object} options: The only valid option is useMasterKey.\n   */\n  Parse.Object._deepSaveAsync = function(object, options) {\n    var unsavedChildren = [];\n    var unsavedFiles = [];\n    Parse.Object._findUnsavedChildren(object, unsavedChildren, unsavedFiles);\n\n    var promise = Parse.Promise.as();\n    _.each(unsavedFiles, function(file) {\n      promise = promise.then(function() {\n        return file.save(options);\n      });\n    });\n\n    var objects = _.uniq(unsavedChildren);\n    var remaining = _.uniq(objects);\n\n    return promise.then(function() {\n      return Parse.Promise._continueWhile(function() {\n        return remaining.length > 0;\n      }, function() {\n\n        // Gather up all the objects that can be saved in this batch.\n        var batch = [];\n        var newRemaining = [];\n        Parse._arrayEach(remaining, function(object) {\n          // Limit batches to 20 objects.\n          if (batch.length > 20) {\n            newRemaining.push(object);\n            return;\n          }\n\n          if (object._canBeSerialized()) {\n            batch.push(object);\n          } else {\n            newRemaining.push(object);\n          }\n        });\n        remaining = newRemaining;\n\n        // If we can't save any objects, there must be a circular reference.\n        if (batch.length === 0) {\n          return Parse.Promise.error(\n            new Parse.Error(Parse.Error.OTHER_CAUSE,\n                            \"Tried to save a batch with a cycle.\"));\n        }\n\n        // Reserve a spot in every object's save queue.\n        var readyToStart = Parse.Promise.when(_.map(batch, function(object) {\n          return object._allPreviousSaves || Parse.Promise.as();\n        }));\n        var batchFinished = new Parse.Promise();\n        Parse._arrayEach(batch, function(object) {\n          object._allPreviousSaves = batchFinished;\n        });\n\n        // Save a single batch, whether previous saves succeeded or failed.\n        return readyToStart._continueWith(function() {\n          return Parse._request({\n            route: \"batch\",\n            method: \"POST\",\n            useMasterKey: options.useMasterKey,\n            sessionToken: options.sessionToken,\n            data: {\n              requests: _.map(batch, function(object) {\n                var json = object._getSaveJSON();\n                var method = \"POST\";\n\n                var path = \"/1/classes/\" + object.className;\n                if (object.id) {\n                  path = path + \"/\" + object.id;\n                  method = \"PUT\";\n                }\n\n                object._startSave();\n\n                return {\n                  method: method,\n                  path: path,\n                  body: json\n                };\n              })\n            }\n          }).then(function(response, status, xhr) {\n            var error;\n            Parse._arrayEach(batch, function(object, i) {\n              if (response[i].success) {\n                object._finishSave(\n                  object.parse(response[i].success, status, xhr));\n              } else {\n                error = error || response[i].error;\n                object._cancelSave();\n              }\n            });\n            if (error) {\n              return Parse.Promise.error(\n                new Parse.Error(error.code, error.error));\n            }\n\n          }).then(function(results) {\n            batchFinished.resolve(results);\n            return results;\n          }, function(error) {\n            batchFinished.reject(error);\n            return Parse.Promise.error(error);\n          });\n        });\n      });\n    }).then(function() {\n      return object;\n    });\n  };\n\n}(this));\n\n(function(root) {\n  root.Parse = root.Parse || {};\n  var Parse = root.Parse;\n  var _ = Parse._;\n\n  /**\n   * Represents a Role on the Parse server. Roles represent groupings of\n   * Users for the purposes of granting permissions (e.g. specifying an ACL\n   * for an Object). Roles are specified by their sets of child users and\n   * child roles, all of which are granted any permissions that the parent\n   * role has.\n   *\n   * <p>Roles must have a name (which cannot be changed after creation of the\n   * role), and must specify an ACL.</p>\n   * @class\n   * A Parse.Role is a local representation of a role persisted to the Parse\n   * cloud.\n   */\n  Parse.Role = Parse.Object.extend(\"_Role\", /** @lends Parse.Role.prototype */ {\n    // Instance Methods\n    \n    /**\n     * Constructs a new ParseRole with the given name and ACL.\n     * \n     * @param {String} name The name of the Role to create.\n     * @param {Parse.ACL} acl The ACL for this role. Roles must have an ACL.\n     */\n    constructor: function(name, acl) {\n      if (_.isString(name) && (acl instanceof Parse.ACL)) {\n        Parse.Object.prototype.constructor.call(this, null, null);\n        this.setName(name);\n        this.setACL(acl);\n      } else {\n        Parse.Object.prototype.constructor.call(this, name, acl);\n      }\n    },\n    \n    /**\n     * Gets the name of the role.  You can alternatively call role.get(\"name\")\n     * \n     * @return {String} the name of the role.\n     */\n    getName: function() {\n      return this.get(\"name\");\n    },\n    \n    /**\n     * Sets the name for a role. This value must be set before the role has\n     * been saved to the server, and cannot be set once the role has been\n     * saved.\n     * \n     * <p>\n     *   A role's name can only contain alphanumeric characters, _, -, and\n     *   spaces.\n     * </p>\n     *\n     * <p>This is equivalent to calling role.set(\"name\", name)</p>\n     * \n     * @param {String} name The name of the role.\n     * @param {Object} options Standard options object with success and error\n     *     callbacks.\n     */\n    setName: function(name, options) {\n      return this.set(\"name\", name, options);\n    },\n    \n    /**\n     * Gets the Parse.Relation for the Parse.Users that are direct\n     * children of this role. These users are granted any privileges that this\n     * role has been granted (e.g. read or write access through ACLs). You can\n     * add or remove users from the role through this relation.\n     * \n     * <p>This is equivalent to calling role.relation(\"users\")</p>\n     * \n     * @return {Parse.Relation} the relation for the users belonging to this\n     *     role.\n     */\n    getUsers: function() {\n      return this.relation(\"users\");\n    },\n    \n    /**\n     * Gets the Parse.Relation for the Parse.Roles that are direct\n     * children of this role. These roles' users are granted any privileges that\n     * this role has been granted (e.g. read or write access through ACLs). You\n     * can add or remove child roles from this role through this relation.\n     * \n     * <p>This is equivalent to calling role.relation(\"roles\")</p>\n     * \n     * @return {Parse.Relation} the relation for the roles belonging to this\n     *     role.\n     */\n    getRoles: function() {\n      return this.relation(\"roles\");\n    },\n    \n    /**\n     * @ignore\n     */\n    validate: function(attrs, options) {\n      if (\"name\" in attrs && attrs.name !== this.getName()) {\n        var newName = attrs.name;\n        if (this.id && this.id !== attrs.objectId) {\n          // Check to see if the objectId being set matches this.id.\n          // This happens during a fetch -- the id is set before calling fetch.\n          // Let the name be set in this case.\n          return new Parse.Error(Parse.Error.OTHER_CAUSE,\n              \"A role's name can only be set before it has been saved.\");\n        }\n        if (!_.isString(newName)) {\n          return new Parse.Error(Parse.Error.OTHER_CAUSE,\n              \"A role's name must be a String.\");\n        }\n        if (!(/^[0-9a-zA-Z\\-_ ]+$/).test(newName)) {\n          return new Parse.Error(Parse.Error.OTHER_CAUSE,\n              \"A role's name can only contain alphanumeric characters, _,\" +\n              \" -, and spaces.\");\n        }\n      }\n      if (Parse.Object.prototype.validate) {\n        return Parse.Object.prototype.validate.call(this, attrs, options);\n      }\n      return false;\n    }\n  });\n}(this));\n\n\n/*global _: false */\n(function(root) {\n  root.Parse = root.Parse || {};\n  var Parse = root.Parse;\n  var _ = Parse._;\n\n  /**\n   * Creates a new instance with the given models and options.  Typically, you\n   * will not call this method directly, but will instead make a subclass using\n   * <code>Parse.Collection.extend</code>.\n   *\n   * @param {Array} models An array of instances of <code>Parse.Object</code>.\n   *\n   * @param {Object} options An optional object with Backbone-style options.\n   * Valid options are:<ul>\n   *   <li>model: The Parse.Object subclass that this collection contains.\n   *   <li>query: An instance of Parse.Query to use when fetching items.\n   *   <li>comparator: A string property name or function to sort by.\n   * </ul>\n   *\n   * @see Parse.Collection.extend\n   *\n   * @class\n   *\n   * <p>Provides a standard collection class for our sets of models, ordered\n   * or unordered.  For more information, see the\n   * <a href=\"http://documentcloud.github.com/backbone/#Collection\">Backbone\n   * documentation</a>.</p>\n   */\n  Parse.Collection = function(models, options) {\n    options = options || {};\n    if (options.comparator) {\n      this.comparator = options.comparator;\n    }\n    if (options.model) {\n      this.model = options.model;\n    }\n    if (options.query) {\n      this.query = options.query;\n    }\n    this._reset();\n    this.initialize.apply(this, arguments);\n    if (models) {\n      this.reset(models, {silent: true, parse: options.parse});\n    }\n  };\n\n  // Define the Collection's inheritable methods.\n  _.extend(Parse.Collection.prototype, Parse.Events,\n      /** @lends Parse.Collection.prototype */ {\n\n    // The default model for a collection is just a Parse.Object.\n    // This should be overridden in most cases.\n    // TODO: think harder. this is likely to be weird.\n    model: Parse.Object,\n\n    /**\n     * Initialize is an empty function by default. Override it with your own\n     * initialization logic.\n     */\n    initialize: function(){},\n\n    /**\n     * The JSON representation of a Collection is an array of the\n     * models' attributes.\n     */\n    toJSON: function() {\n      return this.map(function(model){ return model.toJSON(); });\n    },\n\n    /**\n     * Add a model, or list of models to the set. Pass **silent** to avoid\n     * firing the `add` event for every new model.\n     *\n     * @param {Array} models An array of instances of <code>Parse.Object</code>.\n     *\n     * @param {Object} options An optional object with Backbone-style options.\n     * Valid options are:<ul>\n     *   <li>at: The index at which to add the models.\n     *   <li>silent: Set to true to avoid firing the `add` event for every new\n     *   model.\n     * </ul>\n     */\n    add: function(models, options) {\n      var i, index, length, model, cid, id, cids = {}, ids = {};\n      options = options || {};\n      models = _.isArray(models) ? models.slice() : [models];\n\n      // Begin by turning bare objects into model references, and preventing\n      // invalid models or duplicate models from being added.\n      for (i = 0, length = models.length; i < length; i++) {\n        models[i] = this._prepareModel(models[i], options);\n        model = models[i];\n        if (!model) {\n          throw new Error(\"Can't add an invalid model to a collection\");\n        }\n        cid = model.cid;\n        if (cids[cid] || this._byCid[cid]) {\n          throw new Error(\"Duplicate cid: can't add the same model \" +\n                          \"to a collection twice\");\n        }\n        id = model.id;\n        if (!Parse._isNullOrUndefined(id) && (ids[id] || this._byId[id])) {\n          throw new Error(\"Duplicate id: can't add the same model \" +\n                          \"to a collection twice\");\n        }\n        ids[id] = model;\n        cids[cid] = model;\n      }\n\n      // Listen to added models' events, and index models for lookup by\n      // `id` and by `cid`.\n      for (i = 0; i < length; i++) {\n        (model = models[i]).on('all', this._onModelEvent, this);\n        this._byCid[model.cid] = model;\n        if (model.id) {\n          this._byId[model.id] = model;\n        }\n      }\n\n      // Insert models into the collection, re-sorting if needed, and triggering\n      // `add` events unless silenced.\n      this.length += length;\n      index = Parse._isNullOrUndefined(options.at) ? \n          this.models.length : options.at;\n      this.models.splice.apply(this.models, [index, 0].concat(models));\n      if (this.comparator) {\n        this.sort({silent: true});\n      }\n      if (options.silent) {\n        return this;\n      }\n      for (i = 0, length = this.models.length; i < length; i++) {\n        model = this.models[i];\n        if (cids[model.cid]) {\n          options.index = i;\n          model.trigger('add', model, this, options);\n        }\n      }\n      return this;\n    },\n\n    /**\n     * Remove a model, or a list of models from the set. Pass silent to avoid\n     * firing the <code>remove</code> event for every model removed.\n     *\n     * @param {Array} models The model or list of models to remove from the\n     *   collection.\n     * @param {Object} options An optional object with Backbone-style options.\n     * Valid options are: <ul>\n     *   <li>silent: Set to true to avoid firing the `remove` event.\n     * </ul>\n     */\n    remove: function(models, options) {\n      var i, l, index, model;\n      options = options || {};\n      models = _.isArray(models) ? models.slice() : [models];\n      for (i = 0, l = models.length; i < l; i++) {\n        model = this.getByCid(models[i]) || this.get(models[i]);\n        if (!model) {\n          continue;\n        }\n        delete this._byId[model.id];\n        delete this._byCid[model.cid];\n        index = this.indexOf(model);\n        this.models.splice(index, 1);\n        this.length--;\n        if (!options.silent) {\n          options.index = index;\n          model.trigger('remove', model, this, options);\n        }\n        this._removeReference(model);\n      }\n      return this;\n    },\n\n    /**\n     * Gets a model from the set by id.\n     * @param {String} id The Parse objectId identifying the Parse.Object to\n     * fetch from this collection.\n     */\n    get: function(id) {\n      return id && this._byId[id.id || id];\n    },\n\n    /**\n     * Gets a model from the set by client id.\n     * @param {} cid The Backbone collection id identifying the Parse.Object to\n     * fetch from this collection.\n     */\n    getByCid: function(cid) {\n      return cid && this._byCid[cid.cid || cid];\n    },\n\n    /**\n     * Gets the model at the given index.\n     *\n     * @param {Number} index The index of the model to return.\n     */\n    at: function(index) {\n      return this.models[index];\n    },\n\n    /**\n     * Forces the collection to re-sort itself. You don't need to call this\n     * under normal circumstances, as the set will maintain sort order as each\n     * item is added.\n     * @param {Object} options An optional object with Backbone-style options.\n     * Valid options are: <ul>\n     *   <li>silent: Set to true to avoid firing the `reset` event.\n     * </ul>\n     */\n    sort: function(options) {\n      options = options || {};\n      if (!this.comparator) {\n        throw new Error('Cannot sort a set without a comparator');\n      }\n      var boundComparator = _.bind(this.comparator, this);\n      if (this.comparator.length === 1) {\n        this.models = this.sortBy(boundComparator);\n      } else {\n        this.models.sort(boundComparator);\n      }\n      if (!options.silent) {\n        this.trigger('reset', this, options);\n      }\n      return this;\n    },\n\n    /**\n     * Plucks an attribute from each model in the collection.\n     * @param {String} attr The attribute to return from each model in the\n     * collection.\n     */\n    pluck: function(attr) {\n      return _.map(this.models, function(model){ return model.get(attr); });\n    },\n\n    /**\n     * When you have more items than you want to add or remove individually,\n     * you can reset the entire set with a new list of models, without firing\n     * any `add` or `remove` events. Fires `reset` when finished.\n     *\n     * @param {Array} models The model or list of models to remove from the\n     *   collection.\n     * @param {Object} options An optional object with Backbone-style options.\n     * Valid options are: <ul>\n     *   <li>silent: Set to true to avoid firing the `reset` event.\n     * </ul>\n     */\n    reset: function(models, options) {\n      var self = this;\n      models = models || [];\n      options = options || {};\n      Parse._arrayEach(this.models, function(model) {\n        self._removeReference(model);\n      });\n      this._reset();\n      this.add(models, {silent: true, parse: options.parse});\n      if (!options.silent) {\n        this.trigger('reset', this, options);\n      }\n      return this;\n    },\n\n    /**\n     * Fetches the default set of models for this collection, resetting the\n     * collection when they arrive. If `add: true` is passed, appends the\n     * models to the collection instead of resetting.\n     *\n     * @param {Object} options An optional object with Backbone-style options.\n     * Valid options are:<ul>\n     *   <li>silent: Set to true to avoid firing `add` or `reset` events for\n     *   models fetched by this fetch.\n     *   <li>success: A Backbone-style success callback.\n     *   <li>error: An Backbone-style error callback.\n     *   <li>useMasterKey: In Cloud Code and Node only, uses the Master Key for\n     *       this request.\n     *   <li>sessionToken: A valid session token, used for making a request on\n     *       behalf of a specific user.\n     * </ul>\n     */\n    fetch: function(options) {\n      options = _.clone(options) || {};\n      if (options.parse === undefined) {\n        options.parse = true;\n      }\n      var collection = this;\n      var query = this.query || new Parse.Query(this.model);\n      return query.find({\n        useMasterKey: options.useMasterKey,\n        sessionToken: options.sessionToken\n      }).then(function(results) {\n        if (options.add) {\n          collection.add(results, options);\n        } else {\n          collection.reset(results, options);\n        }\n        return collection;\n      })._thenRunCallbacks(options, this);\n    },\n\n    /**\n     * Creates a new instance of a model in this collection. Add the model to\n     * the collection immediately, unless `wait: true` is passed, in which case\n     * we wait for the server to agree.\n     *\n     * @param {Parse.Object} model The new model to create and add to the\n     *   collection.\n     * @param {Object} options An optional object with Backbone-style options.\n     * Valid options are:<ul>\n     *   <li>wait: Set to true to wait for the server to confirm creation of the\n     *       model before adding it to the collection.\n     *   <li>silent: Set to true to avoid firing an `add` event.\n     *   <li>success: A Backbone-style success callback.\n     *   <li>error: An Backbone-style error callback.\n     *   <li>useMasterKey: In Cloud Code and Node only, uses the Master Key for\n     *       this request.\n     *   <li>sessionToken: A valid session token, used for making a request on\n     *       behalf of a specific user.\n     * </ul>\n     */\n    create: function(model, options) {\n      var coll = this;\n      options = options ? _.clone(options) : {};\n      model = this._prepareModel(model, options);\n      if (!model) {\n        return false;\n      }\n      if (!options.wait) {\n        coll.add(model, options);\n      }\n      var success = options.success;\n      options.success = function(nextModel, resp, xhr) {\n        if (options.wait) {\n          coll.add(nextModel, options);\n        }\n        if (success) {\n          success(nextModel, resp);\n        } else {\n          nextModel.trigger('sync', model, resp, options);\n        }\n      };\n      model.save(null, options);\n      return model;\n    },\n\n    /**\n     * Converts a response into a list of models to be added to the collection.\n     * The default implementation is just to pass it through.\n     * @ignore\n     */\n    parse: function(resp, xhr) {\n      return resp;\n    },\n\n    /**\n     * Proxy to _'s chain. Can't be proxied the same way the rest of the\n     * underscore methods are proxied because it relies on the underscore\n     * constructor.\n     */\n    chain: function() {\n      return _(this.models).chain();\n    },\n\n    /**\n     * Reset all internal state. Called when the collection is reset.\n     */\n    _reset: function(options) {\n      this.length = 0;\n      this.models = [];\n      this._byId  = {};\n      this._byCid = {};\n    },\n\n    /**\n     * Prepare a model or hash of attributes to be added to this collection.\n     */\n    _prepareModel: function(model, options) {\n      if (!(model instanceof Parse.Object)) {\n        var attrs = model;\n        options.collection = this;\n        model = new this.model(attrs, options);\n        if (!model._validate(model.attributes, options)) {\n          model = false;\n        }\n      } else if (!model.collection) {\n        model.collection = this;\n      }\n      return model;\n    },\n\n    /**\n     * Internal method to remove a model's ties to a collection.\n     */\n    _removeReference: function(model) {\n      if (this === model.collection) {\n        delete model.collection;\n      }\n      model.off('all', this._onModelEvent, this);\n    },\n\n    /**\n     * Internal method called every time a model in the set fires an event.\n     * Sets need to update their indexes when models change ids. All other\n     * events simply proxy through. \"add\" and \"remove\" events that originate\n     * in other collections are ignored.\n     */\n    _onModelEvent: function(ev, model, collection, options) {\n      if ((ev === 'add' || ev === 'remove') && collection !== this) {\n        return;\n      }\n      if (ev === 'destroy') {\n        this.remove(model, options);\n      }\n      if (model && ev === 'change:objectId') {\n        delete this._byId[model.previous(\"objectId\")];\n        this._byId[model.id] = model;\n      }\n      this.trigger.apply(this, arguments);\n    }\n\n  });\n\n  // Underscore methods that we want to implement on the Collection.\n  var methods = ['forEach', 'each', 'map', 'reduce', 'reduceRight', 'find',\n    'detect', 'filter', 'select', 'reject', 'every', 'all', 'some', 'any',\n    'include', 'contains', 'invoke', 'max', 'min', 'sortBy', 'sortedIndex',\n    'toArray', 'size', 'first', 'initial', 'rest', 'last', 'without', 'indexOf',\n    'shuffle', 'lastIndexOf', 'isEmpty', 'groupBy'];\n\n  // Mix in each Underscore method as a proxy to `Collection#models`.\n  Parse._arrayEach(methods, function(method) {\n    Parse.Collection.prototype[method] = function() {\n      return _[method].apply(_, [this.models].concat(_.toArray(arguments)));\n    };\n  });\n\n  /**\n   * Creates a new subclass of <code>Parse.Collection</code>.  For example,<pre>\n   *   var MyCollection = Parse.Collection.extend({\n   *     // Instance properties\n   *\n   *     model: MyClass,\n   *     query: MyQuery,\n   *\n   *     getFirst: function() {\n   *       return this.at(0);\n   *     }\n   *   }, {\n   *     // Class properties\n   *\n   *     makeOne: function() {\n   *       return new MyCollection();\n   *     }\n   *   });\n   *\n   *   var collection = new MyCollection();\n   * </pre>\n   *\n   * @function\n   * @param {Object} instanceProps Instance properties for the collection.\n   * @param {Object} classProps Class properies for the collection.\n   * @return {Class} A new subclass of <code>Parse.Collection</code>.\n   */\n  Parse.Collection.extend = Parse._extend;\n\n}(this));\n\n/*global _: false, document: false */\n(function(root) {\n  root.Parse = root.Parse || {};\n  var Parse = root.Parse;\n  var _ = Parse._;\n\n  /**\n   * Creating a Parse.View creates its initial element outside of the DOM,\n   * if an existing element is not provided...\n   * @class\n   *\n   * <p>A fork of Backbone.View, provided for your convenience.  If you use this\n   * class, you must also include jQuery, or another library that provides a\n   * jQuery-compatible $ function.  For more information, see the\n   * <a href=\"http://documentcloud.github.com/backbone/#View\">Backbone\n   * documentation</a>.</p>\n   * <p><strong><em>Available in the client SDK only.</em></strong></p>\n   */\n  Parse.View = function(options) {\n    this.cid = _.uniqueId('view');\n    this._configure(options || {});\n    this._ensureElement();\n    this.initialize.apply(this, arguments);\n    this.delegateEvents();\n  };\n\n  // Cached regex to split keys for `delegate`.\n  var eventSplitter = /^(\\S+)\\s*(.*)$/;\n\n  // List of view options to be merged as properties.\n  // TODO: include objectId, createdAt, updatedAt?\n  var viewOptions = ['model', 'collection', 'el', 'id', 'attributes',\n                     'className', 'tagName'];\n\n  // Set up all inheritable **Parse.View** properties and methods.\n  _.extend(Parse.View.prototype, Parse.Events,\n           /** @lends Parse.View.prototype */ {\n\n    // The default `tagName` of a View's element is `\"div\"`.\n    tagName: 'div',\n\n    /**\n     * jQuery delegate for element lookup, scoped to DOM elements within the\n     * current view. This should be prefered to global lookups where possible.\n     */\n    $: function(selector) {\n      return this.$el.find(selector);\n    },\n\n    /**\n     * Initialize is an empty function by default. Override it with your own\n     * initialization logic.\n     */\n    initialize: function(){},\n\n    /**\n     * The core function that your view should override, in order\n     * to populate its element (`this.el`), with the appropriate HTML. The\n     * convention is for **render** to always return `this`.\n     */\n    render: function() {\n      return this;\n    },\n\n    /**\n     * Remove this view from the DOM. Note that the view isn't present in the\n     * DOM by default, so calling this method may be a no-op.\n     */\n    remove: function() {\n      this.$el.remove();\n      return this;\n    },\n\n    /**\n     * For small amounts of DOM Elements, where a full-blown template isn't\n     * needed, use **make** to manufacture elements, one at a time.\n     * <pre>\n     *     var el = this.make('li', {'class': 'row'},\n     *                        this.model.escape('title'));</pre>\n     */\n    make: function(tagName, attributes, content) {\n      var el = document.createElement(tagName);\n      if (attributes) {\n        Parse.$(el).attr(attributes);\n      }\n      if (content) {\n        Parse.$(el).html(content);\n      }\n      return el;\n    },\n\n    /**\n     * Changes the view's element (`this.el` property), including event\n     * re-delegation.\n     */\n    setElement: function(element, delegate) {\n      this.$el = Parse.$(element);\n      this.el = this.$el[0];\n      if (delegate !== false) {\n        this.delegateEvents();\n      }\n      return this;\n    },\n\n    /**\n     * Set callbacks.  <code>this.events</code> is a hash of\n     * <pre>\n     * *{\"event selector\": \"callback\"}*\n     *\n     *     {\n     *       'mousedown .title':  'edit',\n     *       'click .button':     'save'\n     *       'click .open':       function(e) { ... }\n     *     }\n     * </pre>\n     * pairs. Callbacks will be bound to the view, with `this` set properly.\n     * Uses event delegation for efficiency.\n     * Omitting the selector binds the event to `this.el`.\n     * This only works for delegate-able events: not `focus`, `blur`, and\n     * not `change`, `submit`, and `reset` in Internet Explorer.\n     */\n    delegateEvents: function(events) {\n      events = events || Parse._getValue(this, 'events');\n      if (!events) {\n        return;\n      }\n      this.undelegateEvents();\n      var self = this;\n      Parse._objectEach(events, function(method, key) {\n        if (!_.isFunction(method)) {\n          method = self[events[key]];\n        }\n        if (!method) {\n          throw new Error('Event \"' + events[key] + '\" does not exist');\n        }\n        var match = key.match(eventSplitter);\n        var eventName = match[1], selector = match[2];\n        method = _.bind(method, self);\n        eventName += '.delegateEvents' + self.cid;\n        if (selector === '') {\n          self.$el.bind(eventName, method);\n        } else {\n          self.$el.delegate(selector, eventName, method);\n        }\n      });\n    },\n\n    /**\n     * Clears all callbacks previously bound to the view with `delegateEvents`.\n     * You usually don't need to use this, but may wish to if you have multiple\n     * Backbone views attached to the same DOM element.\n     */\n    undelegateEvents: function() {\n      this.$el.unbind('.delegateEvents' + this.cid);\n    },\n\n    /**\n     * Performs the initial configuration of a View with a set of options.\n     * Keys with special meaning *(model, collection, id, className)*, are\n     * attached directly to the view.\n     */\n    _configure: function(options) {\n      if (this.options) {\n        options = _.extend({}, this.options, options);\n      }\n      var self = this;\n      _.each(viewOptions, function(attr) {\n        if (options[attr]) {\n          self[attr] = options[attr];\n        }\n      });\n      this.options = options;\n    },\n\n    /**\n     * Ensure that the View has a DOM element to render into.\n     * If `this.el` is a string, pass it through `$()`, take the first\n     * matching element, and re-assign it to `el`. Otherwise, create\n     * an element from the `id`, `className` and `tagName` properties.\n     */\n    _ensureElement: function() {\n      if (!this.el) {\n        var attrs = Parse._getValue(this, 'attributes') || {};\n        if (this.id) {\n          attrs.id = this.id;\n        }\n        if (this.className) {\n          attrs['class'] = this.className;\n        }\n        this.setElement(this.make(this.tagName, attrs), false);\n      } else {\n        this.setElement(this.el, false);\n      }\n    }\n\n  });\n\n  /**\n   * @function\n   * @param {Object} instanceProps Instance properties for the view.\n   * @param {Object} classProps Class properies for the view.\n   * @return {Class} A new subclass of <code>Parse.View</code>.\n   */\n  Parse.View.extend = Parse._extend;\n\n}(this));\n\n(function(root) {\n  root.Parse = root.Parse || {};\n  var Parse = root.Parse;\n  var _ = Parse._;\n\n  /**\n   * @class\n   *\n   * <p>A Parse.User object is a local representation of a user persisted to the\n   * Parse cloud. This class is a subclass of a Parse.Object, and retains the\n   * same functionality of a Parse.Object, but also extends it with various\n   * user specific methods, like authentication, signing up, and validation of\n   * uniqueness.</p>\n   */\n  Parse.User = Parse.Object.extend(\"_User\", /** @lends Parse.User.prototype */ {\n    // Instance Variables\n    _isCurrentUser: false,\n\n\n    // Instance Methods\n    \n    /**\n     * Merges another object's attributes into this object.\n     */\n    _mergeFromObject: function(other) {\n      if (other.getSessionToken()) {\n        this._sessionToken = other.getSessionToken();      \n      }    \n      Parse.User.__super__._mergeFromObject.call(this, other);\n    },    \n\n    /**\n     * Internal method to handle special fields in a _User response.\n     */\n    _mergeMagicFields: function(attrs) {\n      if (attrs.sessionToken) {\n        this._sessionToken = attrs.sessionToken;\n        delete attrs.sessionToken;\n      }\n      Parse.User.__super__._mergeMagicFields.call(this, attrs);\n    },\n\n    /**\n     * Removes null values from authData (which exist temporarily for\n     * unlinking)\n     */\n    _cleanupAuthData: function() {\n      if (!this.isCurrent()) {\n        return;\n      }\n      var authData = this.get('authData');\n      if (!authData) {\n        return;\n      }\n      Parse._objectEach(this.get('authData'), function(value, key) {\n        if (!authData[key]) {\n          delete authData[key];\n        }\n      });\n    },\n\n    /**\n     * Synchronizes authData for all providers.\n     */\n    _synchronizeAllAuthData: function() {\n      var authData = this.get('authData');\n      if (!authData) {\n        return;\n      }\n\n      var self = this;\n      Parse._objectEach(this.get('authData'), function(value, key) {\n        self._synchronizeAuthData(key);\n      });\n    },\n\n    /**\n     * Synchronizes auth data for a provider (e.g. puts the access token in the\n     * right place to be used by the Facebook SDK).\n     */\n    _synchronizeAuthData: function(provider) {\n      if (!this.isCurrent()) {\n        return;\n      }\n      var authType;\n      if (_.isString(provider)) {\n        authType = provider;\n        provider = Parse.User._authProviders[authType];\n      } else {\n        authType = provider.getAuthType();\n      }\n      var authData = this.get('authData');\n      if (!authData || !provider) {\n        return;\n      }\n      var success = provider.restoreAuthentication(authData[authType]);\n      if (!success) {\n        this._unlinkFrom(provider);\n      }\n    },\n\n    _handleSaveResult: function(makeCurrent) {\n      // Clean up and synchronize the authData object, removing any unset values\n      if (makeCurrent) {\n        this._isCurrentUser = true;\n      }\n      this._cleanupAuthData();\n      this._synchronizeAllAuthData();\n      // Don't keep the password around.\n      delete this._serverData.password;\n      this._rebuildEstimatedDataForKey(\"password\");\n      this._refreshCache();\n      if (makeCurrent || this.isCurrent()) {\n        Parse.User._saveCurrentUser(this);\n      }\n    },\n\n    /**\n     * Unlike in the Android/iOS SDKs, logInWith is unnecessary, since you can\n     * call linkWith on the user (even if it doesn't exist yet on the server).\n     */\n    _linkWith: function(provider, options) {\n      var authType;\n      if (_.isString(provider)) {\n        authType = provider;\n        provider = Parse.User._authProviders[provider];\n      } else {\n        authType = provider.getAuthType();\n      }\n      if (_.has(options, 'authData')) {\n        var authData = this.get('authData') || {};\n        authData[authType] = options.authData;\n        this.set('authData', authData);\n\n        // Overridden so that the user can be made the current user.\n        var newOptions = _.clone(options) || {};\n        newOptions.success = function(model) {\n          model._handleSaveResult(true);\n          if (options.success) {\n            options.success.apply(this, arguments);\n          }\n        };\n        return this.save({'authData': authData}, newOptions);\n      } else {\n        var self = this;\n        var promise = new Parse.Promise();\n        provider.authenticate({\n          success: function(provider, result) {\n            self._linkWith(provider, {\n              authData: result,\n              success: options.success,\n              error: options.error\n            }).then(function() {\n              promise.resolve(self);\n            });\n          },\n          error: function(provider, error) {\n            if (options.error) {\n              options.error(self, error);\n            }\n            promise.reject(error);\n          }\n        });\n        return promise;\n      }\n    },\n\n    /**\n     * Unlinks a user from a service.\n     */\n    _unlinkFrom: function(provider, options) {\n      var authType;\n      if (_.isString(provider)) {\n        authType = provider;\n        provider = Parse.User._authProviders[provider];\n      } else {\n        authType = provider.getAuthType();\n      }\n      var newOptions = _.clone(options);\n      var self = this;\n      newOptions.authData = null;\n      newOptions.success = function(model) {\n        self._synchronizeAuthData(provider);\n        if (options.success) {\n          options.success.apply(this, arguments);\n        }\n      };\n      return this._linkWith(provider, newOptions);\n    },\n\n    /**\n     * Checks whether a user is linked to a service.\n     */\n    _isLinked: function(provider) {\n      var authType;\n      if (_.isString(provider)) {\n        authType = provider;\n      } else {\n        authType = provider.getAuthType();\n      }\n      var authData = this.get('authData') || {};\n      return !!authData[authType];\n    },\n\n    /**\n     * Deauthenticates all providers.\n     */\n    _logOutWithAll: function() {\n      var authData = this.get('authData');\n      if (!authData) {\n        return;\n      }\n      var self = this;\n      Parse._objectEach(this.get('authData'), function(value, key) {\n        self._logOutWith(key);\n      });\n    },\n\n    /**\n     * Deauthenticates a single provider (e.g. removing access tokens from the\n     * Facebook SDK).\n     */\n    _logOutWith: function(provider) {\n      if (!this.isCurrent()) {\n        return;\n      }\n      if (_.isString(provider)) {\n        provider = Parse.User._authProviders[provider];\n      }\n      if (provider && provider.deauthenticate) {\n        provider.deauthenticate();\n      }\n    },\n\n    /**\n     * Signs up a new user. You should call this instead of save for\n     * new Parse.Users. This will create a new Parse.User on the server, and\n     * also persist the session on disk so that you can access the user using\n     * <code>current</code>.\n     *\n     * <p>A username and password must be set before calling signUp.</p>\n     *\n     * <p>Calls options.success or options.error on completion.</p>\n     *\n     * @param {Object} attrs Extra fields to set on the new user, or null.\n     * @param {Object} options A Backbone-style options object.\n     * @return {Parse.Promise} A promise that is fulfilled when the signup\n     *     finishes.\n     * @see Parse.User.signUp\n     */\n    signUp: function(attrs, options) {\n      var error;\n      options = options || {};\n\n      var username = (attrs && attrs.username) || this.get(\"username\");\n      if (!username || (username === \"\")) {\n        error = new Parse.Error(\n            Parse.Error.OTHER_CAUSE,\n            \"Cannot sign up user with an empty name.\");\n        if (options && options.error) {\n          options.error(this, error);\n        }\n        return Parse.Promise.error(error);\n      }\n\n      var password = (attrs && attrs.password) || this.get(\"password\");\n      if (!password || (password === \"\")) {\n        error = new Parse.Error(\n            Parse.Error.OTHER_CAUSE,\n            \"Cannot sign up user with an empty password.\");\n        if (options && options.error) {\n          options.error(this, error);\n        }\n        return Parse.Promise.error(error);\n      }\n\n      // Overridden so that the user can be made the current user.\n      var newOptions = _.clone(options);\n      newOptions.success = function(model) {\n        model._handleSaveResult(Parse.User._canUseCurrentUser());\n        if (options.success) {\n          options.success.apply(this, arguments);\n        }\n      };\n      return this.save(attrs, newOptions);\n    },\n\n    /**\n     * Logs in a Parse.User. On success, this saves the session to localStorage,\n     * so you can retrieve the currently logged in user using\n     * <code>current</code>.\n     *\n     * <p>A username and password must be set before calling logIn.</p>\n     *\n     * <p>Calls options.success or options.error on completion.</p>\n     *\n     * @param {Object} options A Backbone-style options object.\n     * @see Parse.User.logIn\n     * @return {Parse.Promise} A promise that is fulfilled with the user when\n     *     the login is complete.\n     */\n    logIn: function(options) {\n      if (!Parse.User._canUseCurrentUser()) {\n        throw new Error(\n          'It is not possible to log in on a server environment.'\n        );\n      }\n      var model = this;\n      options = options || {};\n      var request = Parse._request({\n        route: \"login\",\n        method: \"GET\",\n        useMasterKey: options.useMasterKey,\n        data: this.toJSON()\n      });\n      return request.then(function(resp, status, xhr) {\n        var serverAttrs = model.parse(resp, status, xhr);\n        model._finishFetch(serverAttrs);\n        model._handleSaveResult(true);\n        return model;\n      })._thenRunCallbacks(options, this);\n    },\n\n    /**\n     * @see Parse.Object#save\n     */\n    save: function(arg1, arg2, arg3) {\n      var i, attrs, current, options, saved;\n      if (_.isObject(arg1) || _.isNull(arg1) || _.isUndefined(arg1)) {\n        attrs = arg1;\n        options = arg2;\n      } else {\n        attrs = {};\n        attrs[arg1] = arg2;\n        options = arg3;\n      }\n      options = options || {};\n\n      var newOptions = _.clone(options);\n      newOptions.success = function(model) {\n        model._handleSaveResult(false);\n        if (options.success) {\n          options.success.apply(this, arguments);\n        }\n      };\n      return Parse.Object.prototype.save.call(this, attrs, newOptions);\n    },\n\n    /**\n     * @see Parse.Object#fetch\n     */\n    fetch: function(options) {\n      var newOptions = options ? _.clone(options) : {};\n      newOptions.success = function(model) {\n        model._handleSaveResult(false);\n        if (options && options.success) {\n          options.success.apply(this, arguments);\n        }\n      };\n      return Parse.Object.prototype.fetch.call(this, newOptions);\n    },\n\n    /**\n     * Returns true if <code>current</code> would return this user.\n     * @see Parse.User#current\n     */\n    isCurrent: function() {\n      return this._isCurrentUser;\n    },\n\n    /**\n     * Returns get(\"username\").\n     * @return {String}\n     * @see Parse.Object#get\n     */\n    getUsername: function() {\n      return this.get(\"username\");\n    },\n\n    /**\n     * Calls set(\"username\", username, options) and returns the result.\n     * @param {String} username\n     * @param {Object} options A Backbone-style options object.\n     * @return {Boolean}\n     * @see Parse.Object.set\n     */\n    setUsername: function(username, options) {\n      return this.set(\"username\", username, options);\n    },\n\n    /**\n     * Calls set(\"password\", password, options) and returns the result.\n     * @param {String} password\n     * @param {Object} options A Backbone-style options object.\n     * @return {Boolean}\n     * @see Parse.Object.set\n     */\n    setPassword: function(password, options) {\n      return this.set(\"password\", password, options);\n    },\n\n    /**\n     * Returns get(\"email\").\n     * @return {String}\n     * @see Parse.Object#get\n     */\n    getEmail: function() {\n      return this.get(\"email\");\n    },\n\n    /**\n     * Calls set(\"email\", email, options) and returns the result.\n     * @param {String} email\n     * @param {Object} options A Backbone-style options object.\n     * @return {Boolean}\n     * @see Parse.Object.set\n     */\n    setEmail: function(email, options) {\n      return this.set(\"email\", email, options);\n    },\n\n    /**\n     * Checks whether this user is the current user and has been authenticated.\n     * @return (Boolean) whether this user is the current user and is logged in.\n     */\n    authenticated: function() {\n      return !!this._sessionToken &&\n          (Parse.User.current() && Parse.User.current().id === this.id);\n    },\n\n    /**\n     * Returns the session token for this user, if the user has been logged in,\n     * or if it is the result of a query with the master key. Otherwise, returns\n     * undefined.\n     * @return {String} the session token, or undefined\n     */\n    getSessionToken: function() {\n      return this._sessionToken;\n    },\n\n    /**\n     * Request a revocable session token to replace the older style of token.\n     * @param {Object} options A Backbone-style options object.\n     *\n     * @return {Parse.Promise} A promise that is resolved when the replacement\n     *   token has been fetched.\n     */\n    _upgradeToRevocableSession: function(options) {\n      options = options || {};\n      if (!Parse.User.current()) {\n        return Parse.Promise.as()._thenRunCallbacks(options);\n      }\n      var currentSession = Parse.User.current().getSessionToken();\n      if (Parse.Session._isRevocable(currentSession)) {\n        return Parse.Promise.as()._thenRunCallbacks(options);\n      }\n      return Parse._request({\n        route: 'upgradeToRevocableSession',\n        method: 'POST',\n        useMasterKey: options.useMasterKey,\n        sessionToken: currentSession\n      }).then(function(result) {\n        var session = new Parse.Session();\n        session._finishFetch(result);\n        var currentUser = Parse.User.current();\n        currentUser._sessionToken = session.getSessionToken();\n        Parse.User._saveCurrentUser(currentUser);\n      })._thenRunCallbacks(options);\n    },\n\n  }, /** @lends Parse.User */ {\n    // Class Variables\n\n    // The currently logged-in user.\n    _currentUser: null,\n\n    // Whether currentUser is known to match the serialized version on disk.\n    // This is useful for saving a localstorage check if you try to load\n    // _currentUser frequently while there is none stored.\n    _currentUserMatchesDisk: false,\n\n    // The localStorage key suffix that the current user is stored under.\n    _CURRENT_USER_KEY: \"currentUser\",\n\n    // The mapping of auth provider names to actual providers\n    _authProviders: {},\n\n    // Whether to rewrite className User to _User\n    _performUserRewrite: true,\n\n    // Whether to send a Revocable Session header\n    _isRevocableSessionEnabled: false,\n\n    // Whether to enable a memory-unsafe current user in node.js\n    _enableUnsafeCurrentUser: false,\n\n\n    // Class Methods\n\n    /**\n     * Signs up a new user with a username (or email) and password.\n     * This will create a new Parse.User on the server, and also persist the\n     * session in localStorage so that you can access the user using\n     * {@link #current}.\n     *\n     * <p>Calls options.success or options.error on completion.</p>\n     *\n     * @param {String} username The username (or email) to sign up with.\n     * @param {String} password The password to sign up with.\n     * @param {Object} attrs Extra fields to set on the new user.\n     * @param {Object} options A Backbone-style options object.\n     * @return {Parse.Promise} A promise that is fulfilled with the user when\n     *     the signup completes.\n     * @see Parse.User#signUp\n     */\n    signUp: function(username, password, attrs, options) {\n      attrs = attrs || {};\n      attrs.username = username;\n      attrs.password = password;\n      var user = Parse.Object._create(\"_User\");\n      return user.signUp(attrs, options);\n    },\n\n    /**\n     * Logs in a user with a username (or email) and password. On success, this\n     * saves the session to disk, so you can retrieve the currently logged in\n     * user using <code>current</code>.\n     *\n     * <p>Calls options.success or options.error on completion.</p>\n     *\n     * @param {String} username The username (or email) to log in with.\n     * @param {String} password The password to log in with.\n     * @param {Object} options A Backbone-style options object.\n     * @return {Parse.Promise} A promise that is fulfilled with the user when\n     *     the login completes.\n     * @see Parse.User#logIn\n     */\n    logIn: function(username, password, options) {\n      var user = Parse.Object._create(\"_User\");\n      user._finishFetch({ username: username, password: password });\n      return user.logIn(options);\n    },\n\n    /**\n     * Logs in a user with a session token. On success, this saves the session\n     * to disk, so you can retrieve the currently logged in user using\n     * <code>current</code>.\n     *\n     * <p>Calls options.success or options.error on completion.</p>\n     *\n     * @param {String} sessionToken The sessionToken to log in with.\n     * @param {Object} options A Backbone-style options object.\n     * @return {Parse.Promise} A promise that is fulfilled with the user when\n     *     the login completes.\n     */\n    become: function(sessionToken, options) {\n      if (!Parse.User._canUseCurrentUser()) {\n        throw new Error(\n          'It is not secure to become a user on a node.js server environment.'\n        );\n      }\n      options = options || {};\n\n      var user = Parse.Object._create(\"_User\");\n      return Parse._request({\n        route: \"users\",\n        className: \"me\",\n        method: \"GET\",\n        useMasterKey: options.useMasterKey,\n        sessionToken: sessionToken\n      }).then(function(resp, status, xhr) {\n        var serverAttrs = user.parse(resp, status, xhr);\n        user._finishFetch(serverAttrs);\n        user._handleSaveResult(true);\n        return user;\n\n      })._thenRunCallbacks(options, user);\n    },\n\n    /**\n     * Logs out the currently logged in user session. This will remove the\n     * session from disk, log out of linked services, and future calls to\n     * <code>current</code> will return <code>null</code>.\n     * @return {Parse.Promise} A promise that is resolved when the session is\n     *   destroyed on the server.\n     */\n    logOut: function() {\n      if (!Parse.User._canUseCurrentUser()) {\n        throw new Error(\n          'There is no current user user on a node.js server environment.'\n        );\n      }\n      return Parse.User._currentAsync().then(function(currentUser) {\n        var promise = Parse.Storage.removeItemAsync(\n          Parse._getParsePath(Parse.User._CURRENT_USER_KEY));\n\n        if (currentUser !== null) {\n          var currentSession = currentUser.getSessionToken();\n          if (Parse.Session._isRevocable(currentSession)) {\n            promise.then(function() {\n              return Parse._request({\n                route: 'logout',\n                method: 'POST',\n                sessionToken: currentSession\n              });\n            });\n          }\n          currentUser._logOutWithAll();\n          currentUser._isCurrentUser = false;\n        }\n        Parse.User._currentUserMatchesDisk = true;\n        Parse.User._currentUser = null;\n\n        return promise;\n      });\n    },\n\n    /**\n     * Requests a password reset email to be sent to the specified email address\n     * associated with the user account. This email allows the user to securely\n     * reset their password on the Parse site.\n     *\n     * <p>Calls options.success or options.error on completion.</p>\n     *\n     * @param {String} email The email address associated with the user that\n     *     forgot their password.\n     * @param {Object} options A Backbone-style options object.\n     */\n    requestPasswordReset: function(email, options) {\n      options = options || {};\n      var request = Parse._request({\n        route: \"requestPasswordReset\",\n        method: \"POST\",\n        useMasterKey: options.useMasterKey,\n        data: { email: email }\n      });\n      return request._thenRunCallbacks(options);\n    },\n\n    /**\n     * Retrieves the currently logged in ParseUser with a valid session,\n     * either from memory or localStorage, if necessary.\n     * @return {Parse.Object} The currently logged in Parse.User.\n     */\n    current: function() {\n      if (!Parse.User._canUseCurrentUser()) {\n        throw new Error(\n          'There is no current user user on a node.js server environment.'\n        );\n      }\n      if (Parse.Storage.async) {\n        // We can't return the current user synchronously\n        Parse.User._currentAsync();\n        return Parse.User._currentUser;\n      }\n      \n      if (Parse.User._currentUser) {\n        return Parse.User._currentUser;\n      }\n\n      if (Parse.User._currentUserMatchesDisk) {\n        // TODO: Lazily log in anonymous user.\n        return Parse.User._currentUser;\n      }\n\n      // Load the user from local storage.\n      Parse.User._currentUserMatchesDisk = true;\n\n      var userData = Parse.Storage.getItem(Parse._getParsePath(\n          Parse.User._CURRENT_USER_KEY));\n      if (!userData) {\n        // TODO: Lazily log in anonymous user.\n        return null;\n      }\n      Parse.User._currentUser = Parse.Object._create(\"_User\");\n      Parse.User._currentUser._isCurrentUser = true;\n\n      var json = JSON.parse(userData);\n      Parse.User._currentUser.id = json._id;\n      delete json._id;\n      Parse.User._currentUser._sessionToken = json._sessionToken;\n      delete json._sessionToken;\n      Parse.User._currentUser._finishFetch(json);\n\n      Parse.User._currentUser._synchronizeAllAuthData();\n      Parse.User._currentUser._refreshCache();\n      Parse.User._currentUser._opSetQueue = [{}];\n      return Parse.User._currentUser;\n    },\n\n    /**\n     * Retrieves the currently logged in ParseUser from asynchronous Storage.\n     * @return {Parse.Promise} A Promise that is resolved with the currently\n     *   logged in Parse User\n     */\n    _currentAsync: function() {\n      if (Parse.User._currentUser) {\n        return Parse.Promise.as(Parse.User._currentUser);\n      }\n\n      if (Parse.User._currentUserMatchesDisk) {\n        return Parse.Promise.as(Parse.User._currentUser);\n      }\n\n      // Load the user from Storage\n      return Parse.Storage.getItemAsync(Parse._getParsePath(\n        Parse.User._CURRENT_USER_KEY)).then(function(userData) {\n        if (!userData) {\n          return null;\n        }\n        Parse.User._currentUser = Parse.Object._create(\"_User\");\n        Parse.User._currentUser._isCurrentUser = true;\n\n        var json = JSON.parse(userData);\n        Parse.User._currentUser.id = json._id;\n        delete json._id;\n        Parse.User._currentUser._sessionToken = json._sessionToken;\n        delete json._sessionToken;\n        Parse.User._currentUser._finishFetch(json);\n\n        Parse.User._currentUser._synchronizeAllAuthData();\n        Parse.User._currentUser._refreshCache();\n        Parse.User._currentUser._opSetQueue = [{}];\n        return Parse.User._currentUser;\n      });\n    },\n\n    /**\n     * Allow someone to define a custom User class without className\n     * being rewritten to _User. The default behavior is to rewrite\n     * User to _User for legacy reasons. This allows developers to\n     * override that behavior.\n     *\n     * @param {Boolean} isAllowed Whether or not to allow custom User class\n     */\n    allowCustomUserClass: function(isAllowed) {\n      this._performUserRewrite = !isAllowed;\n    },\n\n    /**\n     * Allow a legacy application to start using revocable sessions. If the\n     * current session token is not revocable, a request will be made for a new,\n     * revocable session.\n     * It is not necessary to call this method from cloud code unless you are\n     * handling user signup or login from the server side. In a cloud code call,\n     * this function will not attempt to upgrade the current token.\n     * @param {Object} options A Backbone-style options object.\n     *\n     * @return {Parse.Promise} A promise that is resolved when the process has\n     *   completed. If a replacement session token is requested, the promise\n     *   will be resolved after a new token has been fetched.\n     */\n    enableRevocableSession: function(options) {\n      options = options || {};\n      Parse.User._isRevocableSessionEnabled = true;\n      if (Parse.User._canUseCurrentUser() && Parse.User.current()) {\n        return Parse.User.current()._upgradeToRevocableSession(options);\n      }\n      return Parse.Promise.as()._thenRunCallbacks(options);\n    },\n\n    /**\n     *\n     */\n    enableUnsafeCurrentUser: function() {\n      Parse.User._enableUnsafeCurrentUser = true;\n    },\n\n    _canUseCurrentUser: function() {\n      return !Parse._isNode || Parse.User._enableUnsafeCurrentUser;\n    },\n\n    /**\n     * Persists a user as currentUser to localStorage, and into the singleton.\n     */\n    _saveCurrentUser: function(user) {\n      if (Parse.User._currentUser !== null &&\n          Parse.User._currentUser !== user) {\n        Parse.User.logOut();\n      }\n      user._isCurrentUser = true;\n      Parse.User._currentUser = user;\n      Parse.User._currentUserMatchesDisk = true;\n\n      var json = user.toJSON();\n      json._id = user.id;\n      json._sessionToken = user._sessionToken;\n      if (Parse.Storage.async) {\n        Parse.Storage.setItemAsync(\n          Parse._getParsePath(Parse.User._CURRENT_USER_KEY),\n          JSON.stringify(json));\n      } else {\n        Parse.Storage.setItem(\n          Parse._getParsePath(Parse.User._CURRENT_USER_KEY),\n          JSON.stringify(json));\n      }\n    },\n\n    _registerAuthenticationProvider: function(provider) {\n      Parse.User._authProviders[provider.getAuthType()] = provider;\n      // Synchronize the current user with the auth provider.\n      if (Parse.User.current()) {\n        Parse.User.current()._synchronizeAuthData(provider.getAuthType());\n      }\n    },\n\n    _logInWith: function(provider, options) {\n      var user = Parse.Object._create(\"_User\");\n      return user._linkWith(provider, options);\n    }\n\n  });\n}(this));\n\n\n(function(root) {\n  root.Parse = root.Parse || {};\n  var Parse = root.Parse;\n\n  /**\n   * @class\n   *\n   * <p>A Parse.Session object is a local representation of a revocable session.\n   * This class is a subclass of a Parse.Object, and retains the same\n   * functionality of a Parse.Object.</p>\n   */\n  Parse.Session = Parse.Object.extend('_Session',\n  /** @lends Parse.Session.prototype */\n  {\n    /**\n     * Returns the session token string.\n     * @return {String}\n     */\n    getSessionToken: function() {\n      return this._sessionToken;\n    },\n\n    /**\n     * Internal method to handle special fields in a _Session response.\n     */\n    _mergeMagicFields: function(attrs) {\n      if (attrs.sessionToken) {\n        this._sessionToken = attrs.sessionToken;\n        delete attrs.sessionToken;\n      }\n      Parse.Session.__super__._mergeMagicFields.call(this, attrs);\n    },\n  }, /** @lends Parse.Session */ {\n\n    // Throw an error when modifying these read-only fields\n    readOnlyAttributes: {\n      createdWith: true,\n      expiresAt: true,\n      installationId: true,\n      restricted: true,\n      sessionToken: true,\n      user: true\n    },\n\n    /**\n     * Retrieves the Session object for the currently logged in session.\n     * @return {Parse.Promise} A promise that is resolved with the Parse.Session\n     *   object after it has been fetched.\n     */\n    current: function(options) {\n      options = options || {};\n\n      var session = Parse.Object._create('_Session');\n      var currentToken = Parse.User.current().getSessionToken();\n      return Parse._request({\n        route: 'sessions',\n        className: 'me',\n        method: 'GET',\n        useMasterKey: options.useMasterKey,\n        sessionToken: currentToken\n      }).then(function(resp, status, xhr) {\n        var serverAttrs = session.parse(resp, status, xhr);\n        session._finishFetch(serverAttrs);\n        return session;\n      })._thenRunCallbacks(options, session);\n    },\n\n    /**\n     * Determines whether a session token is revocable.\n     * @return {Boolean}\n     */\n    _isRevocable: function(token) {\n      return token.indexOf('r:') > -1;\n    },\n\n    /**\n     * Determines whether the current session token is revocable.\n     * This method is useful for migrating Express.js or Node.js web apps to\n     * use revocable sessions. If you are migrating an app that uses the Parse\n     * SDK in the browser only, please use Parse.User.enableRevocableSession()\n     * instead, so that sessions can be automatically upgraded.\n     * @return {Boolean}\n     */\n    isCurrentSessionRevocable: function() {\n      if (Parse.User.current() !== null) {\n        return Parse.Session._isRevocable(\n          Parse.User.current().getSessionToken()\n        );\n      }\n    }\n  });\n})(this);\n\n// Parse.Query is a way to create a list of Parse.Objects.\n(function(root) {\n  root.Parse = root.Parse || {};\n  var Parse = root.Parse;\n  var _ = Parse._;\n\n  /**\n   * Creates a new parse Parse.Query for the given Parse.Object subclass.\n   * @param objectClass -\n   *   An instance of a subclass of Parse.Object, or a Parse className string.\n   * @class\n   *\n   * <p>Parse.Query defines a query that is used to fetch Parse.Objects. The\n   * most common use case is finding all objects that match a query through the\n   * <code>find</code> method. For example, this sample code fetches all objects\n   * of class <code>MyClass</code>. It calls a different function depending on\n   * whether the fetch succeeded or not.\n   * \n   * <pre>\n   * var query = new Parse.Query(MyClass);\n   * query.find({\n   *   success: function(results) {\n   *     // results is an array of Parse.Object.\n   *   },\n   *\n   *   error: function(error) {\n   *     // error is an instance of Parse.Error.\n   *   }\n   * });</pre></p>\n   * \n   * <p>A Parse.Query can also be used to retrieve a single object whose id is\n   * known, through the get method. For example, this sample code fetches an\n   * object of class <code>MyClass</code> and id <code>myId</code>. It calls a\n   * different function depending on whether the fetch succeeded or not.\n   * \n   * <pre>\n   * var query = new Parse.Query(MyClass);\n   * query.get(myId, {\n   *   success: function(object) {\n   *     // object is an instance of Parse.Object.\n   *   },\n   *\n   *   error: function(object, error) {\n   *     // error is an instance of Parse.Error.\n   *   }\n   * });</pre></p>\n   * \n   * <p>A Parse.Query can also be used to count the number of objects that match\n   * the query without retrieving all of those objects. For example, this\n   * sample code counts the number of objects of the class <code>MyClass</code>\n   * <pre>\n   * var query = new Parse.Query(MyClass);\n   * query.count({\n   *   success: function(number) {\n   *     // There are number instances of MyClass.\n   *   },\n   *\n   *   error: function(error) {\n   *     // error is an instance of Parse.Error.\n   *   }\n   * });</pre></p>\n   */\n  Parse.Query = function(objectClass) {\n    if (_.isString(objectClass)) {\n      objectClass = Parse.Object._getSubclass(objectClass);\n    }\n\n    this.objectClass = objectClass;\n\n    this.className = objectClass.prototype.className;\n\n    this._where = {};\n    this._include = [];\n    this._limit = -1; // negative limit means, do not send a limit\n    this._skip = 0;\n    this._extraOptions = {};\n  };\n\n  /**\n   * Constructs a Parse.Query that is the OR of the passed in queries.  For\n   * example:\n   * <pre>var compoundQuery = Parse.Query.or(query1, query2, query3);</pre>\n   *\n   * will create a compoundQuery that is an or of the query1, query2, and\n   * query3.\n   * @param {...Parse.Query} var_args The list of queries to OR.\n   * @return {Parse.Query} The query that is the OR of the passed in queries.\n   */\n  Parse.Query.or = function() {\n    var queries = _.toArray(arguments);\n    var className = null;\n    Parse._arrayEach(queries, function(q) {\n      if (_.isNull(className)) {\n        className = q.className;\n      }\n\n      if (className !== q.className) {\n        throw \"All queries must be for the same class\";\n      }\n    });\n    var query = new Parse.Query(className);\n    query._orQuery(queries);\n    return query;\n  };\n\n  Parse.Query.prototype = {\n    /**\n     * Constructs a Parse.Object whose id is already known by fetching data from\n     * the server.  Either options.success or options.error is called when the\n     * find completes.\n     *\n     * @param {String} objectId The id of the object to be fetched.\n     * @param {Object} options A Backbone-style options object.\n     * Valid options are:<ul>\n     *   <li>success: A Backbone-style success callback\n     *   <li>error: An Backbone-style error callback.\n     *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n     *     be used for this request.\n     *   <li>sessionToken: A valid session token, used for making a request on\n     *       behalf of a specific user.\n     * </ul>\n     */\n    get: function(objectId, options) {\n      var self = this;\n      self.equalTo('objectId', objectId);\n\n      var firstOptions = {};\n      if (options && _.has(options, 'useMasterKey')) {\n        firstOptions = { useMasterKey: options.useMasterKey };\n      }\n      if (options && _.has(options, 'sessionToken')) {\n        firstOptions.sessionToken = options.sessionToken;\n      }\n\n      return self.first(firstOptions).then(function(response) {\n        if (response) {\n          return response;\n        }\n\n        var errorObject = new Parse.Error(Parse.Error.OBJECT_NOT_FOUND,\n                                          \"Object not found.\");\n        return Parse.Promise.error(errorObject);\n\n      })._thenRunCallbacks(options, null);\n    },\n\n    /**\n     * Returns a JSON representation of this query.\n     * @return {Object} The JSON representation of the query.\n     */\n    toJSON: function() {\n      var params = {\n        where: this._where\n      };\n\n      if (this._include.length > 0) {\n        params.include = this._include.join(\",\");\n      }\n      if (this._select) {\n        params.keys = this._select.join(\",\");\n      }\n      if (this._limit >= 0) {\n        params.limit = this._limit;\n      }\n      if (this._skip > 0) {\n        params.skip = this._skip;\n      }\n      if (this._order !== undefined) {\n        params.order = this._order.join(\",\");\n      }\n\n      Parse._objectEach(this._extraOptions, function(v, k) {\n        params[k] = v;\n      });\n\n      return params;\n    },\n\n    /**\n     * Retrieves a list of ParseObjects that satisfy this query.\n     * Either options.success or options.error is called when the find\n     * completes.\n     *\n     * @param {Object} options A Backbone-style options object. Valid options\n     * are:<ul>\n     *   <li>success: Function to call when the find completes successfully.\n     *   <li>error: Function to call when the find fails.\n     *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n     *     be used for this request.\n     *   <li>sessionToken: A valid session token, used for making a request on\n     *       behalf of a specific user.\n     * </ul>\n     *\n     * @return {Parse.Promise} A promise that is resolved with the results when\n     * the query completes.\n     */\n    find: function(options) {\n      var self = this;\n      options = options || {};\n\n      var request = Parse._request({\n        route: \"classes\",\n        className: this.className,\n        method: \"GET\",\n        useMasterKey: options.useMasterKey,\n        sessionToken: options.sessionToken,\n        data: this.toJSON()\n      });\n\n      return request.then(function(response) {\n        return _.map(response.results, function(json) {\n          var obj;\n          if (response.className) {\n            obj = new Parse.Object(response.className);\n          } else {\n            obj = new self.objectClass();\n          }\n          obj._finishFetch(json, true);\n          return obj;\n        });\n      })._thenRunCallbacks(options);\n    },\n\n    /**\n     * Counts the number of objects that match this query.\n     * Either options.success or options.error is called when the count\n     * completes.\n     *\n     * @param {Object} options A Backbone-style options object. Valid options\n     * are:<ul>\n     *   <li>success: Function to call when the count completes successfully.\n     *   <li>error: Function to call when the find fails.\n     *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n     *     be used for this request.\n     *   <li>sessionToken: A valid session token, used for making a request on\n     *       behalf of a specific user.\n     * </ul>\n     *\n     * @return {Parse.Promise} A promise that is resolved with the count when\n     * the query completes.\n     */\n    count: function(options) {\n      var self = this;\n      options = options || {};\n\n      var params = this.toJSON();\n      params.limit = 0;\n      params.count = 1;\n      var request = Parse._request({\n        route: \"classes\",\n        className: self.className, \n        method: \"GET\",\n        useMasterKey: options.useMasterKey,\n        sessionToken: options.sessionToken,\n        data: params\n      });\n\n      return request.then(function(response) {\n        return response.count;\n      })._thenRunCallbacks(options);\n    },\n\n    /**\n     * Retrieves at most one Parse.Object that satisfies this query.\n     *\n     * Either options.success or options.error is called when it completes.\n     * success is passed the object if there is one. otherwise, undefined.\n     *\n     * @param {Object} options A Backbone-style options object. Valid options\n     * are:<ul>\n     *   <li>success: Function to call when the find completes successfully.\n     *   <li>error: Function to call when the find fails.\n     *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n     *     be used for this request.\n     *   <li>sessionToken: A valid session token, used for making a request on\n     *       behalf of a specific user.\n     * </ul>\n     *\n     * @return {Parse.Promise} A promise that is resolved with the object when\n     * the query completes.\n     */\n    first: function(options) {\n      var self = this;\n      options = options || {};\n\n      var params = this.toJSON();\n      params.limit = 1;\n      var request = Parse._request({\n        route: \"classes\",\n        className: this.className, \n        method: \"GET\",\n        useMasterKey: options.useMasterKey,\n        sessionToken: options.sessionToken,\n        data: params\n      });\n\n      return request.then(function(response) {\n        return _.map(response.results, function(json) {\n          var obj;\n          if (response.className) {\n            obj = new Parse.Object(response.className);\n          } else {\n            obj = new self.objectClass();\n          }\n          obj._finishFetch(json, true);\n          return obj;\n        })[0];\n      })._thenRunCallbacks(options);\n    },\n\n    /**\n     * Returns a new instance of Parse.Collection backed by this query.\n     * @param {Array} items An array of instances of <code>Parse.Object</code>\n     *     with which to start this Collection.\n     * @param {Object} options An optional object with Backbone-style options.\n     * Valid options are:<ul>\n     *   <li>model: The Parse.Object subclass that this collection contains.\n     *   <li>query: An instance of Parse.Query to use when fetching items.\n     *   <li>comparator: A string property name or function to sort by.\n     * </ul>\n     * @return {Parse.Collection}\n     */\n    collection: function(items, options) {\n      options = options || {};\n      return new Parse.Collection(items, _.extend(options, {\n        model: this.objectClass,\n        query: this\n      }));\n    },\n\n    /**\n     * Sets the number of results to skip before returning any results.\n     * This is useful for pagination.\n     * Default is to skip zero results.\n     * @param {Number} n the number of results to skip.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n    skip: function(n) {\n      this._skip = n;\n      return this;\n    },\n\n    /**\n     * Sets the limit of the number of results to return. The default limit is\n     * 100, with a maximum of 1000 results being returned at a time.\n     * @param {Number} n the number of results to limit to.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n    limit: function(n) {\n      this._limit = n;\n      return this;\n    },\n\n    /**\n     * Add a constraint to the query that requires a particular key's value to\n     * be equal to the provided value.\n     * @param {String} key The key to check.\n     * @param value The value that the Parse.Object must contain.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n    equalTo: function(key, value) {\n      if (_.isUndefined(value)) {\n        return this.doesNotExist(key);\n      } \n\n      this._where[key] = Parse._encode(value);\n      return this;\n    },\n\n    /**\n     * Helper for condition queries\n     */\n    _addCondition: function(key, condition, value) {\n      // Check if we already have a condition\n      if (!this._where[key]) {\n        this._where[key] = {};\n      }\n      this._where[key][condition] = Parse._encode(value);\n      return this;\n    },\n\n    /**\n     * Add a constraint to the query that requires a particular key's value to\n     * be not equal to the provided value.\n     * @param {String} key The key to check.\n     * @param value The value that must not be equalled.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n    notEqualTo: function(key, value) {\n      this._addCondition(key, \"$ne\", value);\n      return this;\n    },\n\n    /**\n     * Add a constraint to the query that requires a particular key's value to\n     * be less than the provided value.\n     * @param {String} key The key to check.\n     * @param value The value that provides an upper bound.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n    lessThan: function(key, value) {\n      this._addCondition(key, \"$lt\", value);\n      return this;\n    },\n\n    /**\n     * Add a constraint to the query that requires a particular key's value to\n     * be greater than the provided value.\n     * @param {String} key The key to check.\n     * @param value The value that provides an lower bound.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n    greaterThan: function(key, value) {\n      this._addCondition(key, \"$gt\", value);\n      return this;\n    },\n\n    /**\n     * Add a constraint to the query that requires a particular key's value to\n     * be less than or equal to the provided value.\n     * @param {String} key The key to check.\n     * @param value The value that provides an upper bound.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n    lessThanOrEqualTo: function(key, value) {\n      this._addCondition(key, \"$lte\", value);\n      return this;\n    },\n\n    /**\n     * Add a constraint to the query that requires a particular key's value to\n     * be greater than or equal to the provided value.\n     * @param {String} key The key to check.\n     * @param value The value that provides an lower bound.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n    greaterThanOrEqualTo: function(key, value) {\n      this._addCondition(key, \"$gte\", value);\n      return this;\n    },\n\n    /**\n     * Add a constraint to the query that requires a particular key's value to\n     * be contained in the provided list of values.\n     * @param {String} key The key to check.\n     * @param {Array} values The values that will match.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n    containedIn: function(key, values) {\n      this._addCondition(key, \"$in\", values);\n      return this;\n    },\n\n    /**\n     * Add a constraint to the query that requires a particular key's value to\n     * not be contained in the provided list of values.\n     * @param {String} key The key to check.\n     * @param {Array} values The values that will not match.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n    notContainedIn: function(key, values) {\n      this._addCondition(key, \"$nin\", values);\n      return this;\n    },\n\n    /**\n     * Add a constraint to the query that requires a particular key's value to\n     * contain each one of the provided list of values.\n     * @param {String} key The key to check.  This key's value must be an array.\n     * @param {Array} values The values that will match.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n    containsAll: function(key, values) {\n      this._addCondition(key, \"$all\", values);\n      return this;\n    },\n\n\n    /**\n     * Add a constraint for finding objects that contain the given key.\n     * @param {String} key The key that should exist.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n    exists: function(key) {\n      this._addCondition(key, \"$exists\", true);\n      return this;\n    },\n\n    /**\n     * Add a constraint for finding objects that do not contain a given key.\n     * @param {String} key The key that should not exist\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n    doesNotExist: function(key) {\n      this._addCondition(key, \"$exists\", false);\n      return this;\n    },\n\n    /**\n     * Add a regular expression constraint for finding string values that match\n     * the provided regular expression.\n     * This may be slow for large datasets.\n     * @param {String} key The key that the string to match is stored in.\n     * @param {RegExp} regex The regular expression pattern to match.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n    matches: function(key, regex, modifiers) {\n      this._addCondition(key, \"$regex\", regex);\n      if (!modifiers) { modifiers = \"\"; }\n      // Javascript regex options support mig as inline options but store them \n      // as properties of the object. We support mi & should migrate them to\n      // modifiers\n      if (regex.ignoreCase) { modifiers += 'i'; }\n      if (regex.multiline) { modifiers += 'm'; }\n\n      if (modifiers && modifiers.length) {\n        this._addCondition(key, \"$options\", modifiers);\n      }\n      return this;\n    },\n\n    /**\n     * Add a constraint that requires that a key's value matches a Parse.Query\n     * constraint.\n     * @param {String} key The key that the contains the object to match the\n     *                     query.\n     * @param {Parse.Query} query The query that should match.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n    matchesQuery: function(key, query) {\n      var queryJSON = query.toJSON();\n      queryJSON.className = query.className;\n      this._addCondition(key, \"$inQuery\", queryJSON);\n      return this;\n    },\n\n   /**\n     * Add a constraint that requires that a key's value not matches a\n     * Parse.Query constraint.\n     * @param {String} key The key that the contains the object to match the\n     *                     query.\n     * @param {Parse.Query} query The query that should not match.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n    doesNotMatchQuery: function(key, query) {\n      var queryJSON = query.toJSON();\n      queryJSON.className = query.className;\n      this._addCondition(key, \"$notInQuery\", queryJSON);\n      return this;\n    },\n\n\n    /**\n     * Add a constraint that requires that a key's value matches a value in\n     * an object returned by a different Parse.Query.\n     * @param {String} key The key that contains the value that is being\n     *                     matched.\n     * @param {String} queryKey The key in the objects returned by the query to\n     *                          match against.\n     * @param {Parse.Query} query The query to run.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n    matchesKeyInQuery: function(key, queryKey, query) {\n      var queryJSON = query.toJSON();\n      queryJSON.className = query.className;\n      this._addCondition(key, \"$select\",\n                         { key: queryKey, query: queryJSON });\n      return this;\n    },\n\n    /**\n     * Add a constraint that requires that a key's value not match a value in\n     * an object returned by a different Parse.Query.\n     * @param {String} key The key that contains the value that is being\n     *                     excluded.\n     * @param {String} queryKey The key in the objects returned by the query to\n     *                          match against.\n     * @param {Parse.Query} query The query to run.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n    doesNotMatchKeyInQuery: function(key, queryKey, query) {\n      var queryJSON = query.toJSON();\n      queryJSON.className = query.className;\n      this._addCondition(key, \"$dontSelect\",\n                         { key: queryKey, query: queryJSON });\n      return this;\n    },\n\n    /**\n     * Add constraint that at least one of the passed in queries matches.\n     * @param {Array} queries\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n    _orQuery: function(queries) {\n      var queryJSON = _.map(queries, function(q) {\n        return q.toJSON().where;\n      });\n\n      this._where.$or = queryJSON;\n      return this;\n    },\n\n    /**\n     * Converts a string into a regex that matches it.\n     * Surrounding with \\Q .. \\E does this, we just need to escape \\E's in\n     * the text separately.\n     */\n    _quote: function(s) {\n      return \"\\\\Q\" + s.replace(\"\\\\E\", \"\\\\E\\\\\\\\E\\\\Q\") + \"\\\\E\";\n    },\n\n    /**\n     * Add a constraint for finding string values that contain a provided\n     * string.  This may be slow for large datasets.\n     * @param {String} key The key that the string to match is stored in.\n     * @param {String} substring The substring that the value must contain.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n    contains: function(key, value) {\n      this._addCondition(key, \"$regex\", this._quote(value));\n      return this;\n    },\n\n    /**\n     * Add a constraint for finding string values that start with a provided\n     * string.  This query will use the backend index, so it will be fast even\n     * for large datasets.\n     * @param {String} key The key that the string to match is stored in.\n     * @param {String} prefix The substring that the value must start with.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n    startsWith: function(key, value) {\n      this._addCondition(key, \"$regex\", \"^\" + this._quote(value));\n      return this;\n    },\n\n    /**\n     * Add a constraint for finding string values that end with a provided\n     * string.  This will be slow for large datasets.\n     * @param {String} key The key that the string to match is stored in.\n     * @param {String} suffix The substring that the value must end with.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n    endsWith: function(key, value) {\n      this._addCondition(key, \"$regex\", this._quote(value) + \"$\");\n      return this;\n    },\n\n    /**\n     * Sorts the results in ascending order by the given key.\n     * \n     * @param {(String|String[]|...String} key The key to order by, which is a \n     * string of comma separated values, or an Array of keys, or multiple keys.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n    ascending: function() {\n      this._order = [];\n      return this.addAscending.apply(this, arguments);\n    },\n\n    /**\n     * Sorts the results in ascending order by the given key, \n     * but can also add secondary sort descriptors without overwriting _order.\n     * \n     * @param {(String|String[]|...String} key The key to order by, which is a\n     * string of comma separated values, or an Array of keys, or multiple keys.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n    addAscending: function(key) {\n      var self = this; \n      if (!this._order) {\n        this._order = [];\n      }\n      Parse._arrayEach(arguments, function(key) {\n        if (Array.isArray(key)) {\n          key = key.join();\n        }\n        self._order = self._order.concat(key.replace(/\\s/g, \"\").split(\",\"));\n      });\n      return this;\n    },\n\n    /**\n     * Sorts the results in descending order by the given key.\n     * \n     * @param {(String|String[]|...String} key The key to order by, which is a\n     * string of comma separated values, or an Array of keys, or multiple keys.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n    descending: function(key) {\n      this._order = [];\n      return this.addDescending.apply(this, arguments);\n    },\n\n    /**\n     * Sorts the results in descending order by the given key,\n     * but can also add secondary sort descriptors without overwriting _order.\n     * \n     * @param {(String|String[]|...String} key The key to order by, which is a\n     * string of comma separated values, or an Array of keys, or multiple keys.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n    addDescending: function(key) {\n      var self = this; \n      if (!this._order) {\n        this._order = [];\n      }\n      Parse._arrayEach(arguments, function(key) {\n        if (Array.isArray(key)) {\n          key = key.join();\n        }\n        self._order = self._order.concat(\n          _.map(key.replace(/\\s/g, \"\").split(\",\"), \n            function(k) { return \"-\" + k; }));\n      });\n      return this;\n    },\n\n    /**\n     * Add a proximity based constraint for finding objects with key point\n     * values near the point given.\n     * @param {String} key The key that the Parse.GeoPoint is stored in.\n     * @param {Parse.GeoPoint} point The reference Parse.GeoPoint that is used.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n    near: function(key, point) {\n      if (!(point instanceof Parse.GeoPoint)) {\n        // Try to cast it to a GeoPoint, so that near(\"loc\", [20,30]) works.\n        point = new Parse.GeoPoint(point);\n      }\n      this._addCondition(key, \"$nearSphere\", point);\n      return this;\n    },\n\n    /**\n     * Add a proximity based constraint for finding objects with key point\n     * values near the point given and within the maximum distance given.\n     * @param {String} key The key that the Parse.GeoPoint is stored in.\n     * @param {Parse.GeoPoint} point The reference Parse.GeoPoint that is used.\n     * @param {Number} maxDistance Maximum distance (in radians) of results to\n     *   return.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n    withinRadians: function(key, point, distance) {\n      this.near(key, point);\n      this._addCondition(key, \"$maxDistance\", distance);\n      return this;\n    },\n\n    /**\n     * Add a proximity based constraint for finding objects with key point\n     * values near the point given and within the maximum distance given.\n     * Radius of earth used is 3958.8 miles.\n     * @param {String} key The key that the Parse.GeoPoint is stored in.\n     * @param {Parse.GeoPoint} point The reference Parse.GeoPoint that is used.\n     * @param {Number} maxDistance Maximum distance (in miles) of results to\n     *     return.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n    withinMiles: function(key, point, distance) {\n      return this.withinRadians(key, point, distance / 3958.8);\n    },\n\n    /**\n     * Add a proximity based constraint for finding objects with key point\n     * values near the point given and within the maximum distance given.\n     * Radius of earth used is 6371.0 kilometers.\n     * @param {String} key The key that the Parse.GeoPoint is stored in.\n     * @param {Parse.GeoPoint} point The reference Parse.GeoPoint that is used.\n     * @param {Number} maxDistance Maximum distance (in kilometers) of results\n     *     to return.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n    withinKilometers: function(key, point, distance) {\n      return this.withinRadians(key, point, distance / 6371.0);\n    },\n\n    /**\n     * Add a constraint to the query that requires a particular key's\n     * coordinates be contained within a given rectangular geographic bounding\n     * box.\n     * @param {String} key The key to be constrained.\n     * @param {Parse.GeoPoint} southwest\n     *     The lower-left inclusive corner of the box.\n     * @param {Parse.GeoPoint} northeast\n     *     The upper-right inclusive corner of the box.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n    withinGeoBox: function(key, southwest, northeast) {\n      if (!(southwest instanceof Parse.GeoPoint)) {\n        southwest = new Parse.GeoPoint(southwest);\n      }\n      if (!(northeast instanceof Parse.GeoPoint)) {\n        northeast = new Parse.GeoPoint(northeast);\n      }\n      this._addCondition(key, '$within', { '$box': [southwest, northeast] });\n      return this;\n    },\n\n    /**\n     * Include nested Parse.Objects for the provided key.  You can use dot\n     * notation to specify which fields in the included object are also fetched.\n     * @param {String} key The name of the key to include.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n    include: function() {\n      var self = this;\n      Parse._arrayEach(arguments, function(key) {\n        if (_.isArray(key)) {\n          self._include = self._include.concat(key);\n        } else {\n          self._include.push(key);\n        }\n      });\n      return this;\n    },\n\n    /**\n     * Restrict the fields of the returned Parse.Objects to include only the\n     * provided keys.  If this is called multiple times, then all of the keys\n     * specified in each of the calls will be included.\n     * @param {Array} keys The names of the keys to include.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n    select: function() {\n      var self = this;\n      this._select = this._select || [];\n      Parse._arrayEach(arguments, function(key) {\n        if (_.isArray(key)) {\n          self._select = self._select.concat(key);\n        } else {\n          self._select.push(key);\n        }\n      });\n      return this;\n    },\n\n    /**\n     * Iterates over each result of a query, calling a callback for each one. If\n     * the callback returns a promise, the iteration will not continue until\n     * that promise has been fulfilled. If the callback returns a rejected\n     * promise, then iteration will stop with that error. The items are\n     * processed in an unspecified order. The query may not have any sort order,\n     * and may not use limit or skip.\n     * @param {Function} callback Callback that will be called with each result\n     *     of the query.\n     * @param {Object} options An optional Backbone-like options object with\n     *     success and error callbacks that will be invoked once the iteration\n     *     has finished.\n     * @return {Parse.Promise} A promise that will be fulfilled once the\n     *     iteration has completed.\n     */\n    each: function(callback, options) {\n      options = options || {};\n\n      if (this._order || this._skip || (this._limit >= 0)) {\n        var error =\n          \"Cannot iterate on a query with sort, skip, or limit.\";\n        return Parse.Promise.error(error)._thenRunCallbacks(options);\n      }\n\n      var promise = new Parse.Promise();\n\n      var query = new Parse.Query(this.objectClass);\n      // We can override the batch size from the options.\n      // This is undocumented, but useful for testing.\n      query._limit = options.batchSize || 100;\n      query._where = _.clone(this._where);\n      query._include = _.clone(this._include);\n      if (this._select) {\n        query._select = _.clone(this._select);\n      }\n\n      query.ascending('objectId');\n\n      var findOptions = {};\n      if (_.has(options, \"useMasterKey\")) {\n        findOptions.useMasterKey = options.useMasterKey;\n      }\n      if (_.has(options, 'sessionToken')) {\n        findOptions.sessionToken = options.sessionToken;\n      }\n\n      var finished = false;\n      return Parse.Promise._continueWhile(function() {\n        return !finished;\n\n      }, function() {\n        return query.find(findOptions).then(function(results) {\n          var callbacksDone = Parse.Promise.as();\n          Parse._.each(results, function(result) {\n            callbacksDone = callbacksDone.then(function() {\n              return callback(result);\n            });\n          });\n\n          return callbacksDone.then(function() {\n            if (results.length >= query._limit) {\n              query.greaterThan(\"objectId\", results[results.length - 1].id);\n            } else {\n              finished = true;\n            }\n          });\n        });\n      })._thenRunCallbacks(options);\n    }\n  };\n\n}(this));\n\n/*global FB: false , console: false*/\n(function(root) {\n  root.Parse = root.Parse || {};\n  var Parse = root.Parse;\n  var _ = Parse._;\n\n  var PUBLIC_KEY = \"*\";\n\n  var initialized = false;\n  var requestedPermissions;\n  var initOptions;\n  var provider = {\n    authenticate: function(options) {\n      var self = this;\n      FB.login(function(response) {\n        if (response.authResponse) {\n          if (options.success) {\n            options.success(self, {\n              id: response.authResponse.userID,\n              access_token: response.authResponse.accessToken,\n              expiration_date: new Date(response.authResponse.expiresIn * 1000 +\n                  (new Date()).getTime()).toJSON()\n            });\n          }\n        } else {\n          if (options.error) {\n            options.error(self, response);\n          }\n        }\n      }, {\n        scope: requestedPermissions\n      });\n    },\n    restoreAuthentication: function(authData) {\n      if (authData) {\n        var authResponse = {\n          userID: authData.id,\n          accessToken: authData.access_token,\n          expiresIn: (Parse._parseDate(authData.expiration_date).getTime() -\n              (new Date()).getTime()) / 1000\n        };\n        var newOptions = _.clone(initOptions);\n        newOptions.authResponse = authResponse;\n\n        // Suppress checks for login status from the browser.\n        newOptions.status = false;\n\n        // If the user doesn't match the one known by the FB SDK, log out.\n        // Most of the time, the users will match -- it's only in cases where\n        // the FB SDK knows of a different user than the one being restored\n        // from a Parse User that logged in with username/password.\n        var existingResponse = FB.getAuthResponse();\n        if (existingResponse &&\n            existingResponse.userID !== authResponse.userID) {\n          FB.logout();\n        }\n\n        FB.init(newOptions);\n      }\n      return true;\n    },\n    getAuthType: function() {\n      return \"facebook\";\n    },\n    deauthenticate: function() {\n      this.restoreAuthentication(null);\n    }\n  };\n\n  /**\n   * Provides a set of utilities for using Parse with Facebook.\n   * @namespace\n   * Provides a set of utilities for using Parse with Facebook.\n   */\n  Parse.FacebookUtils = {\n    /**\n     * Initializes Parse Facebook integration.  Call this function after you\n     * have loaded the Facebook Javascript SDK with the same parameters\n     * as you would pass to<code>\n     * <a href=\n     * \"https://developers.facebook.com/docs/reference/javascript/FB.init/\">\n     * FB.init()</a></code>.  Parse.FacebookUtils will invoke FB.init() for you\n     * with these arguments.\n     *\n     * @param {Object} options Facebook options argument as described here:\n     *   <a href=\n     *   \"https://developers.facebook.com/docs/reference/javascript/FB.init/\">\n     *   FB.init()</a>. The status flag will be coerced to 'false' because it\n     *   interferes with Parse Facebook integration. Call FB.getLoginStatus()\n     *   explicitly if this behavior is required by your application.\n     */\n    init: function(options) {\n      if (typeof(FB) === 'undefined') {\n        throw \"The Facebook JavaScript SDK must be loaded before calling init.\";\n      } \n      initOptions = _.clone(options) || {};\n      if (initOptions.status && typeof(console) !== \"undefined\") {\n        var warn = console.warn || console.log || function() {};\n        warn.call(console, \"The 'status' flag passed into\" +\n          \" FB.init, when set to true, can interfere with Parse Facebook\" +\n          \" integration, so it has been suppressed. Please call\" +\n          \" FB.getLoginStatus() explicitly if you require this behavior.\");\n      }\n      initOptions.status = false;\n      FB.init(initOptions);\n      Parse.User._registerAuthenticationProvider(provider);\n      initialized = true;\n    },\n\n    /**\n     * Gets whether the user has their account linked to Facebook.\n     * \n     * @param {Parse.User} user User to check for a facebook link.\n     *     The user must be logged in on this device.\n     * @return {Boolean} <code>true</code> if the user has their account\n     *     linked to Facebook.\n     */\n    isLinked: function(user) {\n      return user._isLinked(\"facebook\");\n    },\n\n    /**\n     * Logs in a user using Facebook. This method delegates to the Facebook\n     * SDK to authenticate the user, and then automatically logs in (or\n     * creates, in the case where it is a new user) a Parse.User.\n     * \n     * @param {String, Object} permissions The permissions required for Facebook\n     *    log in.  This is a comma-separated string of permissions.\n     *    Alternatively, supply a Facebook authData object as described in our\n     *    REST API docs if you want to handle getting facebook auth tokens\n     *    yourself.\n     * @param {Object} options Standard options object with success and error\n     *    callbacks.\n     */\n    logIn: function(permissions, options) {\n      if (!permissions || _.isString(permissions)) {\n        if (!initialized) {\n          throw \"You must initialize FacebookUtils before calling logIn.\";\n        }\n        requestedPermissions = permissions;\n        return Parse.User._logInWith(\"facebook\", options);\n      } else {\n        var newOptions = _.clone(options) || {};\n        newOptions.authData = permissions;\n        return Parse.User._logInWith(\"facebook\", newOptions);\n      }\n    },\n\n    /**\n     * Links Facebook to an existing PFUser. This method delegates to the\n     * Facebook SDK to authenticate the user, and then automatically links\n     * the account to the Parse.User.\n     *\n     * @param {Parse.User} user User to link to Facebook. This must be the\n     *     current user.\n     * @param {String, Object} permissions The permissions required for Facebook\n     *    log in.  This is a comma-separated string of permissions. \n     *    Alternatively, supply a Facebook authData object as described in our\n     *    REST API docs if you want to handle getting facebook auth tokens\n     *    yourself.\n     * @param {Object} options Standard options object with success and error\n     *    callbacks.\n     */\n    link: function(user, permissions, options) {\n      if (!permissions || _.isString(permissions)) {\n        if (!initialized) {\n          throw \"You must initialize FacebookUtils before calling link.\";\n        }\n        requestedPermissions = permissions;\n        return user._linkWith(\"facebook\", options);\n      } else {\n        var newOptions = _.clone(options) || {};\n        newOptions.authData = permissions;\n        return user._linkWith(\"facebook\", newOptions);\n      }\n    },\n\n    /**\n     * Unlinks the Parse.User from a Facebook account. \n     * \n     * @param {Parse.User} user User to unlink from Facebook. This must be the\n     *     current user.\n     * @param {Object} options Standard options object with success and error\n     *    callbacks.\n     */\n    unlink: function(user, options) {\n      if (!initialized) {\n        throw \"You must initialize FacebookUtils before calling unlink.\";\n      }\n      return user._unlinkFrom(\"facebook\", options);\n    }\n  };\n  \n}(this));\n\n/*global _: false, document: false, window: false, navigator: false */\n(function(root) {\n  root.Parse = root.Parse || {};\n  var Parse = root.Parse;\n  var _ = Parse._;\n\n  /**\n   * History serves as a global router (per frame) to handle hashchange\n   * events or pushState, match the appropriate route, and trigger\n   * callbacks. You shouldn't ever have to create one of these yourself\n   * — you should use the reference to <code>Parse.history</code>\n   * that will be created for you automatically if you make use of \n   * Routers with routes.\n   * @class\n   *   \n   * <p>A fork of Backbone.History, provided for your convenience.  If you \n   * use this class, you must also include jQuery, or another library \n   * that provides a jQuery-compatible $ function.  For more information,\n   * see the <a href=\"http://documentcloud.github.com/backbone/#History\">\n   * Backbone documentation</a>.</p>\n   * <p><strong><em>Available in the client SDK only.</em></strong></p>\n   */\n  Parse.History = function() {\n    this.handlers = [];\n    _.bindAll(this, 'checkUrl');\n  };\n\n  // Cached regex for cleaning leading hashes and slashes .\n  var routeStripper = /^[#\\/]/;\n\n  // Cached regex for detecting MSIE.\n  var isExplorer = /msie [\\w.]+/;\n\n  // Has the history handling already been started?\n  Parse.History.started = false;\n\n  // Set up all inheritable **Parse.History** properties and methods.\n  _.extend(Parse.History.prototype, Parse.Events,\n           /** @lends Parse.History.prototype */ {\n\n    // The default interval to poll for hash changes, if necessary, is\n    // twenty times a second.\n    interval: 50,\n\n    // Gets the true hash value. Cannot use location.hash directly due to bug\n    // in Firefox where location.hash will always be decoded.\n    getHash: function(windowOverride) {\n      var loc = windowOverride ? windowOverride.location : window.location;\n      var match = loc.href.match(/#(.*)$/);\n      return match ? match[1] : '';\n    },\n\n    // Get the cross-browser normalized URL fragment, either from the URL,\n    // the hash, or the override.\n    getFragment: function(fragment, forcePushState) {\n      if (Parse._isNullOrUndefined(fragment)) {\n        if (this._hasPushState || forcePushState) {\n          fragment = window.location.pathname;\n          var search = window.location.search;\n          if (search) {\n            fragment += search;\n          }\n        } else {\n          fragment = this.getHash();\n        }\n      }\n      if (!fragment.indexOf(this.options.root)) {\n        fragment = fragment.substr(this.options.root.length);\n      }\n      return fragment.replace(routeStripper, '');\n    },\n\n    /**\n     * Start the hash change handling, returning `true` if the current\n     * URL matches an existing route, and `false` otherwise.\n     */\n    start: function(options) {\n      if (Parse.History.started) {\n        throw new Error(\"Parse.history has already been started\");\n      }\n      Parse.History.started = true;\n\n      // Figure out the initial configuration. Do we need an iframe?\n      // Is pushState desired ... is it available?\n      this.options = _.extend({}, {root: '/'}, this.options, options);\n      this._wantsHashChange = this.options.hashChange !== false;\n      this._wantsPushState = !!this.options.pushState;\n      this._hasPushState = !!(this.options.pushState && \n                              window.history &&\n                              window.history.pushState);\n      var fragment = this.getFragment();\n      var docMode = document.documentMode;\n      var oldIE = (isExplorer.exec(navigator.userAgent.toLowerCase()) &&\n                   (!docMode || docMode <= 7));\n\n      if (oldIE) {\n        this.iframe = Parse.$('<iframe src=\"javascript:0\" tabindex=\"-1\" />')\n                      .hide().appendTo('body')[0].contentWindow;\n        this.navigate(fragment);\n      }\n\n      // Depending on whether we're using pushState or hashes, and whether\n      // 'onhashchange' is supported, determine how we check the URL state.\n      if (this._hasPushState) {\n        Parse.$(window).bind('popstate', this.checkUrl);\n      } else if (this._wantsHashChange &&\n                 ('onhashchange' in window) &&\n                 !oldIE) {\n        Parse.$(window).bind('hashchange', this.checkUrl);\n      } else if (this._wantsHashChange) {\n        this._checkUrlInterval = window.setInterval(this.checkUrl,\n                                                    this.interval);\n      }\n\n      // Determine if we need to change the base url, for a pushState link\n      // opened by a non-pushState browser.\n      this.fragment = fragment;\n      var loc = window.location;\n      var atRoot  = loc.pathname === this.options.root;\n\n      // If we've started off with a route from a `pushState`-enabled browser,\n      // but we're currently in a browser that doesn't support it...\n      if (this._wantsHashChange && \n          this._wantsPushState && \n          !this._hasPushState &&\n          !atRoot) {\n        this.fragment = this.getFragment(null, true);\n        window.location.replace(this.options.root + '#' + this.fragment);\n        // Return immediately as browser will do redirect to new url\n        return true;\n\n      // Or if we've started out with a hash-based route, but we're currently\n      // in a browser where it could be `pushState`-based instead...\n      } else if (this._wantsPushState &&\n                 this._hasPushState && \n                 atRoot &&\n                 loc.hash) {\n        this.fragment = this.getHash().replace(routeStripper, '');\n        window.history.replaceState({}, document.title,\n            loc.protocol + '//' + loc.host + this.options.root + this.fragment);\n      }\n\n      if (!this.options.silent) {\n        return this.loadUrl();\n      }\n    },\n\n    // Disable Parse.history, perhaps temporarily. Not useful in a real app,\n    // but possibly useful for unit testing Routers.\n    stop: function() {\n      Parse.$(window).unbind('popstate', this.checkUrl)\n                     .unbind('hashchange', this.checkUrl);\n      window.clearInterval(this._checkUrlInterval);\n      Parse.History.started = false;\n    },\n\n    // Add a route to be tested when the fragment changes. Routes added later\n    // may override previous routes.\n    route: function(route, callback) {\n      this.handlers.unshift({route: route, callback: callback});\n    },\n\n    // Checks the current URL to see if it has changed, and if it has,\n    // calls `loadUrl`, normalizing across the hidden iframe.\n    checkUrl: function(e) {\n      var current = this.getFragment();\n      if (current === this.fragment && this.iframe) {\n        current = this.getFragment(this.getHash(this.iframe));\n      }\n      if (current === this.fragment) {\n        return false;\n      }\n      if (this.iframe) {\n        this.navigate(current);\n      }\n      if (!this.loadUrl()) {\n        this.loadUrl(this.getHash());\n      }\n    },\n\n    // Attempt to load the current URL fragment. If a route succeeds with a\n    // match, returns `true`. If no defined routes matches the fragment,\n    // returns `false`.\n    loadUrl: function(fragmentOverride) {\n      var fragment = this.fragment = this.getFragment(fragmentOverride);\n      var matched = _.any(this.handlers, function(handler) {\n        if (handler.route.test(fragment)) {\n          handler.callback(fragment);\n          return true;\n        }\n      });\n      return matched;\n    },\n\n    // Save a fragment into the hash history, or replace the URL state if the\n    // 'replace' option is passed. You are responsible for properly URL-encoding\n    // the fragment in advance.\n    //\n    // The options object can contain `trigger: true` if you wish to have the\n    // route callback be fired (not usually desirable), or `replace: true`, if\n    // you wish to modify the current URL without adding an entry to the\n    // history.\n    navigate: function(fragment, options) {\n      if (!Parse.History.started) {\n        return false;\n      }\n      if (!options || options === true) {\n        options = {trigger: options};\n      }\n      var frag = (fragment || '').replace(routeStripper, '');\n      if (this.fragment === frag) {\n        return;\n      }\n\n      // If pushState is available, we use it to set the fragment as a real URL.\n      if (this._hasPushState) {\n        if (frag.indexOf(this.options.root) !== 0) {\n          frag = this.options.root + frag;\n        }\n        this.fragment = frag;\n        var replaceOrPush = options.replace ? 'replaceState' : 'pushState';\n        window.history[replaceOrPush]({}, document.title, frag);\n\n      // If hash changes haven't been explicitly disabled, update the hash\n      // fragment to store history.\n      } else if (this._wantsHashChange) {\n        this.fragment = frag;\n        this._updateHash(window.location, frag, options.replace);\n        if (this.iframe &&\n            (frag !== this.getFragment(this.getHash(this.iframe)))) {\n          // Opening and closing the iframe tricks IE7 and earlier\n          // to push a history entry on hash-tag change.\n          // When replace is true, we don't want this.\n          if (!options.replace) {\n            this.iframe.document.open().close();\n          }\n          this._updateHash(this.iframe.location, frag, options.replace);\n        }\n\n      // If you've told us that you explicitly don't want fallback hashchange-\n      // based history, then `navigate` becomes a page refresh.\n      } else {\n        window.location.assign(this.options.root + fragment);\n      }\n      if (options.trigger) {\n        this.loadUrl(fragment);\n      }\n    },\n\n    // Update the hash location, either replacing the current entry, or adding\n    // a new one to the browser history.\n    _updateHash: function(location, fragment, replace) {\n      if (replace) {\n        var s = location.toString().replace(/(javascript:|#).*$/, '');\n        location.replace(s + '#' + fragment);\n      } else {\n        location.hash = fragment;\n      }\n    }\n  });\n}(this));\n\n/*global _: false*/\n(function(root) {\n  root.Parse = root.Parse || {};\n  var Parse = root.Parse;\n  var _ = Parse._;\n\n  /**\n   * Routers map faux-URLs to actions, and fire events when routes are\n   * matched. Creating a new one sets its `routes` hash, if not set statically.\n   * @class\n   *\n   * <p>A fork of Backbone.Router, provided for your convenience.\n   * For more information, see the\n   * <a href=\"http://documentcloud.github.com/backbone/#Router\">Backbone\n   * documentation</a>.</p>\n   * <p><strong><em>Available in the client SDK only.</em></strong></p>\n   */\n  Parse.Router = function(options) {\n    options = options || {};\n    if (options.routes) {\n      this.routes = options.routes;\n    }\n    this._bindRoutes();\n    this.initialize.apply(this, arguments);\n  };\n\n  // Cached regular expressions for matching named param parts and splatted\n  // parts of route strings.\n  var namedParam    = /:\\w+/g;\n  var splatParam    = /\\*\\w+/g;\n  var escapeRegExp  = /[\\-\\[\\]{}()+?.,\\\\\\^\\$\\|#\\s]/g;\n\n  // Set up all inheritable **Parse.Router** properties and methods.\n  _.extend(Parse.Router.prototype, Parse.Events,\n           /** @lends Parse.Router.prototype */ {\n\n    /**\n     * Initialize is an empty function by default. Override it with your own\n     * initialization logic.\n     */\n    initialize: function(){},\n\n    /**\n     * Manually bind a single named route to a callback. For example:\n     *\n     * <pre>this.route('search/:query/p:num', 'search', function(query, num) {\n     *       ...\n     *     });</pre>\n     */\n    route: function(route, name, callback) {\n      Parse.history = Parse.history || new Parse.History();\n      if (!_.isRegExp(route)) {\n        route = this._routeToRegExp(route);\n      } \n      if (!callback) {\n        callback = this[name];\n      }\n      Parse.history.route(route, _.bind(function(fragment) {\n        var args = this._extractParameters(route, fragment);\n        if (callback) {\n          callback.apply(this, args);\n        }\n        this.trigger.apply(this, ['route:' + name].concat(args));\n        Parse.history.trigger('route', this, name, args);\n      }, this));\n      return this;\n    },\n\n    /**\n     * Whenever you reach a point in your application that you'd\n     * like to save as a URL, call navigate in order to update the\n     * URL. If you wish to also call the route function, set the \n     * trigger option to true. To update the URL without creating\n     * an entry in the browser's history, set the replace option\n     * to true.\n     */\n    navigate: function(fragment, options) {\n      Parse.history.navigate(fragment, options);\n    },\n\n    // Bind all defined routes to `Parse.history`. We have to reverse the\n    // order of the routes here to support behavior where the most general\n    // routes can be defined at the bottom of the route map.\n    _bindRoutes: function() {\n      if (!this.routes) { \n        return;\n      }\n      var routes = [];\n      for (var route in this.routes) {\n        if (this.routes.hasOwnProperty(route)) {\n          routes.unshift([route, this.routes[route]]);\n        }\n      }\n      for (var i = 0, l = routes.length; i < l; i++) {\n        this.route(routes[i][0], routes[i][1], this[routes[i][1]]);\n      }\n    },\n\n    // Convert a route string into a regular expression, suitable for matching\n    // against the current location hash.\n    _routeToRegExp: function(route) {\n      route = route.replace(escapeRegExp, '\\\\$&')\n                   .replace(namedParam, '([^\\/]+)')\n                   .replace(splatParam, '(.*?)');\n      return new RegExp('^' + route + '$');\n    },\n\n    // Given a route, and a URL fragment that it matches, return the array of\n    // extracted parameters.\n    _extractParameters: function(route, fragment) {\n      return route.exec(fragment).slice(1);\n    }\n  });\n\n  /**\n   * @function\n   * @param {Object} instanceProps Instance properties for the router.\n   * @param {Object} classProps Class properies for the router.\n   * @return {Class} A new subclass of <code>Parse.Router</code>.\n   */\n  Parse.Router.extend = Parse._extend;\n}(this));\n(function(root) {\n  root.Parse = root.Parse || {};\n  var Parse = root.Parse;\n  var _ = Parse._;\n\n  /**\n   * @namespace Contains functions for calling and declaring\n   * <a href=\"/docs/cloud_code_guide#functions\">cloud functions</a>.\n   * <p><strong><em>\n   *   Some functions are only available from Cloud Code.\n   * </em></strong></p>\n   */\n  Parse.Cloud = Parse.Cloud || {};\n\n  _.extend(Parse.Cloud, /** @lends Parse.Cloud */ {\n    /**\n     * Makes a call to a cloud function.\n     * @param {String} name The function name.\n     * @param {Object} data The parameters to send to the cloud function.\n     * @param {Object} options A Backbone-style options object\n     * options.success, if set, should be a function to handle a successful\n     * call to a cloud function.  options.error should be a function that\n     * handles an error running the cloud function.  Both functions are\n     * optional.  Both functions take a single argument.\n     * @return {Parse.Promise} A promise that will be resolved with the result\n     * of the function.\n     */\n    run: function(name, data, options) {\n      options = options || {};\n\n      var request = Parse._request({\n        route: \"functions\",\n        className: name,\n        method: 'POST',\n        useMasterKey: options.useMasterKey,\n        sessionToken: options.sessionToken,\n        data: Parse._encode(data, null, true)\n      });\n\n      return request.then(function(resp) {\n        return Parse._decode(null, resp).result;\n      })._thenRunCallbacks(options);\n    }\n  });\n}(this));\n\n(function(root) {\n  root.Parse = root.Parse || {};\n  var Parse = root.Parse;\n\n  Parse.Installation = Parse.Object.extend(\"_Installation\");\n\n  /**\n   * Contains functions to deal with Push in Parse\n   * @name Parse.Push\n   * @namespace\n   */\n  Parse.Push = Parse.Push || {};\n\n  /**\n   * Sends a push notification.\n   * @param {Object} data -  The data of the push notification.  Valid fields\n   * are:\n   *   <ol>\n   *     <li>channels - An Array of channels to push to.</li>\n   *     <li>push_time - A Date object for when to send the push.</li>\n   *     <li>expiration_time -  A Date object for when to expire\n   *         the push.</li>\n   *     <li>expiration_interval - The seconds from now to expire the push.</li>\n   *     <li>where - A Parse.Query over Parse.Installation that is used to match\n   *         a set of installations to push to.</li>\n   *     <li>data - The data to send as part of the push</li>\n   *   <ol>\n   * @param {Object} options An object that has an optional success function,\n   * that takes no arguments and will be called on a successful push, and\n   * an error function that takes a Parse.Error and will be called if the push\n   * failed.\n   * @return {Parse.Promise} A promise that is fulfilled when the push request\n   *     completes.\n   */\n  Parse.Push.send = function(data, options) {\n    options = options || {};\n\n    if (data.where) {\n      data.where = data.where.toJSON().where;\n    }\n\n    if (data.push_time) {\n      data.push_time = data.push_time.toJSON();\n    }\n\n    if (data.expiration_time) {\n      data.expiration_time = data.expiration_time.toJSON();\n    }\n\n    if (data.expiration_time && data.expiration_interval) {\n      throw \"Both expiration_time and expiration_interval can't be set\";\n    }\n\n    var request = Parse._request({\n      route: 'push',\n      method: 'POST',\n      data: data,\n      useMasterKey: options.useMasterKey\n    });\n    return request._thenRunCallbacks(options);\n  };\n}(this));\n"
../workspace/src/assets/js/app-bundle.js:	      //    if the namespace has been set globally in javascript
../workspace/src/assets/js/app-bundle.js:	      //    Options (Javascript Object): Contents of the element's data-options
../workspace/src/assets/js/app-bundle.js.map:{"version":3,"sources":["webpack:///webpack/bootstrap 003e0cdf789e12458531","webpack:///./src/assets/js/app.js","webpack:///./parse/cloud/parse-common/app-form-validator.js","webpack:///./bower_components/hw-parallax/src/hw-parallax.js","webpack:///./~/jquery/dist/jquery.js","webpack:///./~/fastclick/lib/fastclick.js","webpack:///./~/parse/build/parse-latest.js","webpack:///./~/script-loader/addScript.js","webpack:///./~/parse/build/parse-latest.js?6c84","webpack:///./bower_components/foundation/js/foundation/foundation.js","webpack:///./bower_components/foundation/js/foundation/foundation.reveal.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,wC;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;AACA,4BAA2B,6BAA6B;AACxD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAAyB,6CAA6C;AACtE,EAAC;;AAED;AACA;AACA;AACA;AACA,4BAA2B,6BAA6B;AACxD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAAyB,6CAA6C;AACtE,EAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,oDAAmD,mBAAmB;AACtE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAwC,eAAe;AACvD;AACA;AACA;;AAEA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA,EAAC,a;;;;;;ACpHD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA,G;;;;;;AC3BA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mDAAkD,4BAA4B;AAC9E,sBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mGAAkG,kBAAkB,mBAAmB,UAAU,YAAY,UAAU,WAAW,WAAW;AAC7L;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAuC,kBAAkB;AACzD,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,sBAAqB,yBAAyB;AAC9C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,oDAAmD,gBAAgB;AACnE;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,sBAAqB,gBAAgB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,8BAA8B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,8BAA8B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH,EAAC,U;;;;;;;AC3OD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;AACF;AACA;;AAEA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;;;AAIA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAE;;AAEF;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA,IAAG;AACH,GAAE;;AAEF;AACA;AACA,GAAE;;AAEF;AACA;AACA,GAAE;;AAEF;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,8BAA6B;AAC7B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,SAAQ,YAAY;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,OAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAE;;AAEF,qBAAoB;;AAEpB;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA,GAAE;;AAEF,iCAAgC;AAChC;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAW,YAAY;AACvB;;AAEA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAG;AACH;AACA,YAAW,YAAY;AACvB;;AAEA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;;AAEA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,WAAU,SAAS;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAE;;AAEF;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAS,YAAY;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAU,YAAY;AACtB;;AAEA;AACA;AACA;AACA;;AAEA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,GAAE;;AAEF;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA,EAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS,SAAS;AAClB;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA,iBAAgB,IAAI;;AAEpB;AACA;;AAEA;AACA;;AAEA;AACA,yCAAwC,IAAI;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD,UAAS;;AAET;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAI;AACJ;AACA;;AAEA;AACA,KAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,cAAa,yBAAyB;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAW,SAAS;AACpB;AACA;AACA;;AAEA;AACA;AACA,GAAE;AACF;AACA,GAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,SAAS;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAW,QAAQ;AACnB,YAAW,QAAQ;AACnB,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH,GAAE;AACF;;AAEA;AACA;AACA,YAAW,gBAAgB;AAC3B,cAAa,uBAAuB;AACpC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,YAAW,eAAe;AAC1B,cAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAW,eAAe;AAC1B,cAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAI;AACJ;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAE;AACF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,YAAW,UAAU;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,YAAW,cAAc;AACzB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;AACF;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,iCAAgC,MAAM;AACtC;AACA;AACA;AACA,GAAE;AACF;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,gBAAe;;AAEf,UAAS;;AAET;AACA,SAAQ,iCAAiC;AACzC,SAAQ,oBAAoB;AAC5B,SAAQ,sCAAsC;AAC9C,SAAQ;AACR,GAAE;;AAEF;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAI;AACJ;AACA;;AAEA;AACA,IAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAE;;AAEF;;AAEA;AACA;AACA;AACA,iBAAgB,aAAa,EAAE;AAC/B;AACA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,iEAAgE;AAChE;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,QAAO,yEAAyE;AAChF;;AAEA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA,oDAAmD;AACnD;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAG;;AAEH;AACA;AACA;AACA,kEAAiE,UAAU;AAC3E,uCAAsC,2BAA2B;AACjE;AACA,iCAAgC,MAAM;AACtC;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA,WAAU,YAAY;AACtB;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,WAAU,YAAY;AACtB;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,WAAU,UAAU;AACpB;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,WAAU,cAAc;AACxB;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;;AAEA;AACA,aAAY,uEAAuE;AACnF;AACA;AACA,aAAY,4BAA4B;AACxC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAQ,SAAS;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA,4DAA2D;AAC3D;AACA;;AAEA;AACA;AACA,QAAO;AACP;AACA;;AAEA,oCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,SAAQ,SAAS;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAQ,SAAS;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA,GAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH,SAAQ,SAAS;AACjB;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,YAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAuC,iDAAiD;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,kDAAiD;AACjD,WAAU,wCAAwC;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,gBAAgB;AAC3B;AACA,YAAW,QAAQ;AACnB,YAAW,MAAM;AACjB,YAAW,MAAM;AACjB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;AACA;AACA;AACA;AACA,GAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;AACA;AACA;AACA;AACA,GAAE;AACF;;AAEA;AACA;AACA;AACA;AACA,EAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;AACF;;AAEA;;AAEA,EAAC;;;;AAID;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;;AAEA;;;;AAIA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;;AAEA;AACA;AACA;AACA,IAAG;;AAEH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAE;AACF;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA,KAAI;AACJ;;AAEA,eAAc,SAAS;AACvB;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAE;AACF;AACA;AACA,GAAE;AACF;AACA;AACA,GAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;;AAGD;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,KAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAQ;AACR;AACA;AACA;AACA;;AAEA;;AAEA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAI;AACJ;;AAEA;AACA;AACA,KAAI;AACJ;AACA;;AAEA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA,UAAS,GAAG;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAe,SAAS;AACxB;AACA;AACA;AACA;AACA,IAAG;AACH,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,UAAS,OAAO;AAChB,wBAAuB,wBAAwB;AAC/C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAE;;AAEF;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAE;AACF;AACA;AACA,GAAE;AACF;AACA;AACA,GAAE;AACF;AACA;AACA,GAAE;AACF;AACA;AACA,GAAE;AACF;AACA;AACA,GAAE;AACF;AACA;AACA,GAAE;AACF;AACA;AACA,GAAE;AACF;AACA;AACA,GAAE;AACF;AACA,iDAAgD;AAChD,GAAE;AACF;AACA;AACA,GAAE;AACF;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAC;AACD;;;;AAIA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAE;AACF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAmB;;AAEnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAU,oCAAoC;AAC9C;AACA,qBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAQ;AACR;AACA;AACA;AACA,QAAO;AACP,OAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,SAAQ;AACR,QAAO;AACP;AACA,OAAM;AACN,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,+CAA8C;AAC9C,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAM;AACN;AACA;AACA;AACA,KAAI;;AAEJ;;AAEA,6CAA4C;AAC5C;AACA;AACA;AACA;AACA,WAAU,YAAY;AACtB;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAC;;;AAGD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,GAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA,IAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;;AAGA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,+CAA8C,SAAS,QAAQ,SAAS,MAAM;AAC9E;;AAEA;AACA;AACA;AACA;AACA;AACA,uCAAsC,SAAS,SAAS,YAAY,UAAU;;AAE9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAC;;;;;AAKD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,EAAC;;;AAGD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mDAAkD;AAClD;AACA;;;AAGA,qBAAoB,SAAS;AAC7B;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;;AAEA,IAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,kDAAiD;AACjD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,4BAA2B,IAAI;AAC/B;;AAEA,wEAAuE;AACvE;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAE;AACF;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAE;AACF;AACA;;AAEA;AACA,GAAE;AACF;AACA;AACA;;AAEA;AACA,WAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA,GAAE;;AAEF;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAI;AACJ;;AAEA;;AAEA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;;AAGD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ,IAAG;AACH;AACA,EAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAI;AACJ,GAAE;AACF;AACA;AACA;AACA,IAAG;AACH,GAAE;AACF;AACA;AACA,GAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAE;AACF;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAU,YAAY;AACtB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,EAAC;;;AAGD;AACA;AACA;;AAEA;AACA,cAAa,4CAA4C;AACzD;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAC;;;AAGD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAE,gBAAgB;AAClB;;AAEA;AACA;AACA;AACA;AACA;;AAEA,YAAW;;AAEX;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,OAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,4CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,uCAAsC;AACtC;AACA;AACA;;AAEA;AACA,0BAAyB;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,+CAA8C;AAC9C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,4CAA2C;AAC3C;;AAEA;AACA;AACA;AACA;AACA,WAAU,KAAK;AACf;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kDAAiD;AACjD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAE;;AAEF;;AAEA;AACA;;AAEA;AACA;AACA;AACA,qDAAoD;AACpD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,0BAAyB;AACzB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,+DAA8D;AAC9D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,WAAU,aAAa;AACvB;;AAEA;AACA;AACA;AACA;AACA,kBAAiB,mBAAmB;AACpC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB,+BAA+B;AACxD;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAsB,wDAAwD;AAC9E;;AAEA;AACA,GAAE;;AAEF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAE;;AAEF;AACA;;AAEA,cAAa;;AAEb;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uCAAsC,cAAc;AACpD;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAE;AACF;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,uCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAE;AACF;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA,GAAE;AACF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAE;AACF;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA,KAAI;AACJ;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA,iCAAgC;AAChC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA,2DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA,uBAAsB;AACtB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA,KAAI;AACJ,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc,qCAAqC;;AAEnD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,GAAE;AACF;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH,GAAE;AACF;AACA;AACA,GAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH,GAAE;;AAEF;AACA;AACA;AACA,IAAG;AACH,GAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;;AAGD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAE;AACF;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2DAA0D,2BAA2B;AACrF;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAQ,2BAA2B;AACnC;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,2CAA0C,OAAO;AACjD;AACA;AACA;AACA;;AAEA;AACA;AACA,mCAAkC;AAClC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,GAAE;AACF;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAE;AACF;;AAEA;AACA;AACA,GAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,gBAAe,iCAAiC;AAChD,qDAAoD;AACpD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,iBAAgB,iCAAiC;AACjD;AACA;AACA,KAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,UAAS,OAAO;AAChB;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,MAAK;AACL;;AAEA;AACA,MAAK;AACL;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,UAAS,2BAA2B;AACpC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,QAAO;AACP;;AAEA,QAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,IAAG;AACH,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,IAAG;AACH,GAAE;;AAEF;AACA;AACA;AACA;;AAEA,UAAS,2BAA2B;;AAEpC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAE;;AAEF;AACA;AACA;;AAEA,UAAS,0BAA0B;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAE;;AAEF;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH,GAAE;;AAEF;AACA;AACA,8BAA6B;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA,IAAG;AACH,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,GAAE;;AAEF;AACA;AACA,GAAE;;AAEF;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,YAAW,OAAO;AAClB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,kBAAiB,gBAAgB;AACjC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;AACA;AACA;AACA;AACA;AACA;;AAEA,UAAS,WAAW;AACpB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,EAAC;;;AAGD;AACA;;AAEA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gDAA+C,SAAS,QAAQ,SAAS,MAAM;AAC/E;;AAEA;AACA;AACA;AACA,6BAA4B,SAAS,QAAQ;AAC7C;AACA;AACA;AACA,qCAAoC,4BAA4B;AAChE,6BAA4B,cAAc,SAAS,SAAS;AAC5D,kBAAiB,UAAU;AAC3B;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,EAAC;AACD;;AAEA;;;;AAIA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;;AAEA;AACA,6CAA4C;AAC5C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAkB;;AAElB;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,8BAA6B;;AAE7B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gDAA+C,SAAS,QAAQ,SAAS,MAAM;AAC/E;;AAEA;AACA;AACA;AACA,mCAAkC,2BAA2B;AAC7D,2BAA0B,cAAc,cAAc,OAAO;AAC7D,gBAAe,YAAY,UAAU;;AAErC;AACA;AACA;AACA;;AAEA;AACA;AACA,mEAAkE;AAClE;AACA,gDAA+C,eAAe;;AAE9D;AACA;AACA;AACA;AACA;;AAEA,6BAA4B,SAAS,QAAQ,QAAQ;AACrD;AACA;AACA;AACA,qCAAoC,4BAA4B;AAChE,6BAA4B,cAAc,SAAS,SAAS;AAC5D;AACA;;AAEA;AACA,mEAAkE;;AAElE;AACA;;AAEA;AACA;AACA;AACA,gBAAe;AACf;AACA;AACA,aAAY;AACZ;AACA;AACA,2CAA0C,SAAS,UAAU;AAC7D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,EAAC;;;AAGD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,aAAY,+DAA+D;AAC3E;AACA;AACA;AACA,GAAE;;AAEF;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,SAAQ,gBAAgB;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,SAAQ,OAAO;AACf;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,+BAA8B,4BAA4B;AAC1D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;AACA;AACA;AACA,kBAAiB;;AAEjB;AACA;;AAEA,WAAU,OAAO;AACjB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA,aAAY;AACZ;;AAEA;AACA;AACA;;AAEA,YAAW,SAAS;AACpB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH,GAAE;AACF;AACA;AACA,GAAE;AACF;AACA;AACA,GAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA,IAAG;AACH;AACA,EAAC;;;AAGD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;AACF;AACA;;AAEA;AACA;AACA;AACA,GAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAE;AACF;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,GAAE;AACF;AACA;;AAEA;AACA;AACA;AACA,YAAW,eAAe;AAC1B;;AAEA;AACA;AACA;AACA,SAAQ,QAAQ;AAChB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAQ,gBAAgB;AACxB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH,+CAA8C;AAC9C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAE;AACF;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,WAAU,iBAAiB;AAC3B;AACA;;AAEA;;AAEA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,4BAA2B;AAC3B,gCAA+B,kBAAkB,EAAE;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,iBAAiB;AAC5B;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;;AAEA,SAAQ,iBAAiB;AACzB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA,UAAS,iBAAiB;AAC1B;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,EAAC;;AAED;AACA,kEAAiE;AACjE;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,oBAAmB,cAAc;AACjC,GAAE;AACF;AACA;AACA;AACA;AACA;AACA,kDAAiD;;AAEjD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAE;AACF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA,gCAA+B,SAAS;AACxC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH,GAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,gCAA+B,SAAS;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAmB,gBAAgB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA,WAAU,kBAAkB;AAC5B,YAAW,kBAAkB;AAC7B,eAAc;AACd,EAAC;AACD;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;;AAEA,SAAQ,mBAAmB;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAE;AACF;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAE;AACF;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,0DAAyD;AACzD;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAC;;;AAGD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAI;AACJ;AACA;;AAEA,kCAAiC;AACjC;AACA;AACA,KAAI;AACJ;AACA,KAAI;AACJ;AACA;AACA,MAAK;AACL;;AAEA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAW,SAAS;AACpB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAO;;AAEP;AACA;AACA;;AAEA,OAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;;;;AAKD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,KAAI;AACJ;;AAEA,KAAI;AACJ;AACA;AACA;;AAEA,IAAG;AACH;;AAEA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;;AAEA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ,wCAAuC;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;;AAEA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ,IAAG;AACH;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;;;;;AAKA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI;AACJ;;AAEA;AACA;AACA;;AAEA,WAAU,SAAS;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;;AAEA,WAAU,SAAS;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;;AAEA;AACA,KAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH,GAAE;;AAEF;AACA;AACA;AACA;AACA,UAAS,OAAO;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAC;;;;;AAKD;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA,GAAE;AACF;AACA;AACA,GAAE;;AAEF;AACA;AACA,GAAE;AACF;AACA;AACA;AACA;AACA,EAAC;;;AAGD;;AAEA;;;;AAIA,8BAA6B,IAAI,gDAAgD,EAAE;;AAEnF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,oCAAmC;AACnC;;AAEA;AACA,kCAAiC;AACjC,mCAAkC;AAClC;AACA;;AAEA;AACA;AACA,GAAE;AACF;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA2B;AAC3B;AACA;AACA,IAAG,OAAO;AACV;AACA;AACA;AACA;AACA,GAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB;;AAEhB;AACA;AACA;AACA;AACA;AACA,iBAAgB;;AAEhB,iDAAgD;AAChD;;AAEA;AACA;AACA;AACA;AACA,EAAC;AACD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oBAAmB;AACnB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wDAAuD;AACvD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA,KAAI;;AAEJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA,QAAO;AACP,gBAAe;AACf;AACA;AACA;AACA;AACA;AACA;;AAEA,UAAS;AACT;;AAEA;;AAEA;AACA;;AAEA;AACA,kBAAiB;AACjB,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAE;;AAEF;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,4BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAkC;AAClC;AACA,uBAAsB;AACtB,4BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oFAAmF;AACnF;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,eAAc,oCAAoC;AAClD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAK;AACL;;AAEA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAE;;AAEF;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;;AAGD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;AACF;;;AAGA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAI;AACJ;;AAEA;AACA,GAAE;;AAEF;AACA;AACA;AACA;AACA,KAAI;AACJ;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,KAAI;AACJ;AACA;AACA,IAAG;AACH,GAAE;;AAEF;AACA;;AAEA;AACA;AACA,IAAG;AACH,GAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;;AAGD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAI;AACJ;AACA;AACA;AACA,IAAG;;AAEH,GAAE;AACF;AACA;AACA;AACA;;AAEA,GAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH,GAAE;AACF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAE;AACF;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAc;AACd,OAAM;AACN,OAAM;AACN,IAAG;AACH;AACA,EAAC;;;AAGD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAE;AACF;AACA;;AAEA;AACA,mBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;AACF;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAQ;AACR;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;AACF;;AAEA;AACA;AACA;AACA;AACA,GAAE;AACF;;AAEA;AACA;AACA;AACA,GAAE;AACF;;;;;AAKA;AACA;AACA;AACA;AACA,GAAE;AACF;AACA;AACA,GAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;;;;AAKD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,IAAG;;AAEH;AACA;AACA;AACA,EAAC;;;;;AAKD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAE;AACF;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,IAAG;AACH;AACA,IAAG;AACH;;AAEA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA,EAAC;;;;;AAKD;AACA;AACA;AACA,GAAE;AACF;;;;;;AAMA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA,WAAU,kBAAkB;AAC5B;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;AACA;;AAEA;AACA,oBAAmB,kBAAkB;AACrC;;AAEA,6DAA4D,eAAe;AAC3E;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;;AAEF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA,eAAc,sDAAsD;AACpE;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,KAAI;AACJ;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;;AAGD;AACA,eAAc,mCAAmC;AACjD,gBAAe,6DAA6D;AAC5E;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAI;AACJ;AACA,GAAE;AACF,EAAC;;;AAGD;AACA;AACA;AACA;;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAE;AACF;;;;;AAKA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;;AAEA,EAAC;;;;;;;AC9mUD,yDAAsB;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA,aAAY,QAAQ;AACpB,aAAY,OAAO,YAAY;AAC/B;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAsB,yCAAyC;AAC/D;;;AAGA;AACA;AACA,sCAAqC,OAAO;AAC5C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY,oBAAoB;AAChC,eAAc,QAAQ;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA,aAAY,oBAAoB;AAChC,eAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,aAAY,oBAAoB;AAChC,aAAY,MAAM;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA,aAAY,oBAAoB;AAChC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;;AAGA;AACA;AACA;AACA,aAAY,oBAAoB;AAChC;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA,aAAY,YAAY;AACxB,eAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA,aAAY,MAAM;AAClB,eAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA,aAAY,MAAM;AAClB,eAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA,aAAY,MAAM;AAClB,eAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA,aAAY,6BAA6B;AACzC,eAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,aAAY,MAAM;AAClB,eAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAmB;AACnB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,aAAY,MAAM;AAClB,eAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,aAAY,MAAM;AAClB,eAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA,eAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,aAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAI;AACJ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA,aAAY,QAAQ;AACpB,aAAY,OAAO,YAAY;AAC/B;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA,IAAG;AACH,GAAE;AACF;AACA;AACA,GAAE;AACF;AACA;AACA,EAAC;;;;;;;ACx0BD,+C;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,E;;;;;;ACTA,0UAAyU,kCAAkC,qCAAqC,GAAG,QAAQ,2MAA2M,uJAAuJ,yFAAyF,uGAAuG,gKAAgK,kTAAkT,soBAAsoB,mGAAmG,uCAAuC,kDAAkD,0BAA0B,MAAM,gSAAgS,4DAA4D,qCAAqC,OAAO,oBAAoB,KAAK,OAAO,iBAAiB,KAAK,iDAAiD,iVAAiV,8BAA8B,2DAA2D,uCAAuC,OAAO,uCAAuC,uCAAuC,OAAO,OAAO,yEAAyE,SAAS,OAAO,OAAO,8BAA8B,gCAAgC,+EAA+E,WAAW,SAAS,OAAO,MAAM,gMAAgM,uBAAuB,sCAAsC,gFAAgF,8CAA8C,6EAA6E,OAAO,EAAE,qBAAqB,MAAM,sEAAsE,8OAA8O,yCAAyC,gCAAgC,wDAAwD,0DAA0D,2EAA2E,OAAO,8CAA8C,uBAAuB,uBAAuB,yBAAyB,SAAS,OAAO,kEAAkE,SAAS,OAAO,EAAE,qDAAqD,kBAAkB,MAAM,uNAAuN,yCAAyC,gCAAgC,uEAAuE,0DAA0D,qFAAqF,OAAO,8BAA8B,+BAA+B,+BAA+B,6BAA6B,OAAO,8CAA8C,iDAAiD,uBAAuB,4BAA4B,yBAAyB,SAAS,OAAO,uEAAuE,SAAS,OAAO,EAAE,qDAAqD,kBAAkB,MAAM,yIAAyI,iBAAiB,6CAA6C,yDAAyD,yBAAyB,sBAAsB,SAAS,OAAO,EAAE,oBAAoB,MAAM,mNAAmN,uBAAuB,sCAAsC,4FAA4F,8CAA8C,wFAAwF,OAAO,EAAE,qBAAqB,MAAM,+GAA+G,yDAAyD,2DAA2D,OAAO,WAAW,MAAM,qNAAqN,0CAA0C,wBAAwB,qCAAqC,wFAAwF,8CAA8C,6FAA6F,OAAO,EAAE,sBAAsB,MAAM,yOAAyO,0CAA0C,yBAAyB,qCAAqC,oFAAoF,8CAA8C,4FAA4F,OAAO,EAAE,sBAAsB,MAAM,+JAA+J,oCAAoC,2FAA2F,uCAAuC,gCAAgC,OAAO,EAAE,MAAM,8GAA8G,0CAA0C,wCAAwC,yCAAyC,oEAAoE,OAAO,EAAE,MAAM,kHAAkH,wCAAwC,mBAAmB,EAAE,EAAE,MAAM,6KAA6K,qDAAqD,gEAAgE,gCAAgC,sDAAsD,SAAS,oBAAoB,OAAO,EAAE,MAAM,0KAA0K,uCAAuC,MAAM,+OAA+O,oFAAoF,yCAAyC,OAAO,wDAAwD,oBAAoB,wCAAwC,8CAA8C,qFAAqF,kDAAkD,mCAAmC,EAAE,OAAO,EAAE,0BAA0B,MAAM,iHAAiH,oFAAoF,yCAAyC,OAAO,uDAAuD,oBAAoB,sCAAsC,8CAA8C,qFAAqF,iDAAiD,mCAAmC,EAAE,OAAO,EAAE,0BAA0B,MAAM,yDAAyD,eAAe,oBAAoB,wBAAwB,iCAAiC,iCAAiC,6CAA6C,+BAA+B,OAAO,EAAE,sBAAsB,MAAM,qGAAqG,yDAAyD,mBAAmB,GAAG,MAAM,uHAAuH,2CAA2C,8DAA8D,gBAAgB,yHAAyH,OAAO,8BAA8B,8BAA8B,+BAA+B,sBAAsB,8CAA8C,+CAA+C,SAAS,iDAAiD,OAAO,YAAY,MAAM,kIAAkI,sBAAsB,yDAAyD,wCAAwC,4DAA4D,qCAAqC,OAAO,EAAE,oBAAoB,MAAM,8LAA8L,sEAAsE,4EAA4E,OAAO,EAAE,MAAM,0NAA0N,+DAA+D,iDAAiD,sBAAsB,OAAO,EAAE,MAAM,yNAAyN,0EAA0E,8CAA8C,uCAAuC,0BAA0B,qCAAqC,gFAAgF,OAAO,iBAAiB,MAAM,iGAAiG,0BAA0B,iDAAiD,oEAAoE,2BAA2B,MAAM,gFAAgF,gCAAgC,4EAA4E,MAAM,6SAA6S,uCAAuC,wEAAwE,MAAM,qSAAqS,iFAAiF,MAAM,sMAAsM,uCAAuC,kCAAkC,gEAAgE,OAAO,OAAO,uCAAuC,OAAO,MAAM,mUAAmU,6DAA6D,MAAM,kFAAkF,yCAAyC,MAAM,uHAAuH,mCAAmC,+BAA+B,gFAAgF,SAAS,OAAO,6BAA6B,SAAS,OAAO,EAAE,oBAAoB,MAAM,qGAAqG,yCAAyC,MAAM,qHAAqH,2DAA2D,MAAM,qPAAqP,mCAAmC,2BAA2B,4BAA4B,yBAAyB,OAAO,uEAAuE,uBAAuB,oBAAoB,4CAA4C,gGAAgG,2BAA2B,qCAAqC,SAAS,OAAO,EAAE,qBAAqB,MAAM,0IAA0I,yDAAyD,MAAM,uIAAuI,0CAA0C,qDAAqD,8CAA8C,6CAA6C,SAAS,EAAE,OAAO,EAAE,MAAM,qLAAqL,oEAAoE,6CAA6C,iCAAiC,EAAE,EAAE,MAAM,mIAAmI,uCAAuC,kDAAkD,sCAAsC,qBAAqB,YAAY,OAAO,6CAA6C,OAAO,qBAAqB,MAAM,2OAA2O,kCAAkC,sBAAsB,sCAAsC,OAAO,OAAO,qBAAqB,sCAAsC,SAAS,OAAO,0CAA0C,SAAS,OAAO,oBAAoB,MAAM,mdAAmd,mCAAmC,kCAAkC,qBAAqB,0CAA0C,oEAAoE,SAAS,OAAO,yCAAyC,4CAA4C,SAAS,OAAO,iGAAiG,YAAY,OAAO,sCAAsC,gBAAgB,MAAM,4HAA4H,mCAAmC,kCAAkC,yEAAyE,kFAAkF,OAAO,+CAA+C,kDAAkD,gBAAgB,MAAM,oQAAoQ,kCAAkC,0BAA0B,kBAAkB,OAAO,+BAA+B,gEAAgE,kBAAkB,iCAAiC,0BAA0B,6BAA6B,sBAAsB,OAAO,qBAAqB,MAAM,mRAAmR,0GAA0G,0CAA0C,yBAAyB,uEAAuE,QAAQ,MAAM,2LAA2L,0CAA0C,yBAAyB,oEAAoE,QAAQ,MAAM,uKAAuK,2CAA2C,uDAAuD,+BAA+B,8BAA8B,EAAE,EAAE,iBAAiB,MAAM,sGAAsG,oBAAoB,sCAAsC,yBAAyB,gDAAgD,wFAAwF,QAAQ,MAAM,yJAAyJ,0CAA0C,mCAAmC,+BAA+B,EAAE,QAAQ,MAAM,8HAA8H,0EAA0E,MAAM,gKAAgK,yCAAyC,uBAAuB,8BAA8B,4BAA4B,uBAAuB,2CAA2C,QAAQ,yBAAyB,2BAA2B,gDAAgD,uBAAuB,yBAAyB,6BAA6B,gCAAgC,yBAAyB,yBAAyB,6CAA6C,SAAS,qBAAqB,iDAAiD,SAAS,sBAAsB,QAAQ,MAAM,6UAA6U,0BAA0B,yBAAyB,6CAA6C,gCAAgC,yBAAyB,6DAA6D,UAAU,4CAA4C,8BAA8B,0CAA0C,wDAAwD,sBAAsB,QAAQ,MAAM,uKAAuK,4BAA4B,yBAAyB,6BAA6B,mBAAmB,2CAA2C,oBAAoB,oBAAoB,QAAQ,MAAM,wOAAwO,yBAAyB,0BAA0B,oCAAoC,yCAAyC,QAAQ,MAAM,2KAA2K,4BAA4B,yBAAyB,6BAA6B,sCAAsC,QAAQ,OAAO,8CAA8C,SAAS,uBAAuB,QAAQ,MAAM,uHAAuH,oCAAoC,yBAAyB,0BAA0B,6CAA6C,SAAS,QAAQ,MAAM,2MAA2M,qEAAqE,oBAAoB,wEAAwE,kBAAkB,MAAM,qFAAqF,sBAAsB,sEAAsE,oBAAoB,MAAM,4FAA4F,qBAAqB,4EAA4E,mBAAmB,MAAM,gHAAgH,sBAAsB,uEAAuE,oBAAoB,MAAM,oJAAoJ,qBAAqB,4BAA4B,oDAAoD,OAAO,0BAA0B,MAAM,4GAA4G,uDAAuD,qBAAqB,oCAAoC,qCAAqC,WAAW,SAAS,OAAO,EAAE,iBAAiB,MAAM,4GAA4G,oBAAoB,oEAAoE,gCAAgC,6CAA6C,OAAO,EAAE,kBAAkB,MAAM,qGAAqG,oBAAoB,oEAAoE,4BAA4B,yDAAyD,OAAO,kBAAkB,MAAM,wFAAwF,uDAAuD,qBAAqB,oCAAoC,4DAA4D,WAAW,SAAS,OAAO,EAAE,iBAAiB,MAAM,uFAAuF,uCAAuC,uDAAuD,OAAO,MAAM,mQAAmQ,uBAAuB,iBAAiB,MAAM,2GAA2G,8NAA8N,uHAAuH,6EAA6E,yCAAyC,0EAA0E,sDAAsD,0BAA0B,qLAAqL,gGAAgG,sOAAsO,iUAAiU,8QAA8Q,OAAO,qEAAqE,uMAAuM,wBAAwB,gLAAgL,OAAO,qFAAqF,qBAAqB,kCAAkC,0FAA0F,wGAAwG,kCAAkC,qBAAqB,kGAAkG,wEAAwE,WAAW,SAAS,OAAO,OAAO,8KAA8K,uKAAuK,uBAAuB,SAAS,4DAA4D,8BAA8B,0EAA0E,+HAA+H,WAAW,SAAS,+FAA+F,0BAA0B,kDAAkD,WAAW,yBAAyB,SAAS,OAAO,wFAAwF,mBAAmB,oBAAoB,MAAM,qGAAqG,8BAA8B,MAAM,8IAA8I,mCAAmC,qEAAqE,6DAA6D,kBAAkB,MAAM,yEAAyE,2CAA2C,MAAM,mIAAmI,oDAAoD,MAAM,uEAAuE,iCAAiC,MAAM,0LAA0L,sCAAsC,6DAA6D,QAAQ,KAAK,EAAE,wKAAwK,qCAAqC,+CAA+C,QAAQ,KAAK,oFAAoF,oCAAoC,yCAAyC,QAAQ,KAAK,2EAA2E,sDAAsD,MAAM,qHAAqH,4CAA4C,MAAM,qEAAqE,uFAAuF,MAAM,sEAAsE,0BAA0B,MAAM,0EAA0E,4BAA4B,MAAM,wKAAwK,2CAA2C,MAAM,uOAAuO,kCAAkC,kBAAkB,MAAM,mGAAmG,mBAAmB,MAAM,kFAAkF,2BAA2B,qBAAqB,OAAO,2CAA2C,mBAAmB,MAAM,oGAAoG,wBAAwB,kBAAkB,gBAAgB,OAAO,+DAA+D,MAAM,iEAAiE,eAAe,mBAAmB,oBAAoB,oBAAoB,uBAAuB,wBAAwB,sBAAsB,QAAQ,MAAM,oDAAoD,kGAAkG,sKAAsK,uIAAuI,oCAAoC,sCAAsC,6EAA6E,0CAA0C,SAAS,EAAE,QAAQ,KAAK,EAAE,yEAAyE,uEAAuE,sCAAsC,mCAAmC,8DAA8D,MAAM,6FAA6F,4CAA4C,uCAAuC,wCAAwC,qCAAqC,sCAAsC,wDAAwD,UAAU,OAAO,EAAE,MAAM,0IAA0I,mCAAmC,gCAAgC,uCAAuC,MAAM,yKAAyK,+HAA+H,2MAA2M,sHAAsH,uKAAuK,0DAA0D,2QAA2Q,iBAAiB,8BAA8B,gCAAgC,mRAAmR,mGAAmG,8BAA8B,oFAAoF,wFAAwF,gCAAgC,EAAE,EAAE,uBAAuB,oFAAoF,SAAS,0BAA0B,+EAA+E,SAAS,uBAAuB,wBAAwB,iCAAiC,SAAS,sCAAsC,qBAAqB,OAAO,EAAE,oBAAoB,MAAM,gIAAgI,EAAE,kBAAkB,KAAK,0FAA0F,8BAA8B,qCAAqC,MAAM,aAAa,uEAAuE,OAAO,YAAY,0BAA0B,gBAAgB,OAAO,yCAAyC,qCAAqC,0CAA0C,QAAQ,4JAA4J,kBAAkB,EAAE,wBAAwB,MAAM,mGAAmG,4BAA4B,MAAM,0VAA0V,gDAAgD,MAAM,kFAAkF,mJAAmJ,oCAAoC,sCAAsC,gCAAgC,qCAAqC,qFAAqF,sCAAsC,QAAQ,KAAK,EAAE,+GAA+G,oCAAoC,sCAAsC,yEAAyE,QAAQ,KAAK,EAAE,6BAA6B,+EAA+E,2BAA2B,oBAAoB,OAAO,2FAA2F,6BAA6B,OAAO,OAAO,EAAE,KAAK,aAAa,+LAA+L,kCAAkC,0LAA0L,gEAAgE,6FAA6F,4CAA4C,KAAK,4FAA4F,kEAAkE,KAAK,sGAAsG,uFAAuF,4BAA4B,KAAK,OAAO,+BAA+B,KAAK,4GAA4G,kBAAkB,KAAK,qJAAqJ,uVAAuV,gBAAgB,4RAA4R,uCAAuC,OAAO,OAAO,iDAAiD,+BAA+B,GAAG,OAAO,6FAA6F,yKAAyK,+CAA+C,sHAAsH,oDAAoD,OAAO,kGAAkG,2CAA2C,OAAO,mGAAmG,sIAAsI,qBAAqB,MAAM,6FAA6F,wJAAwJ,2BAA2B,KAAK,qKAAqK,OAAO,wDAAwD,OAAO,wDAAwD,OAAO,6IAA6I,sBAAsB,yHAAyH,OAAO,sDAAsD,MAAM,yJAAyJ,OAAO,wDAAwD,OAAO,wDAAwD,OAAO,mHAAmH,0CAA0C,0CAA0C,kCAAkC,kCAAkC,MAAM,yFAAyF,2CAA2C,wCAAwC,4XAA4X,mCAAmC,QAAQ,KAAK,8FAA8F,OAAO,sHAAsH,OAAO,oEAAoE,iCAAiC,wEAAwE,OAAO,kBAAkB,oBAAoB,OAAO,oCAAoC,oEAAoE,OAAO,8BAA8B,iCAAiC,OAAO,6DAA6D,MAAM,+LAA+L,2CAA2C,qEAAqE,uDAAuD,OAAO,+FAA+F,6EAA6E,wCAAwC,2EAA2E,gGAAgG,qHAAqH,cAAc,8OAA8O,2EAA2E,WAAW,2DAA2D,SAAS,SAAS,MAAM,4CAA4C,gDAAgD,IAAI,SAAS,IAAI,SAAS,IAAI,8BAA8B,IAAI,SAAS,IAAI,SAAS,IAAI,wCAAwC,uCAAuC,mBAAmB,oBAAoB,OAAO,iCAAiC,sCAAsC,8BAA8B,+BAA+B,iCAAiC,iCAAiC,gCAAgC,iFAAiF,MAAM,oDAAoD,wCAAwC,qCAAqC,+BAA+B,qBAAqB,aAAa,kDAAkD,SAAS,YAAY,4BAA4B,SAAS,uBAAuB,oCAAoC,SAAS,QAAQ,gDAAgD,uEAAuE,wCAAwC,gIAAgI,WAAW,qCAAqC,QAAQ,qCAAqC,4BAA4B,qBAAqB,qBAAqB,MAAM,6CAA6C,qDAAqD,kFAAkF,oDAAoD,SAAS,oBAAoB,OAAO,mBAAmB,MAAM,+HAA+H,qBAAqB,qDAAqD,yCAAyC,4EAA4E,OAAO,0CAA0C,uBAAuB,mCAAmC,4BAA4B,6CAA6C,+CAA+C,qCAAqC,0BAA0B,qBAAqB,aAAa,2BAA2B,0DAA0D,2BAA2B,mBAAmB,wDAAwD,eAAe,YAAY,kCAAkC,eAAe,6BAA6B,2DAA2D,eAAe,aAAa,8BAA8B,mDAAmD,oKAAoK,4CAA4C,eAAe,OAAO,4EAA4E,eAAe,aAAa,OAAO,kCAAkC,aAAa,WAAW,UAAU,sCAAsC,2DAA2D,kDAAkD,2PAA2P,SAAS,uBAAuB,QAAQ,mBAAmB,gDAAgD,OAAO,kGAAkG,yDAAyD,iCAAiC,mBAAmB,MAAM,8XAA8X,gCAAgC,wCAAwC,sCAAsC,kCAAkC,8CAA8C,8CAA8C,oCAAoC,mCAAmC,8EAA8E,OAAO,uDAAuD,iEAAiE,OAAO,8mBAA8mB,gDAAgD,OAAO,kCAAkC,iDAAiD,qBAAqB,OAAO,4BAA4B,sBAAsB,iCAAiC,OAAO,qBAAqB,gCAAgC,OAAO,mDAAmD,EAAE,gCAAgC,oCAAoC,0BAA0B,OAAO,gDAAgD,2CAA2C,OAAO,wDAAwD,0BAA0B,wDAAwD,OAAO,6BAA6B,gFAAgF,OAAO,OAAO,gDAAgD,OAAO,kDAAkD,8DAA8D,yCAAyC,6BAA6B,mCAAmC,8BAA8B,EAAE,SAAS,+CAA+C,wCAAwC,SAAS,4CAA4C,OAAO,8BAA8B,uDAAuD,+DAA+D,SAAS,sDAAsD,6CAA6C,SAAS,gDAAgD,gDAAgD,OAAO,iCAAiC,uIAAuI,gDAAgD,eAAe,8DAA8D,qEAAqE,WAAW,YAAY,6PAA6P,WAAW,SAAS,OAAO,oJAAoJ,SAAS,qKAAqK,OAAO,EAAE,MAAM,kJAAkJ,sCAAsC,oBAAoB,OAAO,8EAA8E,MAAM,+kBAA+kB,sBAAsB,0CAA0C,8BAA8B,mDAAmD,SAAS,+EAA+E,oCAAoC,SAAS,6BAA6B,kDAAkD,yJAAyJ,SAAS,mFAAmF,OAAO,uCAAuC,8BAA8B,OAAO,4BAA4B,2BAA2B,wDAAwD,SAAS,gBAAgB,iDAAiD,OAAO,4CAA4C,8BAA8B,OAAO,6BAA6B,yCAAyC,gEAAgE,SAAS,EAAE,OAAO,8BAA8B,4BAA4B,OAAO,4CAA4C,8BAA8B,OAAO,sCAAsC,8BAA8B,OAAO,wCAAwC,2BAA2B,wEAAwE,SAAS,gBAAgB,4FAA4F,OAAO,8BAA8B,wBAAwB,iDAAiD,qEAAqE,SAAS,EAAE,sBAAsB,OAAO,mBAAmB,MAAM,iJAAiJ,sBAAsB,+BAA+B,qBAAqB,OAAO,6BAA6B,gDAAgD,yCAAyC,SAAS,EAAE,qBAAqB,OAAO,0CAA0C,qBAAqB,OAAO,wCAAwC,qBAAqB,OAAO,sCAAsC,qBAAqB,OAAO,uBAAuB,uCAAuC,OAAO,4DAA4D,4DAA4D,8BAA8B,2BAA2B,SAAS,uBAAuB,OAAO,2DAA2D,6FAA6F,4BAA4B,+BAA+B,qDAAqD,yCAAyC,sBAAsB,OAAO,sCAAsC,2CAA2C,OAAO,0CAA0C,mCAAmC,gFAAgF,EAAE,OAAO,4BAA4B,yCAAyC,uBAAuB,SAAS,oCAAoC,OAAO,0CAA0C,qDAAqD,mDAAmD,wBAAwB,OAAO,sCAAsC,8CAA8C,8BAA8B,oBAAoB,OAAO,+CAA+C,uCAAuC,OAAO,EAAE,mBAAmB,MAAM,sCAAsC,wGAAwG,OAAO,8DAA8D,SAAS,mNAAmN,sHAAsH,2CAA2C,0BAA0B,iDAAiD,6EAA6E,SAAS,0BAA0B,uDAAuD,4BAA4B,OAAO,6EAA6E,mKAAmK,OAAO,oCAAoC,qDAAqD,4DAA4D,yBAAyB,qCAAqC,WAAW,SAAS,EAAE,4BAA4B,OAAO,qCAAqC,kDAAkD,4DAA4D,yBAAyB,mCAAmC,WAAW,SAAS,EAAE,4BAA4B,OAAO,0BAA0B,MAAM,+OAA+O,sBAAsB,4BAA4B,2CAA2C,kCAAkC,SAAS,EAAE,OAAO,OAAO,8BAA8B,OAAO,MAAM,gGAAgG,yDAAyD,MAAM,GAAG,QAAQ,uEAAuE,kCAAkC,2BAA2B,uBAAuB,yBAAyB,kEAAkE,0BAA0B,WAAW,gDAAgD,6CAA6C,OAAO,WAAW,gCAAgC,OAAO,KAAK,0BAA0B,wCAAwC,0CAA0C,QAAQ,iDAAiD,iDAAiD,QAAQ,6CAA6C,6CAA6C,QAAQ,oCAAoC,oCAAoC,QAAQ,KAAK,0CAA0C,uBAAuB,WAAW,yDAAyD,qDAAqD,iDAAiD,sCAAsC,2DAA2D,sBAAsB,4BAA4B,aAAa,OAAO,+BAA+B,aAAa,WAAW,EAAE,mBAAmB,UAAU,wDAAwD,sCAAsC,2DAA2D,sBAAsB,4BAA4B,aAAa,OAAO,+BAA+B,aAAa,WAAW,EAAE,mBAAmB,UAAU,oDAAoD,sCAAsC,uDAAuD,sBAAsB,4BAA4B,aAAa,OAAO,0BAA0B,aAAa,WAAW,EAAE,mBAAmB,UAAU,sCAAsC,+BAA+B,UAAU,OAAO,YAAY,EAAE,KAAK,6CAA6C,4CAA4C,wCAAwC,0CAA0C,8BAA8B,SAAS,oBAAoB,QAAQ,iDAAiD,qCAAqC,QAAQ,6CAA6C,4BAA4B,QAAQ,oCAAoC,iCAAiC,2CAA2C,+BAA+B,WAAW,SAAS,QAAQ,KAAK,yGAAyG,6CAA6C,yEAAyE,QAAQ,sDAAsD,qCAAqC,uCAAuC,QAAQ,kDAAkD,4EAA4E,QAAQ,KAAK,8BAA8B,KAAK,QAAQ,qBAAqB,kCAAkC,2BAA2B,oBAAoB,6IAA6I,+DAA+D,wTAAwT,aAAa,oLAAoL,qFAAqF,qDAAqD,oHAAoH,OAAO,kGAAkG,OAAO,kGAAkG,OAAO,4DAA4D,cAAc,2IAA2I,0BAA0B,yCAAyC,yCAAyC,gCAAgC,+DAA+D,SAAS,iDAAiD,qDAAqD,mFAAmF,WAAW,SAAS,EAAE,kCAAkC,+BAA+B,8FAA8F,yBAAyB,SAAS,6BAA6B,OAAO,KAAK,EAAE,GAAG,QAAQ,qBAAqB,kCAAkC,2BAA2B,oBAAoB,yKAAyK,2BAA2B,mCAAmC,MAAM,4JAA4J,aAAa,yIAAyI,wCAAwC,2CAA2C,OAAO,wCAAwC,kCAAkC,sBAAsB,OAAO,kHAAkH,yBAAyB,sDAAsD,6CAA6C,OAAO,oBAAoB,MAAM,+EAA+E,OAAO,qOAAqO,cAAc,wJAAwJ,8BAA8B,sCAAsC,yDAAyD,EAAE,gDAAgD,4CAA4C,gIAAgI,kDAAkD,SAAS,0CAA0C,sCAAsC,6CAA6C,sBAAsB,OAAO,6BAA6B,MAAM,gCAAgC,uGAAuG,iDAAiD,mBAAmB,sBAAsB,SAAS,wCAAwC,oBAAoB,4CAA4C,uBAAuB,SAAS,OAAO,6CAA6C,SAAS,gDAAgD,uBAAuB,OAAO,qEAAqE,OAAO,mEAAmE,qCAAqC,OAAO,6CAA6C,0EAA0E,mCAAmC,2NAA2N,SAAS,OAAO,MAAM,yCAAyC,2DAA2D,KAAK,QAAQ,uBAAuB,kCAAkC,2BAA2B,oBAAoB,mGAAmG,OAAO,0EAA0E,OAAO,qLAAqL,uBAAuB,6BAA6B,MAAM,uDAAuD,ovRAAovR,EAAE,KAAK,QAAQ,uCAAuC,oBAAoB,+CAA+C,GAAG,+BAA+B,sCAAsC,qdAAqd,0CAA0C,0CAA0C,mBAAmB,EAAE,EAAE,oCAAoC,2LAA2L,4NAA4N,6CAA6C,wBAAwB,sBAAsB,SAAS,6CAA6C,wDAAwD,EAAE,kNAAkN,uBAAuB,8BAA8B,uCAAuC,gCAAgC,iCAAiC,mCAAmC,0BAA0B,2CAA2C,iCAAiC,SAAS,sBAAsB,OAAO,wTAAwT,8CAA8C,0FAA0F,iBAAiB,SAAS,+CAA+C,iCAAiC,sBAAsB,SAAS,gNAAgN,+BAA+B,uBAAuB,8BAA8B,8BAA8B,gDAAgD,mCAAmC,qBAAqB,WAAW,4FAA4F,2BAA2B,iCAAiC,+BAA+B,+BAA+B,gFAAgF,sCAAsC,aAAa,6BAA6B,WAAW,iCAAiC,SAAS,sBAAsB,OAAO,qWAAqW,sDAAsD,yCAAyC,sBAAsB,SAAS,wBAAwB,6CAA6C,wCAAwC,2LAA2L,uBAAuB,8BAA8B,qBAAqB,6BAA6B,iDAAiD,8DAA8D,aAAa,WAAW,qBAAqB,qBAAqB,6BAA6B,wCAAwC,iDAAiD,8DAA8D,aAAa,WAAW,iCAAiC,SAAS,sBAAsB,OAAO,MAAM,0EAA0E,2EAA2E,GAAG,aAAa,qDAAqD,kCAAkC,2BAA2B,oBAAoB,gNAAgN,4BAA4B,wbAAwb,wDAAwD,yCAAyC,uBAAuB,4DAA4D,4BAA4B,mDAAmD,gCAAgC,iCAAiC,OAAO,6BAA6B,gEAAgE,sCAAsC,wCAAwC,OAAO,iDAAiD,6CAA6C,6BAA6B,8BAA8B,OAAO,OAAO,0BAA0B,2BAA2B,OAAO,kKAAkK,2DAA2D,8KAA8K,yCAAyC,wDAAwD,gCAAgC,SAAS,EAAE,yDAAyD,iCAAiC,SAAS,EAAE,2DAA2D,wDAAwD,+BAA+B,SAAS,EAAE,4DAA4D,uDAAuD,gCAAgC,SAAS,EAAE,OAAO,MAAM,iEAAiE,MAAM,4JAA4J,MAAM,qRAAqR,6BAA6B,sEAAsE,OAAO,4BAA4B,qEAAqE,OAAO,+BAA+B,yEAAyE,OAAO,8BAA8B,wEAAwE,OAAO,MAAM,kLAAkL,OAAO,2GAA2G,wCAAwC,mEAAmE,4CAA4C,oGAAoG,GAAG,SAAS,mBAAmB,8BAA8B,OAAO,EAAE,kDAAkD,MAAM,kCAAkC,sGAAsG,OAAO,mCAAmC,gEAAgE,gBAAgB,kHAAkH,OAAO,oGAAoG,eAAe,kDAAkD,OAAO,2CAA2C,kCAAkC,0CAA0C,4CAA4C,2CAA2C,6CAA6C,yCAAyC,4CAA4C,qDAAqD,uDAAuD,sPAAsP,6BAA6B,2CAA2C,OAAO,uGAAuG,eAAe,kDAAkD,OAAO,8CAA8C,8CAA8C,OAAO,kGAAkG,eAAe,kDAAkD,OAAO,yCAAyC,8CAA8C,OAAO,MAAM,GAAG,QAAQ,mDAAmD,kCAAkC,2BAA2B,oBAAoB,6BAA6B,4lBAA4lB,sBAAsB,gCAAgC,6BAA6B,yCAAyC,yCAAyC,0CAA0C,SAAS,OAAO,mCAAmC,8EAA8E,WAAW,gEAAgE,sCAAsC,uEAAuE,aAAa,8CAA8C,yEAAyE,wEAAwE,kFAAkF,eAAe,0CAA0C,mFAAmF,eAAe,iEAAiE,aAAa,EAAE,WAAW,EAAE,SAAS,OAAO,MAAM,0EAA0E,OAAO,oDAAoD,2CAA2C,MAAM,8EAA8E,yCAAyC,2BAA2B,OAAO,yCAAyC,8CAA8C,OAAO,gCAAgC,2CAA2C,OAAO,kCAAkC,wDAAwD,OAAO,qDAAqD,yBAAyB,uBAAuB,iGAAiG,SAAS,OAAO,2BAA2B,qDAAqD,SAAS,OAAO,sBAAsB,wDAAwD,OAAO,OAAO,uCAAuC,qCAAqC,qCAAqC,SAAS,OAAO,MAAM,qEAAqE,yCAAyC,2BAA2B,OAAO,yCAAyC,8CAA8C,OAAO,qDAAqD,yBAAyB,qBAAqB,OAAO,oDAAoD,MAAM,wJAAwJ,QAAQ,6HAA6H,iDAAiD,MAAM,yWAAyW,QAAQ,iEAAiE,+CAA+C,MAAM,8KAA8K,QAAQ,+HAA+H,kDAAkD,MAAM,0WAA0W,QAAQ,kEAAkE,gDAAgD,MAAM,qFAAqF,QAAQ,gFAAgF,8CAA8C,MAAM,sFAAsF,QAAQ,iEAAiE,4CAA4C,MAAM,sFAAsF,QAAQ,iFAAiF,+CAA+C,MAAM,uFAAuF,QAAQ,kEAAkE,6CAA6C,MAAM,wSAAwS,QAAQ,mEAAmE,OAAO,iHAAiH,uCAAuC,qEAAqE,OAAO,6BAA6B,oDAAoD,OAAO,sDAAsD,MAAM,0SAA0S,QAAQ,oEAAoE,OAAO,kHAAkH,uCAAuC,qEAAqE,OAAO,6BAA6B,qDAAqD,OAAO,sDAAsD,MAAM,4LAA4L,QAAQ,qEAAqE,OAAO,0HAA0H,uCAAuC,qEAAqE,OAAO,6BAA6B,sDAAsD,eAAe,OAAO,sDAAsD,MAAM,6LAA6L,QAAQ,sEAAsE,OAAO,2HAA2H,uCAAuC,qEAAqE,OAAO,6BAA6B,uDAAuD,eAAe,OAAO,sDAAsD,MAAM,KAAK,QAAQ,qBAAqB,kCAAkC,2BAA2B,oBAAoB,mlBAAmlB,8CAA8C,MAAM,4BAA4B,gCAAgC,MAAM,0BAA0B,8DAA8D,iHAAiH,qMAAqM,iDAAiD,OAAO,+HAA+H,wDAAwD,sBAAsB,+BAA+B,SAAS,OAAO,2BAA2B,SAAS,OAAO,KAAK,EAAE,2GAA2G,oBAAoB,mDAAmD,0CAA0C,2CAA2C,OAAO,EAAE,gBAAgB,KAAK,EAAE,8QAA8Q,oCAAoC,4BAA4B,OAAO,yGAAyG,2BAA2B,OAAO,6GAA6G,OAAO,mCAAmC,2CAA2C,OAAO,iDAAiD,oBAAoB,OAAO,wCAAwC,4BAA4B,OAAO,KAAK,EAAE,uPAAuP,sMAAsM,0GAA0G,OAAO,mCAAmC,gBAAgB,oBAAoB,OAAO,iDAAiD,oBAAoB,OAAO,wCAAwC,+BAA+B,OAAO,KAAK,EAAE,4DAA4D,kCAAkC,KAAK,EAAE,sPAAsP,uCAAuC,8BAA8B,OAAO,0EAA0E,OAAO,+DAA+D,4BAA4B,OAAO,6GAA6G,OAAO,mCAAmC,gBAAgB,6CAA6C,OAAO,iDAAiD,wBAAwB,sBAAsB,SAAS,+CAA+C,iDAAiD,SAAS,6CAA6C,oEAAoE,SAAS,mDAAmD,2EAA2E,SAAS,OAAO,qDAAqD,SAAS,OAAO,wCAAwC,wBAAwB,+BAA+B,SAAS,wCAAwC,OAAO,KAAK,EAAE,+DAA+D,iDAAiD,KAAK,EAAE,kOAAkO,sCAAsC,gCAAgC,OAAO,oFAAoF,MAAM,0EAA0E,6BAA6B,OAAO,6GAA6G,OAAO,mCAAmC,gBAAgB,yDAAyD,OAAO,iDAAiD,wBAAwB,sBAAsB,SAAS,+CAA+C,kDAAkD,SAAS,6CAA6C,oEAAoE,SAAS,6CAA6C,6EAA6E,SAAS,OAAO,qDAAqD,SAAS,OAAO,wCAAwC,wBAAwB,yCAAyC,SAAS,OAAO,iDAAiD,SAAS,OAAO,KAAK,EAAE,yDAAyD,sEAAsE,KAAK,EAAE,mTAAmT,wCAAwC,wCAAwC,OAAO,oFAAoF,MAAM,0EAA0E,6BAA6B,OAAO,6GAA6G,OAAO,mCAAmC,gBAAgB,+DAA+D,OAAO,iDAAiD,wBAAwB,sBAAsB,SAAS,+CAA+C,kDAAkD,SAAS,6CAA6C,oEAAoE,SAAS,mDAAmD,4EAA4E,SAAS,OAAO,qDAAqD,SAAS,OAAO,wCAAwC,wBAAwB,yCAAyC,SAAS,OAAO,0PAA0P,0DAA0D,wDAAwD,kEAAkE,gFAAgF,eAAe,EAAE,iCAAiC,mCAAmC,eAAe,OAAO,6DAA6D,sCAAsC,eAAe,aAAa,uCAAuC,iCAAiC,aAAa,WAAW,EAAE,0BAA0B,SAAS,OAAO,KAAK,EAAE,+DAA+D,4EAA4E,KAAK,EAAE,4OAA4O,sCAAsC,wCAAwC,OAAO,wFAAwF,MAAM,8EAA8E,6BAA6B,OAAO,6GAA6G,OAAO,mCAAmC,gBAAgB,4DAA4D,OAAO,iDAAiD,wBAAwB,sBAAsB,SAAS,+CAA+C,0BAA0B,SAAS,6CAA6C,oEAAoE,SAAS,gDAAgD,kFAAkF,SAAS,OAAO,qDAAqD,SAAS,OAAO,wCAAwC,wBAAwB,oBAAoB,SAAS,OAAO,gEAAgE,wIAAwI,wDAAwD,6DAA6D,gFAAgF,eAAe,EAAE,aAAa,WAAW,EAAE,0BAA0B,SAAS,OAAO,KAAK,EAAE,4DAA4D,yEAAyE,KAAK,EAAE,2RAA2R,8CAA8C,qCAAqC,0BAA0B,8CAA8C,+CAA+C,6BAA6B,6EAA6E,aAAa,yCAAyC,uDAAuD,aAAa,6DAA6D,oKAAoK,aAAa,6BAA6B,WAAW,wBAAwB,UAAU,iEAAiE,qEAAqE,OAAO,+HAA+H,MAAM,kCAAkC,wBAAwB,8DAA8D,mEAAmE,+BAA+B,wBAAwB,SAAS,EAAE,OAAO,mIAAmI,MAAM,oCAAoC,wBAAwB,iEAAiE,mEAAmE,+BAA+B,wBAAwB,SAAS,EAAE,OAAO,6GAA6G,OAAO,mCAAmC,wBAAwB,2BAA2B,wBAAwB,wCAAwC,kBAAkB,yGAAyG,UAAU,4BAA4B,6CAA6C,6DAA6D,kBAAkB,oDAAoD,SAAS,kDAAkD,gEAAgE,qBAAqB,uDAAuD,SAAS,gCAAgC,kBAAkB,gDAAgD,SAAS,uCAAuC,OAAO,iDAAiD,wBAAwB,sBAAsB,SAAS,+CAA+C,mEAAmE,SAAS,kDAAkD,8GAA8G,6JAA6J,WAAW,4LAA4L,wMAAwM,uEAAuE,+DAA+D,6BAA6B,SAAS,OAAO,qDAAqD,SAAS,OAAO,qDAAqD,wBAAwB,yDAAyD,2DAA2D,SAAS,+CAA+C,sCAAsC,2CAA2C,uEAAuE,+JAA+J,eAAe,aAAa,OAAO,+DAA+D,aAAa,WAAW,0BAA0B,SAAS,OAAO,qDAAqD,SAAS,OAAO,KAAK,EAAE,iEAAiE,+EAA+E,KAAK,EAAE,kEAAkE,+EAA+E,KAAK,EAAE,KAAK,QAAQ,qBAAqB,kCAAkC,2BAA2B,oBAAoB,oMAAoM,aAAa,mDAAmD,OAAO,sWAAsW,2BAA2B,qBAAqB,kCAAkC,MAAM,kCAAkC,wIAAwI,4CAA4C,mCAAmC,qCAAqC,mFAAmF,SAAS,+BAA+B,gFAAgF,SAAS,OAAO,wGAAwG,yEAAyE,kCAAkC,8BAA8B,SAAS,0DAA0D,0CAA0C,uDAAuD,OAAO,8GAA8G,+EAA+E,kCAAkC,8BAA8B,SAAS,0DAA0D,0CAA0C,uDAAuD,OAAO,wGAAwG,OAAO,mCAAmC,gBAAgB,iEAAiE,OAAO,iHAAiH,YAAY,kCAAkC,wBAAwB,kBAAkB,oCAAoC,yEAAyE,+CAA+C,iEAAiE,SAAS,OAAO,wEAAwE,+CAA+C,SAAS,kFAAkF,+DAA+D,uBAAuB,OAAO,MAAM,GAAG,QAAQ,gEAAgE,kCAAkC,2BAA2B,oBAAoB,0OAA0O,6CAA6C,0CAA0C,WAAW,yBAAyB,kDAAkD,WAAW,EAAE,mHAAmH,6BAA6B,6BAA6B,mCAAmC,mCAAmC,MAAM,2DAA2D,+IAA+I,QAAQ,sCAAsC,qEAAqE,OAAO,iGAAiG,cAAc,gDAAgD,0CAA0C,kDAAkD,uBAAuB,OAAO,iGAAiG,cAAc,mDAAmD,0CAA0C,iDAAiD,uBAAuB,OAAO,0ZAA0Z,wCAAwC,wCAAwC,6EAA6E,6BAA6B,0CAA0C,0CAA0C,yBAAyB,EAAE,yHAAyH,mEAAmE,6BAA6B,0CAA0C,0CAA0C,yBAAyB,EAAE,gCAAgC,MAAM,2DAA2D,cAAc,0DAA0D,mGAAmG,oEAAoE,8BAA8B,SAAS,OAAO,6BAA6B,SAAS,qCAAqC,6BAA6B,yBAAyB,wBAAwB,wCAAwC,uCAAuC,4BAA4B,uDAAuD,SAAS,4CAA4C,uCAAuC,4BAA4B,4BAA4B,2BAA2B,qCAAqC,aAAa,OAAO,sDAAsD,aAAa,WAAW,UAAU,yDAAyD,yCAAyC,0CAA0C,kCAAkC,2BAA2B,aAAa,mBAAmB,gCAAgC,8BAA8B,2BAA2B,aAAa,EAAE,WAAW,OAAO,gCAAgC,yBAAyB,WAAW,SAAS,EAAE,yBAAyB,OAAO,qNAAqN,SAAS,mEAAmE,SAAS,0GAA0G,0BAA0B,kDAAkD,0EAA0E,WAAW,EAAE,SAAS,kCAAkC,OAAO,KAAK,EAAE,+EAA+E,yGAAyG,OAAO,sFAAsF,+CAA+C,gJAAgJ,SAAS,8BAA8B,iCAAiC,gCAAgC,8EAA8E,gDAAgD,SAAS,EAAE,qCAAqC,qCAAqC,OAAO,0GAA0G,OAAO,kFAAkF,+CAA+C,gJAAgJ,SAAS,8BAA8B,4BAA4B,8EAA8E,kCAAkC,SAAS,EAAE,qCAAqC,qCAAqC,OAAO,yXAAyX,SAAS,sMAAsM,SAAS,mXAAmX,cAAc,kSAAkS,0CAA0C,oDAAoD,iCAAiC,iCAAiC,0DAA0D,mBAAmB,gEAAgE,eAAe,YAAY,kDAAkD,eAAe,aAAa,OAAO,8DAA8D,aAAa,WAAW,mEAAmE,uCAAuC,wDAAwD,aAAa,mBAAmB,oCAAoC,aAAa,EAAE,WAAW,OAAO,mDAAmD,WAAW,UAAU,yDAAyD,0BAA0B,iCAAiC,0DAA0D,mBAAmB,mDAAmD,eAAe,YAAY,kDAAkD,eAAe,aAAa,OAAO,iDAAiD,aAAa,qEAAqE,yCAAyC,0DAA0D,eAAe,mBAAmB,sCAAsC,eAAe,EAAE,aAAa,OAAO,4DAA4D,uDAAuD,eAAe,OAAO,0CAA0C,eAAe,aAAa,WAAW,OAAO,kCAAkC,WAAW,UAAU,yCAAyC,sBAAsB,UAAU,sDAAsD,oEAAoE,uCAAuC,yCAAyC,cAAc,WAAW,gEAAgE,uCAAuC,qCAAqC,cAAc,WAAW,SAAS,0BAA0B,6BAA6B,+BAA+B,8DAA8D,WAAW,EAAE,SAAS,2BAA2B,+BAA+B,iDAAiD,WAAW,EAAE,SAAS,OAAO,gEAAgE,gEAAgE,SAAS,yBAAyB,OAAO,kJAAkJ,6CAA6C,OAAO,2HAA2H,mCAAmC,OAAO,2HAA2H,yCAAyC,OAAO,iHAAiH,mOAAmO,qIAAqI,cAAc,yKAAyK,oBAAoB,8CAA8C,2CAA2C,qBAAqB,uCAAuC,qCAAqC,aAAa,qCAAqC,oCAAoC,aAAa,YAAY,SAAS,OAAO,+CAA+C,SAAS,gCAAgC,6CAA6C,gCAAgC,mDAAmD,WAAW,kBAAkB,oIAAoI,WAAW,kEAAkE,SAAS,mBAAmB,8BAA8B,wCAAwC,0CAA0C,aAAa,OAAO,mCAAmC,aAAa,WAAW,kBAAkB,4IAA4I,WAAW,2KAA2K,SAAS,EAAE,OAAO,+XAA+X,SAAS,iFAAiF,qCAAqC,+CAA+C,SAAS,mBAAmB,2CAA2C,SAAS,EAAE,OAAO,OAAO,EAAE,KAAK,QAAQ,wFAAwF,kCAAkC,2BAA2B,oBAAoB,uCAAuC,wBAAwB,gDAAgD,OAAO,wBAAwB,uDAAuD,OAAO,wBAAwB,uDAAuD,OAAO,0BAA0B,qBAAqB,OAAO,0BAA0B,qBAAqB,OAAO,wEAAwE,MAAM,0CAA0C,sBAAsB,kDAAkD,0CAA0C,8BAA8B,uCAAuC,uCAAuC,gDAAgD,8CAA8C,oQAAoQ,OAAO,EAAE,+BAA+B,MAAM,oEAAoE,KAAK,sCAAsC,OAAO,0DAA0D,cAAc,wJAAwJ,wCAAwC,mDAAmD,sKAAsK,OAAO,sCAAsC,qCAAqC,sCAAsC,2HAA2H,iBAAiB,SAAS,sCAAsC,iCAAiC,IAAI,4BAA4B,uBAAuB,gJAAgJ,iBAAiB,SAAS,0DAA0D,QAAQ,iCAAiC,qBAAqB,MAAM,yIAAyI,OAAO,wRAAwR,MAAM,gHAAgH,kBAAkB,iRAAiR,gDAAgD,+CAA+C,kCAAkC,oDAAoD,2CAA2C,yDAAyD,mBAAmB,0FAA0F,EAAE,QAAQ,0BAA0B,OAAO,2MAA2M,wBAAwB,kHAAkH,sBAAsB,+CAA+C,OAAO,qCAAqC,8BAA8B,2EAA2E,OAAO,gCAAgC,wKAAwK,gDAAgD,qFAAqF,4CAA4C,+LAA+L,SAAS,OAAO,sEAAsE,SAAS,OAAO,mEAAmE,6CAA6C,OAAO,6BAA6B,4EAA4E,OAAO,MAAM,8BAA8B,sOAAsO,0BAA0B,OAAO,oKAAoK,OAAO,gCAAgC,yBAAyB,OAAO,wEAAwE,OAAO,2DAA2D,cAAc,yFAAyF,+BAA+B,0BAA0B,kCAAkC,yEAAyE,wBAAwB,2EAA2E,mCAAmC,sLAAsL,EAAE,aAAa,2BAA2B,uCAAuC,qCAAqC,wBAAwB,WAAW,EAAE,SAAS,6DAA6D,OAAO,MAAM,KAAK,QAAQ,qLAAqL,kCAAkC,2BAA2B,oBAAoB,ghBAAghB,qHAAqH,sCAAsC,sCAAsC,OAAO,0EAA0E,OAAO,yVAAyV,2GAA2G,2DAA2D,OAAO,sCAAsC,qCAAqC,4CAA4C,OAAO,uDAAuD,qBAAqB,gCAAgC,wBAAwB,OAAO,0CAA0C,6CAA6C,OAAO,8BAA8B,gFAAgF,EAAE,oEAAoE,4EAA4E,kFAAkF,iCAAiC,wBAAwB,wBAAwB,yBAAyB,iCAAiC,aAAa,IAAI,kEAAkE,OAAO,wBAAwB,wBAAwB,yBAAyB,2BAA2B,0DAA0D,6CAA6C,MAAM,4qBAA4qB,oCAAoC,uDAAuD,oCAAoC,8EAA8E,WAAW,EAAE,kCAAkC,MAAM,yDAAyD,OAAO,uXAAuX,8BAA8B,gDAAgD,4FAA4F,6BAA6B,MAAM,gvCAAgvC,gCAAgC,yDAAyD,oCAAoC,yUAAyU,8BAA8B,yBAAyB,OAAO,yIAAyI,gBAAgB,cAAc,OAAO,2EAA2E,cAAc,YAAY,WAAW,EAAE,kCAAkC,MAAM,yDAAyD,OAAO,4UAA4U,cAAc,mIAAmI,8BAA8B,+CAA+C,sEAAsE,QAAQ,wBAAwB,0CAA0C,yCAAyC,iCAAiC,6CAA6C,mCAAmC,qLAAqL,yDAAyD,0BAA0B,2IAA2I,iBAAiB,gBAAgB,aAAa,EAAE,WAAW,yCAAyC,yDAAyD,yDAAyD,uCAAuC,eAAe,+BAA+B,0IAA0I,sCAAsC,qCAAqC,eAAe,aAAa,EAAE,WAAW,EAAE,SAAS,yBAAyB,QAAQ,yCAAyC,qBAAqB,kDAAkD,0CAA0C,iCAAiC,SAAS,0BAA0B,6BAA6B,SAAS,2DAA2D,gCAAgC,qBAAqB,+CAA+C,2CAA2C,WAAW,EAAE,SAAS,OAAO,EAAE,wCAAwC,kCAAkC,sBAAsB,SAAS,OAAO,oJAAoJ,gCAAgC,8CAA8C,SAAS,OAAO,6BAA6B,MAAM,wMAAwM,oCAAoC,yDAAyD,oCAAoC,gFAAgF,WAAW,EAAE,kCAAkC,MAAM,yDAAyD,OAAO,4PAA4P,gGAAgG,MAAM,iNAAiN,oCAAoC,6DAA6D,oCAAoC,gFAAgF,WAAW,EAAE,kCAAkC,MAAM,yDAAyD,OAAO,oQAAoQ,iGAAiG,MAAM,2KAA2K,oLAAoL,yGAAyG,OAAO,mCAAmC,sCAAsC,6FAA6F,kBAAkB,EAAE,EAAE,oBAAoB,OAAO,6CAA6C,4CAA4C,oDAAoD,sDAAsD,SAAS,EAAE,gEAAgE,0BAA0B,SAAS,EAAE,oCAAoC,kCAAkC,SAAS,yCAAyC,yCAAyC,qDAAqD,WAAW,OAAO,4CAA4C,WAAW,SAAS,2CAA2C,yCAAyC,qDAAqD,WAAW,OAAO,4CAA4C,WAAW,SAAS,iCAAiC,wCAAwC,oBAAoB,OAAO,mMAAmM,wBAAwB,oCAAoC,iBAAiB,SAAS,qCAAqC,iEAAiE,8CAA8C,kCAAkC,WAAW,8BAA8B,oCAAoC,mCAAmC,qGAAqG,qDAAqD,qCAAqC,yCAAyC,iBAAiB,eAAe,EAAE,aAAa,8DAA8D,sDAAsD,eAAe,EAAE,aAAa,WAAW,SAAS,EAAE,qCAAqC,OAAO,gQAAgQ,OAAO,qDAAqD,QAAQ,sCAAsC,6BAA6B,wDAAwD,qBAAqB,uDAAuD,SAAS,uBAAuB,sBAAsB,SAAS,gDAAgD,sBAAsB,SAAS,qBAAqB,OAAO,+GAA+G,gBAAgB,sCAAsC,gDAAgD,OAAO,mGAAmG,uBAAuB,uEAAuE,SAAS,gBAAgB,qGAAqG,OAAO,qEAAqE,OAAO,0EAA0E,qCAAqC,OAAO,qLAAqL,mCAAmC,oBAAoB,mDAAmD,sEAAsE,WAAW,gDAAgD,uBAAuB,SAAS,OAAO,gDAAgD,SAAS,OAAO,wGAAwG,iDAAiD,mBAAmB,sBAAsB,SAAS,wCAAwC,oBAAoB,4CAA4C,uBAAuB,SAAS,OAAO,6CAA6C,SAAS,gDAAgD,uBAAuB,OAAO,wIAAwI,OAAO,yDAAyD,QAAQ,oCAAoC,gEAAgE,OAAO,2RAA2R,sEAAsE,iFAAiF,wDAAwD,4BAA4B,wCAAwC,qCAAqC,aAAa,+GAA+G,0DAA0D,aAAa,OAAO,wCAAwC,aAAa,+BAA+B,WAAW,SAAS,EAAE,OAAO,uHAAuH,sDAAsD,2DAA2D,4DAA4D,0DAA0D,SAAS,EAAE,0CAA0C,4EAA4E,kLAAkL,8BAA8B,EAAE,kFAAkF,OAAO,2HAA2H,qBAAqB,iBAAiB,SAAS,mFAAmF,yCAAyC,yCAAyC,kDAAkD,+BAA+B,OAAO,sGAAsG,gCAAgC,EAAE,OAAO,qTAAqT,uDAAuD,yBAAyB,qCAAqC,oJAAoJ,wBAAwB,sDAAsD,oDAAoD,oDAAoD,4DAA4D,uCAAuC,qCAAqC,2BAA2B,2DAA2D,WAAW,gBAAgB,mCAAmC,WAAW,SAAS,EAAE,wCAAwC,OAAO,mQAAmQ,0UAA0U,2DAA2D,+EAA+E,+CAA+C,WAAW,SAAS,EAAE,uDAAuD,oDAAoD,yDAAyD,2CAA2C,wBAAwB,4DAA4D,4DAA4D,6OAA6O,8EAA8E,+CAA+C,aAAa,WAAW,EAAE,wBAAwB,4CAA4C,WAAW,SAAS,EAAE,wCAAwC,wCAAwC,OAAO,mLAAmL,4GAA4G,EAAE,yFAAyF,yCAAyC,kCAAkC,OAAO,oIAAoI,wBAAwB,wDAAwD,iEAAiE,gDAAgD,+BAA+B,WAAW,SAAS,EAAE,OAAO,sMAAsM,yCAAyC,4HAA4H,wDAAwD,2CAA2C,+CAA+C,iDAAiD,yCAAyC,0BAA0B,WAAW,SAAS,qBAAqB,OAAO,iQAAiQ,wBAAwB,oCAAoC,oCAAoC,uDAAuD,SAAS,4DAA4D,8BAA8B,mBAAmB,iFAAiF,2DAA2D,0CAA0C,aAAa,OAAO,0CAA0C,aAAa,WAAW,SAAS,EAAE,OAAO,0OAA0O,wBAAwB,4DAA4D,sDAAsD,4DAA4D,mDAAmD,sDAAsD,wCAAwC,WAAW,EAAE,SAAS,EAAE,yJAAyJ,kDAAkD,wEAAwE,EAAE,WAAW,SAAS,EAAE,oEAAoE,gDAAgD,4DAA4D,EAAE,WAAW,SAAS,EAAE,OAAO,wSAAwS,iEAAiE,GAAG,oDAAoD,0DAA0D,YAAY,EAAE,yDAAyD,oDAAoD,0DAA0D,YAAY,EAAE,gDAAgD,mCAAmC,OAAO,sCAAsC,6CAA6C,OAAO,gMAAgM,QAAQ,0IAA0I,wBAAwB,+DAA+D,sBAAsB,mDAAmD,2CAA2C,WAAW,EAAE,0BAA0B,SAAS,OAAO,qBAAqB,iDAAiD,SAAS,4EAA4E,qBAAqB,sBAAsB,SAAS,4CAA4C,mCAAmC,SAAS,0BAA0B,8DAA8D,2GAA2G,kEAAkE,WAAW,SAAS,EAAE,wGAAwG,gEAAgE,8CAA8C,WAAW,EAAE,SAAS,8GAA8G,gEAAgE,0CAA0C,oIAAoI,0DAA0D,yCAAyC,aAAa,WAAW,SAAS,EAAE,0EAA0E,uBAAuB,SAAS,wCAAwC,+BAA+B,8CAA8C,kDAAkD,uFAAuF,gCAAgC,kOAAkO,8BAA8B,WAAW,6CAA6C,wCAAwC,WAAW,kGAAkG,wGAAwG,iCAAiC,WAAW,+BAA+B,iCAAiC,iCAAiC,wCAAwC,aAAa,OAAO,2CAA2C,aAAa,WAAW,0DAA0D,8EAA8E,iDAAiD,+BAA+B,uDAAuD,kCAAkC,yCAAyC,aAAa,WAAW,OAAO,sCAAsC,uCAAuC,WAAW,SAAS,EAAE,gCAAgC,+BAA+B,SAAS,oBAAoB,OAAO,sOAAsO,gCAAgC,6BAA6B,6CAA6C,OAAO,qMAAqM,OAAO,iCAAiC,OAAO,8EAA8E,wDAAwD,qBAAqB,SAAS,8DAA8D,OAAO,gIAAgI,OAAO,gCAAgC,2DAA2D,wDAAwD,OAAO,mOAAmO,OAAO,gCAAgC,mEAAmE,8DAA8D,OAAO,mJAAmJ,OAAO,gCAAgC,mEAAmE,2DAA2D,OAAO,6VAA6V,OAAO,4BAA4B,SAAS,wEAAwE,8CAA8C,OAAO,wKAAwK,gCAAgC,6BAA6B,sEAAsE,8CAA8C,OAAO,qJAAqJ,sDAAsD,mDAAmD,kCAAkC,SAAS,EAAE,oBAAoB,OAAO,2HAA2H,qEAAqE,OAAO,mPAAmP,OAAO,2cAA2c,cAAc,2GAA2G,wBAAwB,gCAAgC,sCAAsC,uNAAuN,EAAE,6DAA6D,qEAAqE,sBAAsB,SAAS,mCAAmC,OAAO,mNAAmN,4DAA4D,6DAA6D,kEAAkE,mEAAmE,yEAAyE,GAAG,+CAA+C,wDAAwD,qDAAqD,sFAAsF,YAAY,EAAE,+DAA+D,yEAAyE,gCAAgC,oDAAoD,mBAAmB,kFAAkF,EAAE,+BAA+B,OAAO,2pBAA2pB,cAAc,2IAA2I,8CAA8C,iEAAiE,uBAAuB,yBAAyB,SAAS,OAAO,qBAAqB,6BAA6B,yBAAyB,SAAS,wBAAwB,uBAAuB,EAAE,uCAAuC,iEAAiE,sEAAsE,WAAW,EAAE,wCAAwC,qCAAqC,4EAA4E,oCAAoC,aAAa,wEAAwE,oCAAoC,aAAa,gCAAgC,mMAAmM,aAAa,WAAW,SAAS,2CAA2C,2BAA2B,6CAA6C,SAAS,kDAAkD,8BAA8B,mCAAmC,SAAS,qBAAqB,mDAAmD,2BAA2B,UAAU,oDAAoD,gFAAgF,SAAS,2BAA2B,wFAAwF,kHAAkH,8BAA8B,6KAA6K,+DAA+D,+DAA+D,wGAAwG,mBAAmB,6CAA6C,WAAW,mBAAmB,gFAAgF,WAAW,EAAE,SAAS,4BAA4B,+CAA+C,gFAAgF,kFAAkF,iDAAiD,4CAA4C,oCAAoC,0CAA0C,2DAA2D,uEAAuE,6BAA6B,WAAW,wCAAwC,mPAAmP,EAAE,gEAAgE,6DAA6D,+BAA+B,gDAAgD,eAAe,aAAa,2CAA2C,+BAA+B,6CAA6C,aAAa,yBAAyB,aAAa,mBAAmB,gCAAgC,8CAA8C,aAAa,oCAAoC,2BAA2B,SAAS,EAAE,sCAAsC,OAAO,mRAAmR,OAAO,+lBAA+lB,cAAc,+GAA+G,gCAAgC,yBAAyB,2CAA2C,qEAAqE,UAAU,yBAAyB,kCAAkC,SAAS,8BAA8B,2BAA2B,SAAS,wCAAwC,0NAA0N,EAAE,wCAAwC,6BAA6B,6BAA6B,WAAW,uBAAuB,SAAS,mCAAmC,OAAO,+JAA+J,mCAAmC,8DAA8D,4BAA4B,wDAAwD,WAAW,SAAS,EAAE,gCAAgC,8CAA8C,SAAS,qBAAqB,2CAA2C,SAAS,sBAAsB,OAAO,iGAAiG,aAAa,kCAAkC,qDAAqD,OAAO,iGAAiG,QAAQ,kCAAkC,wBAAwB,OAAO,sRAAsR,gCAAgC,sCAAsC,8BAA8B,2EAA2E,wDAAwD,qCAAqC,SAAS,EAAE,2EAA2E,iCAAiC,0BAA0B,iEAAiE,wEAAwE,SAAS,EAAE,uBAAuB,sBAAsB,SAAS,oIAAoI,4DAA4D,sCAAsC,WAAW,UAAU,4HAA4H,6BAA6B,gDAAgD,8GAA8G,8DAA8D,SAAS,iCAAiC,oBAAoB,OAAO,yNAAyN,6BAA6B,OAAO,kNAAkN,OAAO,+CAA+C,QAAQ,2CAA2C,gCAAgC,0CAA0C,SAAS,yDAAyD,OAAO,+eAA+e,oBAAoB,mEAAmE,SAAS,yBAAyB,2CAA2C,yDAAyD,+CAA+C,oCAAoC,WAAW,SAAS,EAAE,uBAAuB,OAAO,6JAA6J,OAAO,4EAA4E,6DAA6D,sBAAsB,SAAS,8CAA8C,OAAO,iJAAiJ,OAAO,+CAA+C,iDAAiD,OAAO,mLAAmL,QAAQ,oCAAoC,+CAA+C,OAAO,yTAAyT,OAAO,qDAAqD,OAAO,2DAA2D,yIAAyI,yEAAyE,wHAAwH,SAAS,2BAA2B,8DAA8D,uDAAuD,4BAA4B,WAAW,SAAS,EAAE,uBAAuB,+DAA+D,SAAS,qBAAqB,OAAO,yRAAyR,+CAA+C,sBAAsB,SAAS,2BAA2B,0BAA0B,kDAAkD,qBAAqB,sBAAsB,SAAS,uCAAuC,8CAA8C,SAAS,OAAO,sDAAsD,SAAS,qBAAqB,OAAO,wEAAwE,UAAU,2FAA2F,iCAAiC,OAAO,8EAA8E,UAAU,+CAA+C,OAAO,oGAAoG,QAAQ,gHAAgH,+CAA+C,OAAO,OAAO,EAAE,0KAA0K,mCAAmC,wEAAwE,OAAO,0DAA0D,yBAAyB,qDAAqD,wDAAwD,OAAO,yBAAyB,MAAM,sKAAsK,6DAA6D,kDAAkD,MAAM,qJAAqJ,8BAA8B,sCAAsC,OAAO,kBAAkB,wCAAwC,yBAAyB,qBAAqB,iBAAiB,OAAO,6BAA6B,6CAA6C,gJAAgJ,4CAA4C,SAAS,uBAAuB,mIAAmI,4CAA4C,SAAS,mDAAmD,mBAAmB,SAAS,kCAAkC,OAAO,2CAA2C,MAAM,wJAAwJ,kCAAkC,qDAAqD,+CAA+C,OAAO,EAAE,uBAAuB,iBAAiB,OAAO,6BAA6B,0DAA0D,2CAA2C,+IAA+I,4CAA4C,SAAS,iDAAiD,OAAO,sCAAsC,MAAM,qNAAqN,8BAA8B,sCAAsC,OAAO,8CAA8C,qHAAqH,0CAA0C,+CAA+C,mDAAmD,uCAAuC,4BAA4B,OAAO,0BAA0B,qHAAqH,OAAO,EAAE,MAAM,+JAA+J,2CAA2C,0bAA0b,4FAA4F,qHAAqH,YAAY,GAAG,kDAAkD,EAAE,+FAA+F,kIAAkI,qHAAqH,YAAY,GAAG,kDAAkD,EAAE,+BAA+B,OAAO,yEAAyE,OAAO,oHAAoH,OAAO,kGAAkG,MAAM,8GAA8G,+EAA+E,2DAA2D,iFAAiF,SAAS,OAAO,2GAA2G,SAAS,OAAO,mJAAmJ,8BAA8B,OAAO,oCAAoC,uCAAuC,kCAAkC,qDAAqD,+DAA+D,+QAA+Q,OAAO,OAAO,8DAA8D,OAAO,qHAAqH,uEAAuE,sEAAsE,SAAS,0EAA0E,uEAAuE,QAAQ,mPAAmP,uCAAuC,2CAA2C,wEAAwE,OAAO,oEAAoE,aAAa,2IAA2I,uCAAuC,oBAAoB,mBAAmB,QAAQ,2DAA2D,4BAA4B,MAAM,6EAA6E,gDAAgD,6CAA6C,iCAAiC,+BAA+B,kCAAkC,WAAW,iBAAiB,SAAS,6CAA6C,8BAA8B,+BAA+B,WAAW,iBAAiB,SAAS,OAAO,EAAE,MAAM,+DAA+D,yHAAyH,2BAA2B,OAAO,yCAAyC,qEAAqE,OAAO,0CAA0C,gCAAgC,kDAAkD,6DAA6D,2CAA2C,WAAW,SAAS,EAAE,OAAO,+BAA+B,mDAAmD,6DAA6D,2CAA2C,WAAW,SAAS,EAAE,OAAO,oCAAoC,MAAM,wBAAwB,OAAO,uCAAuC,OAAO,oHAAoH,+BAA+B,4BAA4B,+EAA+E,yCAAyC,2CAA2C,2CAA2C,oCAAoC,SAAS,EAAE,OAAO,EAAE,8CAA8C,sCAAsC,wCAAwC,wDAAwD,sCAAsC,SAAS,cAAc,kGAAkG,gCAAgC,wDAAwD,+EAA+E,wCAAwC,qBAAqB,aAAa,8CAA8C,iCAAiC,aAAa,OAAO,wCAAwC,aAAa,WAAW,EAAE,mCAAmC,mHAAmH,qKAAqK,WAAW,0IAA0I,kEAAkE,WAAW,GAAG,kDAAkD,oDAAoD,qDAAqD,WAAW,EAAE,uIAAuI,mCAAmC,qLAAqL,yDAAyD,mDAAmD,wCAAwC,kEAAkE,kCAAkC,oDAAoD,qCAAqC,mBAAmB,wCAAwC,4BAA4B,oHAAoH,iBAAiB,gBAAgB,aAAa,wCAAwC,wBAAwB,2DAA2D,0CAA0C,yGAAyG,iBAAiB,OAAO,qDAAqD,uCAAuC,iBAAiB,eAAe,EAAE,0BAA0B,uGAAuG,eAAe,eAAe,0BAA0B,6CAA6C,6BAA6B,aAAa,mBAAmB,0CAA0C,gDAAgD,aAAa,EAAE,WAAW,EAAE,SAAS,EAAE,OAAO,mBAAmB,sBAAsB,OAAO,EAAE,MAAM,KAAK,QAAQ,qBAAqB,kCAAkC,2BAA2B,oBAAoB,yoBAAyoB,kIAAkI,OAAO,sDAAsD,UAAU,oGAAoG,6DAA6D,oEAAoE,6BAA6B,2BAA2B,SAAS,OAAO,mEAAmE,SAAS,OAAO,6HAA6H,OAAO,0DAA0D,kCAAkC,OAAO,+ZAA+Z,OAAO,4CAA4C,OAAO,+HAA+H,iDAAiD,OAAO,+ZAA+Z,eAAe,oGAAoG,wCAAwC,OAAO,6aAA6a,eAAe,oGAAoG,wCAAwC,OAAO,mFAAmF,iEAAiE,mCAAmC,sDAAsD,+UAA+U,WAAW,qCAAqC,gHAAgH,WAAW,uDAAuD,gLAAgL,WAAW,SAAS,8CAA8C,4EAA4E,SAAS,qBAAqB,OAAO,KAAK,EAAE,GAAG,QAAQ,6CAA6C,kCAAkC,2BAA2B,oBAAoB,2OAA2O,MAAM,gFAAgF,OAAO,uqBAAuqB,8BAA8B,+BAA+B,6CAA6C,OAAO,0BAA0B,mCAAmC,OAAO,0BAA0B,mCAAmC,OAAO,oBAAoB,6CAA6C,mBAAmB,4BAA4B,mCAAmC,EAAE,OAAO,MAAM,6JAA6J,sWAAsW,8IAA8I,wCAAwC,uBAAuB,EAAE,EAAE,OAAO,qKAAqK,MAAM,oFAAoF,OAAO,6SAA6S,uDAAuD,WAAW,gCAAgC,+DAA+D,0LAA0L,YAAY,OAAO,6DAA6D,4BAA4B,uBAAuB,4EAA4E,WAAW,0BAA0B,8CAA8C,iIAAiI,WAAW,wBAAwB,6EAA6E,gIAAgI,WAAW,0BAA0B,4BAA4B,SAAS,2HAA2H,YAAY,OAAO,kEAAkE,yCAAyC,yBAAyB,yCAAyC,WAAW,SAAS,0JAA0J,mGAAmG,yEAAyE,8BAA8B,qBAAqB,aAAa,EAAE,SAAS,6BAA6B,sBAAsB,SAAS,gDAAgD,YAAY,OAAO,iCAAiC,gCAAgC,8BAA8B,uDAAuD,WAAW,SAAS,oBAAoB,OAAO,0LAA0L,MAAM,6FAA6F,OAAO,8NAA8N,+BAA+B,gCAAgC,+DAA+D,sCAAsC,OAAO,OAAO,kEAAkE,uBAAuB,qBAAqB,WAAW,sCAAsC,wCAAwC,sCAAsC,uCAAuC,wBAAwB,gCAAgC,kCAAkC,0DAA0D,WAAW,uCAAuC,SAAS,oBAAoB,OAAO,sEAAsE,OAAO,4HAA4H,6CAA6C,OAAO,8EAA8E,2IAA2I,kDAAkD,OAAO,gFAAgF,OAAO,4EAA4E,kCAAkC,OAAO,iNAAiN,OAAO,mNAAmN,gCAAgC,+BAA+B,oEAAoE,SAAS,4DAA4D,2CAA2C,qDAAqD,SAAS,OAAO,4CAA4C,SAAS,8BAA8B,+CAA+C,SAAS,oBAAoB,OAAO,4FAA4F,OAAO,8GAA8G,kDAAkD,wBAAwB,EAAE,EAAE,OAAO,qQAAqQ,MAAM,6FAA6F,OAAO,4NAA4N,wBAAwB,8BAA8B,gCAAgC,uDAAuD,uCAAuC,SAAS,EAAE,sBAAsB,0BAA0B,mCAAmC,EAAE,8BAA8B,+CAA+C,SAAS,oBAAoB,OAAO,oPAAoP,OAAO,2lBAA2lB,yCAAyC,0CAA0C,+BAA+B,SAAS,8BAA8B,8DAA8D,2BAA2B,kGAAkG,0BAA0B,4BAA4B,6CAA6C,WAAW,OAAO,+CAA+C,WAAW,4BAA4B,SAAS,mCAAmC,OAAO,8OAA8O,aAAa,oFAAoF,OAAO,yrBAAyrB,wBAAwB,kDAAkD,mDAAmD,qBAAqB,uBAAuB,SAAS,4BAA4B,mCAAmC,SAAS,sCAAsC,0DAA0D,6BAA6B,yCAAyC,WAAW,wBAAwB,qCAAqC,WAAW,OAAO,4DAA4D,WAAW,UAAU,kCAAkC,qBAAqB,OAAO,uNAAuN,oBAAoB,OAAO,wNAAwN,sCAAsC,OAAO,6HAA6H,wBAAwB,yBAAyB,yBAAyB,yBAAyB,OAAO,kJAAkJ,+CAA+C,4BAA4B,oCAAoC,iDAAiD,4DAA4D,0BAA0B,WAAW,SAAS,8BAA8B,kCAAkC,SAAS,qBAAqB,OAAO,gIAAgI,wCAAwC,kCAAkC,SAAS,mDAAmD,OAAO,yWAAyW,uEAAuE,iBAAiB,SAAS,+BAA+B,sCAAsC,SAAS,gDAAgD,0DAA0D,uCAAuC,SAAS,4CAA4C,OAAO,OAAO,EAAE,sbAAsb,yHAAyH,uDAAuD,8EAA8E,QAAQ,KAAK,EAAE,gJAAgJ,kIAAkI,+BAA+B,YAAY,UAAU,GAAG,oEAAoE,uCAAuC,YAAY,UAAU,EAAE,mDAAmD,kDAAkD,OAAO,qEAAqE,OAAO,+DAA+D,MAAM,oGAAoG,KAAK,QAAQ,4DAA4D,kCAAkC,2BAA2B,oBAAoB,slBAAslB,oCAAoC,mCAAmC,EAAE,4BAA4B,6CAA6C,4BAA4B,MAAM,8FAA8F,mOAAmO,uKAAuK,sSAAsS,uCAAuC,OAAO,+JAA+J,4PAA4P,oBAAoB,OAAO,6LAA6L,0BAA0B,oBAAoB,OAAO,mNAAmN,eAAe,6DAA6D,mEAAmE,iDAAiD,yBAAyB,uCAAuC,SAAS,sBAAsB,oCAAoC,SAAS,kBAAkB,OAAO,oKAAoK,oCAAoC,8BAA8B,iCAAiC,gCAAgC,SAAS,oBAAoB,OAAO,mGAAmG,iCAAiC,uBAAuB,sIAAsI,MAAM,cAAc,qYAAqY,2DAA2D,sBAAsB,iBAAiB,SAAS,gCAAgC,wBAAwB,yDAAyD,sCAAsC,uCAAuC,WAAW,wBAAwB,4EAA4E,WAAW,+CAA+C,wDAAwD,wCAAwC,oDAAoD,gCAAgC,6CAA6C,WAAW,OAAO,2DAA2D,WAAW,SAAS,EAAE,OAAO,oRAAoR,sDAAsD,OAAO,yPAAyP,2BAA2B,+BAA+B,yBAAyB,SAAS,wBAAwB,4CAA4C,8BAA8B,uCAAuC,WAAW,SAAS,EAAE,+BAA+B,OAAO,4UAA4U,uBAAuB,gEAAgE,wBAAwB,+BAA+B,WAAW,+BAA+B,4CAA4C,WAAW,iEAAiE,SAAS,OAAO,0CAA0C,SAAS,OAAO,OAAO,EAAE,wCAAwC,OAAO,+DAA+D,OAAO,yDAAyD,MAAM,wFAAwF,KAAK,QAAQ,qBAAqB,kCAAkC,2BAA2B,oBAAoB,2cAA2c,kNAAkN,sCAAsC,uDAAuD,eAAe,oEAAoE,OAAO,yIAAyI,iCAAiC,kDAAkD,oCAAoC,SAAS,iEAAiE,OAAO,mJAAmJ,gCAAgC,iBAAiB,SAAS,4CAA4C,wBAAwB,iBAAiB,SAAS,sEAAsE,+BAA+B,iCAAiC,WAAW,SAAS,EAAE,OAAO,iHAAiH,4CAA4C,wBAAwB,iBAAiB,SAAS,0BAA0B,sEAAsE,yCAAyC,SAAS,EAAE,OAAO,2MAA2M,gCAAgC,iBAAiB,SAAS,qBAAqB,mCAAmC,8BAA8B,yDAAyD,SAAS,OAAO,4CAA4C,SAAS,4CAA4C,qCAAqC,iBAAiB,SAAS,yEAAyE,uBAAuB,qCAAqC,SAAS,OAAO,mDAAmD,4GAA4G,qCAAqC,SAAS,gCAAgC,uCAAuC,mFAAmF,uDAAuD,6BAA6B,8CAA8C,4CAA4C,SAAS,OAAO,mOAAmO,qBAAqB,mCAAmC,8BAA8B,yDAAyD,SAAS,OAAO,4CAA4C,SAAS,yCAAyC,oDAAoD,gDAAgD,yCAAyC,0HAA0H,gDAAgD,0CAA0C,kCAAkC,qDAAqD,aAAa,YAAY,4BAA4B,qBAAqB,cAAc,SAAS,OAAO,0BAA0B,4CAA4C,iCAAiC,iDAAiD,wCAAwC,6HAA6H,mBAAmB,sCAAsC,eAAe,EAAE,aAAa,+CAA+C,kCAAkC,2CAA2C,eAAe,oCAAoC,aAAa,WAAW,EAAE,yBAAyB,SAAS,OAAO,4GAA4G,qBAAqB,mCAAmC,8BAA8B,yDAAyD,SAAS,OAAO,4CAA4C,SAAS,0CAA0C,wBAAwB,mCAAmC,8CAA8C,8CAA8C,gCAAgC,mDAAmD,WAAW,UAAU,oDAAoD,OAAO,gHAAgH,qBAAqB,mCAAmC,8BAA8B,SAAS,OAAO,4CAA4C,SAAS,kDAAkD,oCAAoC,OAAO,8FAA8F,4CAA4C,wBAAwB,iBAAiB,SAAS,wBAAwB,sEAAsE,gCAAgC,SAAS,EAAE,OAAO,mKAAmK,gCAAgC,iBAAiB,SAAS,mCAAmC,yDAAyD,SAAS,kDAAkD,oCAAoC,SAAS,OAAO,qcAAqc,OAAO,qEAAqE,OAAO,2DAA2D,cAAc,kJAAkJ,kBAAkB,gCAAgC,6EAA6E,+CAA+C,mIAAmI,yCAAyC,uCAAuC,WAAW,4CAA4C,SAAS,6EAA6E,+CAA+C,uIAAuI,yCAAyC,uCAAuC,WAAW,4CAA4C,SAAS,gHAAgH,8CAA8C,mEAAmE,gCAAgC,mDAAmD,WAAW,UAAU,4CAA4C,OAAO,kXAAkX,OAAO,yFAAyF,cAAc,2HAA2H,+CAA+C,yGAAyG,SAAS,yBAAyB,gCAAgC,sCAAsC,wIAAwI,EAAE,yDAAyD,2DAA2D,0CAA0C,wCAAwC,uBAAuB,SAAS,mCAAmC,OAAO,4FAA4F,8CAA8C,wEAAwE,uBAAuB,yBAAyB,SAAS,OAAO,qBAAqB,6BAA6B,yBAAyB,SAAS,gCAAgC,4CAA4C,8CAA8C,yCAAyC,gCAAgC,mDAAmD,WAAW,UAAU,yEAAyE,OAAO,qFAAqF,yDAAyD,8CAA8C,yCAAyC,2CAA2C,mDAAmD,WAAW,UAAU,mEAAmE,OAAO,uJAAuJ,mCAAmC,OAAO,iEAAiE,OAAO,sEAAsE,sCAAsC,OAAO,wGAAwG,OAAO,0BAA0B,OAAO,2DAA2D,QAAQ,uFAAuF,yDAAyD,OAAO,wGAAwG,OAAO,0BAA0B,OAAO,2DAA2D,QAAQ,uFAAuF,yDAAyD,OAAO,8DAA8D,OAAO,mEAAmE,mCAAmC,OAAO,kGAAkG,OAAO,uBAAuB,OAAO,2DAA2D,QAAQ,iFAAiF,mDAAmD,OAAO,yNAAyN,gHAAgH,OAAO,oNAAoN,OAAO,4EAA4E,kCAAkC,OAAO,4GAA4G,OAAO,mEAAmE,cAAc,gJAAgJ,gCAAgC,oCAAoC,+DAA+D,SAAS,oEAAoE,yDAAyD,+DAA+D,SAAS,+BAA+B,kKAAkK,yBAAyB,4CAA4C,uCAAuC,iDAAiD,gEAAgE,mDAAmD,SAAS,6BAA6B,OAAO,QAAQ,4BAA4B,miBAAmiB,qiBAAqiB,eAAe,uGAAuG,OAAO,mEAAmE,OAAO,wDAAwD,OAAO,4DAA4D,OAAO,2DAA2D,cAAc,qLAAqL,4BAA4B,kCAAkC,kCAAkC,mDAAmD,2CAA2C,OAAO,2TAA2T,OAAO,kEAAkE,OAAO,uDAAuD,OAAO,2DAA2D,cAAc,2KAA2K,mDAAmD,2BAA2B,yCAAyC,EAAE,mCAAmC,OAAO,wSAAwS,OAAO,+DAA+D,OAAO,2DAA2D,cAAc,wIAAwI,+CAA+C,sHAAsH,SAAS,gCAAgC,qDAAqD,+BAA+B,2KAA2K,oCAAoC,0DAA0D,yCAAyC,uCAAuC,sBAAsB,WAAW,mCAAmC,OAAO,iPAAiP,cAAc,qHAAqH,+CAA+C,kHAAkH,SAAS,sEAAsE,qHAAqH,uCAAuC,+DAA+D,6DAA6D,uCAAuC,uCAAuC,kIAAkI,EAAE,eAAe,EAAE,aAAa,yCAAyC,+CAA+C,WAAW,oDAAoD,yCAAyC,2BAA2B,SAAS,EAAE,OAAO,qUAAqU,OAAO,0GAA0G,OAAO,wGAAwG,gCAAgC,sCAAsC,mIAAmI,eAAe,SAAS,EAAE,kDAAkD,OAAO,kKAAkK,aAAa,wEAAwE,+CAA+C,kHAAkH,SAAS,kCAAkC,gGAAgG,yCAAyC,SAAS,8CAA8C,yCAAyC,SAAS,mDAAmD,yFAAyF,SAAS,gGAAgG,8GAA8G,wBAAwB,sEAAsE,SAAS,kEAAkE,sDAAsD,0CAA0C,8CAA8C,wBAAwB,mEAAmE,kCAAkC,mDAAmD,4DAA4D,gDAAgD,iDAAiD,EAAE,uCAAuC,OAAO,6GAA6G,cAAc,uHAAuH,sCAAsC,2DAA2D,SAAS,mDAAmD,2DAA2D,SAAS,uKAAuK,0BAA0B,wBAAwB,WAAW,oEAAoE,wDAAwD,4CAA4C,gDAAgD,0BAA0B,qEAAqE,oCAAoC,qDAAqD,8DAA8D,kDAAkD,mDAAmD,EAAE,yCAAyC,SAAS,EAAE,OAAO,oRAAoR,QAAQ,8GAA8G,8CAA8C,OAAO,6bAA6b,OAAO,mEAAmE,cAAc,uPAAuP,gCAAgC,qDAAqD,sEAAsE,0EAA0E,SAAS,6DAA6D,OAAO,wEAAwE,mDAAmD,OAAO,yCAAyC,qEAAqE,OAAO,6IAA6I,8FAA8F,8BAA8B,SAAS,mCAAmC,uCAAuC,kDAAkD,mCAAmC,2BAA2B,gDAAgD,kCAAkC,qIAAqI,SAAS,OAAO,gIAAgI,SAAS,OAAO,8DAA8D,qEAAqE,kGAAkG,4EAA4E,SAAS,OAAO,kDAAkD,mDAAmD,iDAAiD,OAAO,OAAO,EAAE,GAAG,QAAQ,uBAAuB,kCAAkC,2BAA2B,wUAAwU,qEAAqE,OAAO,4CAA4C,kCAAkC,OAAO,wIAAwI,iCAAiC,kDAAkD,oCAAoC,SAAS,oEAAoE,OAAO,MAAM,+BAA+B,0FAA0F,4JAA4J,wGAAwG,cAAc,yIAAyI,gCAAgC,yDAAyD,kEAAkE,+BAA+B,wKAAwK,oCAAoC,6DAA6D,4CAA4C,yBAAyB,SAAS,sCAAsC,OAAO,uFAAuF,QAAQ,8CAA8C,wCAAwC,OAAO,gZAAgZ,QAAQ,sDAAsD,4CAA4C,0GAA0G,SAAS,OAAO,KAAK,EAAE,GAAG,QAAQ,iFAAiF,kCAAkC,2BAA2B,oBAAoB,4nBAA4nB,mBAAmB,qCAAqC,4DAA4D,wCAAwC,4DAA4D,QAAQ,EAAE,wYAAwY,wBAAwB,oCAAoC,8DAA8D,gDAAgD,4DAA4D,QAAQ,EAAE,uTAAuT,oBAAoB,oCAAoC,8DAA8D,wCAAwC,4DAA4D,QAAQ,EAAE,0DAA0D,oCAAoC,6DAA6D,OAAO,uCAAuC,yDAAyD,yBAAyB,yBAAyB,uBAAuB,kEAAkE,8BAA8B,MAAM,4KAA4K,oHAAoH,eAAe,oDAAoD,YAAY,2FAA2F,yCAAyC,2BAA2B,6CAA6C,kCAAkC,kCAAkC,SAAS,0CAA0C,2DAA2D,SAAS,OAAO,EAAE,6CAA6C,8BAA8B,mBAAmB,MAAM,+BAA+B,4NAA4N,OAAO,8DAA8D,OAAO,weAAwe,wBAAwB,2CAA2C,gCAAgC,wDAAwD,0BAA0B,sCAAsC,SAAS,wDAAwD,2DAA2D,SAAS,mEAAmE,yBAAyB,4BAA4B,WAAW,8IAA8I,kDAAkD,WAAW,mCAAmC,OAAO,mFAAmF,OAAO,yEAAyE,sBAAsB,sCAAsC,yCAAyC,qDAAqD,SAAS,2BAA2B,iDAAiD,SAAS,+BAA+B,qCAAqC,SAAS,6BAA6B,mCAAmC,SAAS,wCAAwC,iDAAiD,SAAS,gEAAgE,wBAAwB,SAAS,EAAE,wBAAwB,OAAO,kMAAkM,OAAO,0eAA0e,cAAc,sHAAsH,wBAAwB,gCAAgC,wCAAwC,2NAA2N,EAAE,kDAAkD,yDAAyD,oBAAoB,qCAAqC,yDAAyD,aAAa,OAAO,2CAA2C,aAAa,yCAAyC,uBAAuB,WAAW,EAAE,SAAS,6BAA6B,OAAO,6LAA6L,OAAO,2eAA2e,cAAc,qHAAqH,wBAAwB,gCAAgC,qCAAqC,yBAAyB,yBAAyB,sCAAsC,qNAAqN,EAAE,kDAAkD,gCAAgC,SAAS,6BAA6B,OAAO,4QAA4Q,OAAO,0eAA0e,cAAc,sHAAsH,wBAAwB,gCAAgC,qCAAqC,yBAAyB,sCAAsC,qNAAqN,EAAE,kDAAkD,yDAAyD,oBAAoB,qCAAqC,yDAAyD,aAAa,OAAO,2CAA2C,aAAa,yCAAyC,uBAAuB,WAAW,KAAK,SAAS,6BAA6B,OAAO,sGAAsG,MAAM,2HAA2H,OAAO,0VAA0V,iBAAiB,qDAAqD,gCAAgC,8DAA8D,gEAAgE,GAAG,OAAO,sLAAsL,OAAO,mDAAmD,YAAY,iFAAiF,uBAAuB,oBAAoB,OAAO,mLAAmL,OAAO,uDAAuD,YAAY,kFAAkF,wBAAwB,oBAAoB,OAAO,qJAAqJ,OAAO,2GAA2G,YAAY,6FAA6F,mCAAmC,wCAAwC,SAAS,mDAAmD,oBAAoB,OAAO,gHAAgH,+EAA+E,gCAAgC,SAAS,2DAA2D,oBAAoB,OAAO,yJAAyJ,OAAO,kGAAkG,YAAY,gGAAgG,gDAAgD,oBAAoB,OAAO,sJAAsJ,OAAO,qGAAqG,YAAY,8FAA8F,gDAAgD,oBAAoB,OAAO,yJAAyJ,OAAO,qGAAqG,YAAY,iGAAiG,gDAAgD,oBAAoB,OAAO,kKAAkK,OAAO,qGAAqG,YAAY,uGAAuG,iDAAiD,oBAAoB,OAAO,qKAAqK,OAAO,qGAAqG,YAAY,0GAA0G,iDAAiD,oBAAoB,OAAO,kKAAkK,OAAO,uCAAuC,MAAM,qDAAqD,YAAY,kGAAkG,iDAAiD,oBAAoB,OAAO,sKAAsK,OAAO,uCAAuC,MAAM,yDAAyD,YAAY,qGAAqG,kDAAkD,oBAAoB,OAAO,sKAAsK,OAAO,2EAA2E,MAAM,qDAAqD,YAAY,kGAAkG,kDAAkD,oBAAoB,OAAO,wGAAwG,OAAO,iDAAiD,YAAY,qFAAqF,mDAAmD,oBAAoB,OAAO,2GAA2G,OAAO,oDAAoD,YAAY,2FAA2F,oDAAoD,oBAAoB,OAAO,oMAAoM,OAAO,oEAAoE,OAAO,iEAAiE,YAAY,wGAAwG,mDAAmD,yBAAyB,kBAAkB,EAAE,kNAAkN,kBAAkB,EAAE,8BAA8B,kBAAkB,EAAE,8CAA8C,2DAA2D,SAAS,oBAAoB,OAAO,iIAAiI,OAAO,0GAA0G,YAAY,qDAAqD,YAAY,kGAAkG,uCAAuC,8CAA8C,yDAAyD,oBAAoB,OAAO,oIAAoI,OAAO,0GAA0G,YAAY,yDAAyD,YAAY,uGAAuG,uCAAuC,8CAA8C,4DAA4D,oBAAoB,OAAO,mKAAmK,OAAO,wGAAwG,OAAO,0HAA0H,YAAY,0CAA0C,YAAY,iHAAiH,uCAAuC,8CAA8C,wEAAwE,kCAAkC,EAAE,oBAAoB,OAAO,mKAAmK,OAAO,yGAAyG,OAAO,0HAA0H,YAAY,0CAA0C,YAAY,sHAAsH,uCAAuC,8CAA8C,4EAA4E,kCAAkC,EAAE,oBAAoB,OAAO,wGAAwG,MAAM,0BAA0B,YAAY,2FAA2F,oDAAoD,kCAAkC,SAAS,EAAE,sCAAsC,oBAAoB,OAAO,oNAAoN,qFAAqF,OAAO,8JAA8J,OAAO,oEAAoE,OAAO,uEAAuE,YAAY,8FAA8F,gEAAgE,oBAAoB,OAAO,uNAAuN,OAAO,oEAAoE,OAAO,uEAAuE,YAAY,gGAAgG,wEAAwE,oBAAoB,OAAO,gKAAgK,OAAO,oEAAoE,OAAO,qEAAqE,YAAY,8FAA8F,wEAAwE,oBAAoB,OAAO,qGAAqG,2BAA2B,wIAAwI,YAAY,qFAAqF,yBAAyB,wDAAwD,OAAO,sLAAsL,2BAA2B,uIAAuI,YAAY,2FAA2F,wBAAwB,4BAA4B,2BAA2B,SAAS,mDAAmD,mCAAmC,6BAA6B,WAAW,mFAAmF,SAAS,EAAE,oBAAoB,OAAO,sGAAsG,2BAA2B,uIAAuI,YAAY,yFAAyF,yBAAyB,yDAAyD,OAAO,sLAAsL,2BAA2B,uIAAuI,YAAY,4FAA4F,wBAAwB,4BAA4B,2BAA2B,SAAS,mDAAmD,mCAAmC,6BAA6B,WAAW,gIAAgI,kBAAkB,EAAE,GAAG,SAAS,EAAE,oBAAoB,OAAO,8IAA8I,OAAO,mEAAmE,eAAe,mEAAmE,YAAY,0FAA0F,iDAAiD,4HAA4H,SAAS,wDAAwD,oBAAoB,OAAO,oLAAoL,OAAO,mEAAmE,eAAe,kEAAkE,OAAO,4FAA4F,YAAY,6GAA6G,8BAA8B,4DAA4D,oBAAoB,OAAO,kOAAkO,OAAO,mEAAmE,eAAe,kEAAkE,OAAO,4FAA4F,YAAY,2GAA2G,iEAAiE,OAAO,uOAAuO,OAAO,mEAAmE,eAAe,kEAAkE,OAAO,iGAAiG,YAAY,gHAAgH,iEAAiE,OAAO,iMAAiM,OAAO,gDAAgD,eAAe,mFAAmF,eAAe,qFAAqF,YAAY,iHAAiH,qDAAqD,oDAAoD,SAAS,qDAAqD,oDAAoD,SAAS,4CAA4C,iCAAiC,EAAE,oBAAoB,OAAO,2LAA2L,OAAO,sDAAsD,YAAY,mFAAmF,wBAAwB,mDAAmD,+BAA+B,sDAAsD,WAAW,OAAO,oCAAoC,WAAW,SAAS,EAAE,oBAAoB,OAAO,mPAAmP,MAAM,yDAAyD,YAAY,kFAAkF,wBAAwB,0CAA0C,mDAAmD,+BAA+B,oDAAoD,WAAW,OAAO,mCAAmC,WAAW,SAAS,EAAE,oBAAoB,OAAO,2cAA2c,SAAS,kGAAkG,OAAO,kLAAkL,cAAc,iIAAiI,gCAAgC,gEAAgE,0FAA0F,uEAAuE,SAAS,4CAA4C,wDAAwD,mKAAmK,4CAA4C,gDAAgD,2BAA2B,gDAAgD,SAAS,sCAAsC,+BAA+B,+CAA+C,0DAA0D,SAAS,6CAA6C,0DAA0D,SAAS,+BAA+B,wDAAwD,2BAA2B,WAAW,cAAc,iEAAiE,mDAAmD,oDAAoD,6DAA6D,wCAAwC,eAAe,EAAE,aAAa,EAAE,oDAAoD,mDAAmD,gFAAgF,eAAe,OAAO,gCAAgC,eAAe,aAAa,EAAE,WAAW,EAAE,SAAS,6BAA6B,OAAO,MAAM,KAAK,QAAQ,4DAA4D,kCAAkC,2BAA2B,oBAAoB,6BAA6B,8BAA8B,6BAA6B,oBAAoB,oBAAoB,uCAAuC,wBAAwB,qCAAqC,sCAAsC,kCAAkC,qCAAqC,sQAAsQ,EAAE,aAAa,WAAW,OAAO,gCAAgC,4CAA4C,aAAa,WAAW,SAAS,GAAG,8CAA8C,EAAE,OAAO,kDAAkD,uBAAuB,8BAA8B,uNAAuN,gDAAgD,iDAAiD,qGAAqG,qWAAqW,iGAAiG,wBAAwB,WAAW,gCAAgC,SAAS,oBAAoB,OAAO,gCAAgC,4BAA4B,OAAO,mCAAmC,yCAAyC,OAAO,MAAM,8LAA8L,4aAA4a,OAAO,uaAAua,yCAAyC,oFAAoF,SAAS,8CAA8C,sEAAsE,kEAAkE,oSAAoS,SAAS,mCAAmC,6BAA6B,6DAA6D,2BAA2B,OAAO,0GAA0G,WAAW,iHAAiH,QAAQ,yHAAyH,4CAA4C,OAAO,+PAA+P,eAAe,yTAAyT,OAAO,mIAAmI,sDAAsD,6BAA6B,8EAA8E,WAAW,6CAA6C,8DAA8D,SAAS,OAAO,kDAAkD,4CAA4C,iEAAiE,SAAS,OAAO,mOAAmO,WAAW,2FAA2F,eAAe,0TAA0T,OAAO,wIAAwI,sDAAsD,6BAA6B,6EAA6E,WAAW,6CAA6C,uDAAuD,SAAS,OAAO,kDAAkD,4CAA4C,0DAA0D,SAAS,OAAO,+FAA+F,WAAW,+FAA+F,OAAO,6HAA6H,2BAA2B,6EAA6E,SAAS,uDAAuD,OAAO,MAAM,OAAO,QAAQ,6FAA6F,kCAAkC,2BAA2B,oBAAoB,21BAA21B,yBAAyB,kCAAkC,MAAM,iGAAiG,6EAA6E,yFAAyF,gLAAgL,qTAAqT,6EAA6E,6CAA6C,qCAAqC,OAAO,yKAAyK,iDAAiD,qDAAqD,gDAAgD,gDAAgD,yBAAyB,iCAAiC,aAAa,WAAW,OAAO,sCAAsC,WAAW,SAAS,mDAAmD,+DAA+D,SAAS,mDAAmD,OAAO,2LAA2L,oCAAoC,sEAAsE,SAAS,qCAAqC,8JAA8J,GAAG,UAAU,yBAAyB,kEAAkE,wDAAwD,qKAAqK,0CAA0C,4CAA4C,2HAA2H,sBAAsB,oJAAoJ,kCAAkC,SAAS,4LAA4L,0DAA0D,SAAS,8GAA8G,4DAA4D,SAAS,kCAAkC,yIAAyI,SAAS,4JAA4J,kCAAkC,yDAAyD,yRAAyR,uDAAuD,2EAA2E,4FAA4F,gKAAgK,oIAAoI,oEAAoE,wCAAwC,mGAAmG,SAAS,qCAAqC,gCAAgC,SAAS,OAAO,+JAA+J,qHAAqH,qDAAqD,sCAAsC,OAAO,gKAAgK,+BAA+B,iCAAiC,EAAE,OAAO,uKAAuK,yCAAyC,uDAAuD,gEAAgE,SAAS,wCAAwC,uBAAuB,SAAS,0BAA0B,iCAAiC,SAAS,8BAA8B,uCAAuC,SAAS,OAAO,8NAA8N,0EAA0E,8DAA8D,6CAA6C,uCAAuC,wBAAwB,WAAW,SAAS,EAAE,uBAAuB,OAAO,ofAAof,qCAAqC,uBAAuB,SAAS,2CAA2C,qBAAqB,kBAAkB,SAAS,+DAA+D,qCAAqC,iBAAiB,SAAS,qHAAqH,sDAAsD,4CAA4C,WAAW,+BAA+B,6EAA6E,0CAA0C,wBAAwB,4HAA4H,kCAAkC,+BAA+B,mEAAmE,mGAAmG,yNAAyN,kDAAkD,aAAa,0EAA0E,WAAW,4JAA4J,OAAO,+DAA+D,SAAS,8BAA8B,iCAAiC,SAAS,OAAO,uLAAuL,sBAAsB,wEAAwE,+CAA+C,SAAS,OAAO,mCAAmC,SAAS,OAAO,KAAK,EAAE,GAAG,QAAQ,0CAA0C,kCAAkC,2BAA2B,oBAAoB,2fAA2f,8BAA8B,2BAA2B,qCAAqC,OAAO,yBAAyB,6CAA6C,MAAM,8IAA8I,mCAAmC,qCAAqC,2BAA2B,6KAA6K,8JAA8J,2KAA2K,gCAAgC,EAAE,6DAA6D,6DAA6D,iCAAiC,6CAA6C,SAAS,yBAAyB,gCAAgC,SAAS,8DAA8D,8DAA8D,yBAAyB,uCAAuC,WAAW,mEAAmE,2DAA2D,SAAS,SAAS,oBAAoB,OAAO,iaAAia,kDAAkD,OAAO,uPAAuP,2BAA2B,kBAAkB,SAAS,wBAAwB,wCAAwC,kDAAkD,wDAAwD,WAAW,SAAS,0CAA0C,OAAO,OAAO,qEAAqE,SAAS,OAAO,qKAAqK,8JAA8J,6CAA6C,OAAO,qKAAqK,6CAA6C,OAAO,KAAK,EAAE,wCAAwC,OAAO,iEAAiE,OAAO,2DAA2D,MAAM,4FAA4F,GAAG,QAAQ,mBAAmB,kCAAkC,2BAA2B,oBAAoB,oSAAoS,uDAAuD,oEAAoE,OAAO,yCAAyC,OAAO,oEAAoE,OAAO,qVAAqV,cAAc,4HAA4H,gCAAgC,wCAAwC,oOAAoO,EAAE,8CAA8C,kDAAkD,SAAS,6BAA6B,OAAO,KAAK,EAAE,GAAG,QAAQ,qBAAqB,kCAAkC,2BAA2B,kEAAkE,8IAA8I,yDAAyD,OAAO,4mBAA4mB,OAAO,kPAAkP,cAAc,6HAA6H,8BAA8B,yBAAyB,+CAA+C,OAAO,6BAA6B,iDAAiD,OAAO,mCAAmC,6DAA6D,OAAO,+DAA+D,4EAA4E,OAAO,sCAAsC,iHAAiH,EAAE,gDAAgD,MAAM,GAAG,QAAQ,G;;;;;;ACAp5zT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,iEAAgE;;AAEhE;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,4BAA2B;AAC3B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,oDAAmD,qBAAqB,YAAY,EAAE,EAAE;;AAExF;AACA;AACA;AACA,oBAAmB;AACnB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAQ,qDAAqD;AAC7D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,IAAG;;AAEH;AACA;AACA,4CAA2C,IAAI;AAC/C;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,0FAAyF,IAAI;AAC7F,+FAA8F,IAAI;AAClG,2FAA0F,IAAI;AAC9F,gGAA+F,IAAI;AACnG,0FAAyF,IAAI;AAC7F,+FAA8F,IAAI;AAClG,2FAA0F,IAAI;AAC9F,gGAA+F,IAAI;AACnG,4FAA2F,IAAI;AAC/F,MAAK;;AAEL;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL,cAAa;;AAEb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,oDAAmD;AACnD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;;AAEA;AACA;AACA,mDAAkD,eAAe;AACjE;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,4CAA2C,QAAQ;AACnD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX,UAAS;AACT,QAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAO;;AAEP;AACA;AACA,QAAO;;AAEP;AACA;AACA,QAAO;;AAEP;AACA;AACA,QAAO;;AAEP;AACA;AACA,QAAO;;AAEP;AACA;AACA,QAAO;;AAEP;AACA;AACA,QAAO;;AAEP;AACA;AACA,QAAO;;AAEP;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;;AAEA,EAAC;;;;;;;;ACptBD,qEAAsB;AACtB;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB;AACzB,4BAA2B;AAC3B,2BAA0B;AAC1B,4BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,cAAa;AACb;AACA,8CAA6C,UAAU,GAAG,wCAAwC;AAClG;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAe;AACf;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAwF;AACxF;AACA;AACA,QAAO;;AAEP;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA,kCAAiC;AACjC;AACA,UAAS;AACT;;AAEA;AACA;AACA,QAAO;AACP;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,+BAA8B;;AAE9B;AACA;AACA;AACA,UAAS;;AAET;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;;AAEA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAe;AACf;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,YAAW;;AAEX;AACA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,gCAA+B;;AAE/B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA,0CAAyC,gCAAgC;AACzE;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gEAA+D;;AAE/D;AACA;AACA;AACA,YAAW;;AAEX;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe;AACf;AACA,YAAW;AACX;;AAEA;AACA;AACA,0BAAyB;;AAEzB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe;AACf;AACA,YAAW;AACX;;AAEA,wCAAuC,YAAY;AACnD;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAe;AACf;AACA,YAAW;AACX;;AAEA;AACA,0BAAyB;;AAEzB;AACA;AACA;AACA;AACA;AACA,gBAAe;AACf;AACA,YAAW;AACX;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;;AAEA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA,yCAAwC;AACxC,yCAAwC;AACxC,yCAAwC;AACxC,yCAAwC;AACxC,yCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 003e0cdf789e12458531\n **/","/** @jsx React.DOM */var $ = require('jquery');\nwindow.$ = window.jQuery = $;\nvar FastClick = require('fastclick');\nrequire('foundation/foundation');\nrequire('foundation/foundation.reveal');\nrequire('hw-parallax/src/hw-parallax');\n\nFastClick.attach(document.body);\n$(document).foundation();\n\n// Parallax\nif (!Modernizr.touch) {\n  $('.intro-section,.schedule').parallax({\n    scroll_factor: 0.5\n  });\n  $('.instructor__heading').parallax({\n    scroll_factor: 0.2\n  });\n\n  $('.od-parallax').parallax({\n    scroll_factor: 0.3\n  });\n}\n\nvar $body = $(document.body);\n$body.on('click', '.course-curriculum__header', function() {\n\n  // since the accordion is \"css-only\", this enables clearing the radio button if current box is open\n  var $for = $('#' + $(this).attr('for'));\n  if ($for.length && $for.prop('checked')) {\n    setTimeout(function() {$for.prop('checked', false);}, 0);\n  }\n  else {\n    // the accordion is being expanded, send a GA event\n    var unitName = $(this).find('.course-curriculum__unit-name').text();\n    window.ga && ga('send', 'event', 'curriculum', 'expand unit', unitName);\n  }\n\n  // re-draw parallax because page height has changed\n  setTimeout(function() {$(window).trigger('hwparallax.reconfigure');}, 0);\n});\n\n$body.on('click', '.faq-list__header', function() {\n  // since the accordion is \"css-only\", this enables clearing the radio button if current box is open\n  var $for = $('#' + $(this).attr('for'));\n  if ($for.length && $for.prop('checked')) {\n    setTimeout(function() {$for.prop('checked', false);}, 0);\n  }\n  else {\n    // the accordion is being expanded, send a GA event\n    var questionText = $(this).find('.faq-list__header').text();\n    window.ga && ga('send', 'event', 'faq', 'expand question', questionText);\n  }\n\n  // re-draw parallax because page height has changed\n  setTimeout(function() {$(window).trigger('hwparallax.reconfigure');}, 0);\n});\n\n// Application form\nrequire('script-loader!parse');\nvar applicationFormValidator = require('parse-common/app-form-validator');\nParse.initialize('fyWcoNIpRkC4Tc18XJqHUKNFXoDkhTZqF1ceJeFS', 'IYowp9G78uLzKdnviez6NMtIJ4tx28ocqFcYJ0nW');\n\n$('.application-form__send-button').on('click', function() {\n  // Send a GA event for attempting to submit\n  window.ga && ga('send', 'event', 'application form', 'submit attempt');\n  \n  // Gather all keys/values from the form\n  var values = $('.application-form__form')\n    .serializeArray()\n    .reduce(\n      function(carry, current) {\n        carry[current.name] = current.value;\n        return carry;\n      }, {}\n    );\n  // Validate\n  var errors = applicationFormValidator(values);\n  var errorKeys = Object.keys(errors);\n  if (errorKeys.length) {\n    // Has errors, alert about them\n    var errorValues = errorKeys.map(function(key) {return errors[key]});\n    alert(errorValues.join(\"\\r\\n\"));\n    \n    // Send GA event with errors\n    window.ga && ga('send', 'event', 'application form', 'submit errors', errorValues.join(','));\n  }\n  else {\n    // No errors, submit!\n    $('#application-form').addClass('application-form--submitting');\n    Parse.Cloud.run('sendApplication', {values: values}).then(\n      function() {\n        alert('Your application was submitted successfully!');\n        $('#application-form').removeClass('application-form--submitting').foundation('reveal', 'close');\n        \n        // Send GA event for parse submit success\n        window.ga && ga('send', 'event', 'application form', 'submit to parse success');\n      },\n      function(error) {\n        var errorMessage = error && error.error || 'Unknown error';\n        alert(\"An error occurred while submitting your application:\\r\\n\\r\\n\" + errorMessage);\n        $('#application-form').removeClass('application-form--submitting');\n        \n        // Send GA event for parse submit error\n        window.ga && ga('send', 'event', 'application form', 'submit to parse error', errorMessage);\n      }\n    );\n    \n    // Send GA event for parse submit attempt\n    window.ga && ga('send', 'event', 'application form', 'submit to parse attempt');\n  }\n});\n\n// Send an event after 30 seconds to prevent inaccurate bounce rate\nsetTimeout(function() {\n  window.ga && ga('send', 'event', 'activity', 'user spent 30 seconds on page');\n}, 30 * 1000);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/assets/js/app.js\n ** module id = 0\n ** module chunks = 0\n **/","/** @jsx React.DOM */module.exports = function(values) {\n  if (!values) {\n    return false;\n  }\n  \n  var errors = {};\n  var required = {\n    firstName: 'First name',\n    lastName: 'Last name',\n    emailAddress: 'Email address',\n    phoneNumber: 'Phone number',\n    applyingTo: 'Applying to',\n    leadSource: 'How you heard about us',\n    whyApplying: 'Why are you applying',\n    education: 'Education background',\n    hobbies: 'Hobbies and passions',\n    plans: 'Plans',\n    codingBackground: 'Coding background'\n  };\n  \n  Object.keys(required).forEach(function(key) {\n    if (!values[key]) {\n      errors[key] = required[key] + ' is required';\n    }\n  });\n  \n  return errors;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./parse/cloud/parse-common/app-form-validator.js\n ** module id = 1\n ** module chunks = 0\n **/","/** @jsx React.DOM *//*\n Copyright (C) 2013 Ziad Saab ziad(dot)saab(at)gmail(dot)com\n\n Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\n documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation\n the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE\n WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS\n OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n;(function($) {\n  var ParallaxManager = function(options) {\n    this.options = options;\n    this.vendor_prefixes = ['webkit', 'moz', 'o', 'ms'];\n    this.num_vendor_prefixes = this.vendor_prefixes.length;\n\n    // Function used to detect support for a certain CSS style\n    var thisBrowserSupportsStyle = function(style) {\n      var vendors = ['Webkit', 'Moz', 'ms', 'O'];\n      var num_vendors = vendors.length;\n      var dummy_el = window.document.createElement('parallax');\n\n      // First test the bare style without prefix\n      if (dummy_el.style[style] !== undefined) {\n        return true;\n      }\n\n      // Test the camel-cased vendor-prefixed styles\n      style = style.replace(/./, function(first) {return first.toUpperCase();});\n      for (var i = 0; i < num_vendors; i++) {\n        var pfx_style = vendors[i] + style;\n        // The browser will return an empty string if a style is supported but not present, and undefined if the style is not supported\n        if (dummy_el.style[pfx_style] !== undefined) {\n          return true;\n        }\n      }\n      return false;\n    };\n\n    // Detect if we have 2d or 3d transforms by checking for support of the transform (2d) and perspective (3d) styles\n    this.has_3dtransforms = thisBrowserSupportsStyle('perspective');\n    // Additional test due to false positives returned with WebKit on some browsers: they support perspective but can't do 3d transforms\n    if (this.has_3dtransforms && thisBrowserSupportsStyle('WebkitPerspective')) {\n      var $test_el = $('<div><style type=\"text/css\">@media (transform-3d),(-webkit-transform-3d) {#parallax-3dtest {position: absolute;left: 9px;height: 5px;margin: 0;padding: 0;border: 0;}</style><div id=\"parallax-3dtest\"></div></div>').appendTo('body');\n      var $el = $('#parallax-3dtest');\n      this.has_3dtransforms = $el.height() == 5 && $el.offset().left == 9;\n      $test_el.remove();\n    }\n    this.has_2dtransforms = thisBrowserSupportsStyle('transform');\n  };\n\n  // Define \"methods\" on the ParallaxManager class\n  $.extend(ParallaxManager.prototype, {\n    init: function() {\n      this.scroll_factor = this.options.scroll_factor;\n      var parallax_blocks = this.parallax_blocks = [];\n      var image_attr = this.options.image_attr\n\n      var $body = $('body');\n      var $origins = this.options.origins;\n      $origins.each(function() {\n        var $origin = $(this);\n        var $parallax_block;\n        if ($origin.data(image_attr)) {\n          $parallax_block = $('<div class=\"parallax-block\"><img class=\"parallax-image\" src=\"' + $origin.data(image_attr) + '\"></div>');\n          parallax_blocks.push({\n            origin: $origin,\n            block: $parallax_block,\n            bg_ratio: $origin.data('width') / $origin.data('height')\n          });\n          $body.prepend($parallax_block);\n        }\n        else if ($origin.data('tile')) {\n          $parallax_block = $('<div class=\"parallax-block\"><div class=\"parallax-image\" style=\"background-image: url(' + $origin.data('tile') + ')\"></div></div>')\n          parallax_blocks.push({\n            origin: $origin,\n            block: $parallax_block,\n            bg_ratio: 1\n          });\n          $body.prepend($parallax_block);\n        }\n      });\n\n      var manager = this;\n      var reconfigure = function() {\n        manager.redrawBlocks();\n        manager.render();\n      };\n      var $window = $(window);\n      $window.on('load', reconfigure);\n      $window.on('resize', reconfigure);\n      $window.on('hwparallax.reconfigure', reconfigure);\n      $window.on('scroll', function() {manager.render();});\n    },\n    redrawBlocks: function() {\n      var window_width = $(window).width();\n      var window_height = this.window_height = $(window).height();\n\n      // Calculate document height to fix Chrome issue when scrolling past the content...\n      var body = document.body;\n      var html = document.documentElement;\n\n      var document_height = Math.max( body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight);\n      this.max_scrolltop = Math.max(0, document_height - window_height);\n\n      var num_parallax_blocks = this.parallax_blocks.length;\n      for (var i = 0; i < num_parallax_blocks; i++) {\n        var parallax_block_data = this.parallax_blocks[i];\n        var $parallax_block = parallax_block_data.block;\n        var bg_ratio = parallax_block_data.bg_ratio;\n        var $parallax_image = $parallax_block.children('.parallax-image');\n        var $origin = parallax_block_data.origin;\n\n        // Calculate the minimum background image height so that we may scroll by the scroll factor and keep the image in the bounds of its container\n        var origin_height = $origin.outerHeight();\n        var min_height = window_height - ((window_height - origin_height) * this.scroll_factor);\n\n        // Calculate the size of the parallax background image so that it covers the target block while still respecting the previously calculated minimum height\n        // Also, if the image's width is larger than the window's, center it about its parent element\n        var img_width = window_width;\n        var img_height = Math.ceil(img_width / bg_ratio);\n        var img_xoff = 0;\n        if (img_height < min_height) {\n          img_height = min_height;\n          img_width = img_height * bg_ratio;\n          img_xoff = Math.floor(img_width - window_width) / 2;\n        }\n        $parallax_image.width(img_width).height(img_height);\n\n        // Set the dimensions of the parallax block and hide it\n        $parallax_block.width(window_width).height(origin_height).css('visibility', 'hidden');\n\n        // Cache some data about the parallax block so that we don't have to recalculate it on every tick\n        // This data potentially changes, only changes when the window is resized\n        $.extend(parallax_block_data, {\n          origin_position: $origin.offset().top,\n          origin_height: origin_height,\n          image: $parallax_image,\n          image_xoff: img_xoff,\n          image_height: img_height\n        });\n      }\n    },\n    render: function() {\n      if (!this.drawing) {\n        this.drawing = true;\n        var manager = this;\n        if (window.requestAnimationFrame) {\n          window.requestAnimationFrame(function() {manager.draw();}, document);\n        }\n        else {\n          manager.draw();\n        }\n      }\n    },\n    draw: function() {\n      var scroll_top = Math.min(Math.max(0, $(window).scrollTop()), this.max_scrolltop);\n\n      // Loop thru all the parallax blocks\n      var num_blocks = this.parallax_blocks.length;\n      var data;\n      for (var i = 0; i < num_blocks; i++) {\n        data = this.parallax_blocks[i];\n        // Determine if parallax block is in view\n        // i.e. its bottom is below the window's upper bound and its top is above the window's lower bound\n        if (data.origin_position < scroll_top + this.window_height && data.origin_position + data.origin_height > scroll_top) {\n          // The block's y position in its fixed plane is the position of the original block relative to the top of the window\n          var new_block_position = data.origin_position - scroll_top;\n          // The background image's position is parallaxed to follow the block by the scroll factor\n          var new_image_position = new_block_position * (this.scroll_factor - 1);\n\n          // Apply the translations to block and image using the best method possible: 3d transform, 2d transform or regular top/left\n          var block_styles = {\n            visibility: 'visible'\n          };\n          var image_styles = {};\n          var block_transform, image_transform, prefixed_style;\n          var j;\n          if (this.has_3dtransforms) {\n            block_transform = block_styles.transform = 'translate3d(0px, ' + new_block_position + 'px, 0px)';\n            image_transform = image_styles.transform = 'translate3d(-' + data.image_xoff + 'px, ' + new_image_position + 'px, 0px)';\n            for (j = 0; j < this.num_vendor_prefixes; j++) {\n              prefixed_style = '-' + this.vendor_prefixes[j] + '-transform';\n              block_styles[prefixed_style] = block_transform;\n              image_styles[prefixed_style] = image_transform;\n            }\n          }\n          else if (this.has_2dtransforms) {\n            block_transform = block_styles.transform = 'translate(0px, ' + new_block_position + 'px)';\n            image_transform = image_styles.transform = 'translate(-' + data.image_xoff + 'px, ' + new_image_position + 'px)';\n            for (j = 0; j < this.num_vendor_prefixes; j++) {\n              prefixed_style = '-' + this.vendor_prefixes[j] + '-transform';\n              block_styles[prefixed_style] = block_transform;\n              image_styles[prefixed_style] = image_transform;\n            }\n          }\n          else {\n            block_styles.top = new_block_position + 'px';\n            block_styles.left = 0 + 'px';\n            image_styles.top = new_image_position + 'px';\n            image_styles.left = -data.image_xoff + 'px';\n          }\n          data.block.css(block_styles);\n          data.image.css(image_styles);\n        }\n        else {\n          data.block.css('visibility', 'hidden');\n        }\n      }\n      this.drawing = false;\n    }\n  });\n\n  // Hook into jQuery\n  $.extend($.fn, {\n    parallax: function(options) {\n      var settings = $.extend(\n          {\n            scroll_factor: 0.2,\n            image_attr: 'image'\n          },\n          options,\n          {\n            origins: $(this)\n          }\n      );\n      var pm = new ParallaxManager(settings);\n      pm.init();\n    }\n  });\n})(jQuery);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./bower_components/hw-parallax/src/hw-parallax.js\n ** module id = 2\n ** module chunks = 0\n **/","/** @jsx React.DOM *//*!\n * jQuery JavaScript Library v1.11.3\n * http://jquery.com/\n *\n * Includes Sizzle.js\n * http://sizzlejs.com/\n *\n * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2015-04-28T16:19Z\n */\n\n(function( global, factory ) {\n\n\tif ( typeof module === \"object\" && typeof module.exports === \"object\" ) {\n\t\t// For CommonJS and CommonJS-like environments where a proper window is present,\n\t\t// execute the factory and get jQuery\n\t\t// For environments that do not inherently posses a window with a document\n\t\t// (such as Node.js), expose a jQuery-making factory as module.exports\n\t\t// This accentuates the need for the creation of a real window\n\t\t// e.g. var jQuery = require(\"jquery\")(window);\n\t\t// See ticket #14549 for more info\n\t\tmodule.exports = global.document ?\n\t\t\tfactory( global, true ) :\n\t\t\tfunction( w ) {\n\t\t\t\tif ( !w.document ) {\n\t\t\t\t\tthrow new Error( \"jQuery requires a window with a document\" );\n\t\t\t\t}\n\t\t\t\treturn factory( w );\n\t\t\t};\n\t} else {\n\t\tfactory( global );\n\t}\n\n// Pass this if window is not defined yet\n}(typeof window !== \"undefined\" ? window : this, function( window, noGlobal ) {\n\n// Can't do this because several apps including ASP.NET trace\n// the stack via arguments.caller.callee and Firefox dies if\n// you try to trace through \"use strict\" call chains. (#13335)\n// Support: Firefox 18+\n//\n\nvar deletedIds = [];\n\nvar slice = deletedIds.slice;\n\nvar concat = deletedIds.concat;\n\nvar push = deletedIds.push;\n\nvar indexOf = deletedIds.indexOf;\n\nvar class2type = {};\n\nvar toString = class2type.toString;\n\nvar hasOwn = class2type.hasOwnProperty;\n\nvar support = {};\n\n\n\nvar\n\tversion = \"1.11.3\",\n\n\t// Define a local copy of jQuery\n\tjQuery = function( selector, context ) {\n\t\t// The jQuery object is actually just the init constructor 'enhanced'\n\t\t// Need init if jQuery is called (just allow error to be thrown if not included)\n\t\treturn new jQuery.fn.init( selector, context );\n\t},\n\n\t// Support: Android<4.1, IE<9\n\t// Make sure we trim BOM and NBSP\n\trtrim = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g,\n\n\t// Matches dashed string for camelizing\n\trmsPrefix = /^-ms-/,\n\trdashAlpha = /-([\\da-z])/gi,\n\n\t// Used by jQuery.camelCase as callback to replace()\n\tfcamelCase = function( all, letter ) {\n\t\treturn letter.toUpperCase();\n\t};\n\njQuery.fn = jQuery.prototype = {\n\t// The current version of jQuery being used\n\tjquery: version,\n\n\tconstructor: jQuery,\n\n\t// Start with an empty selector\n\tselector: \"\",\n\n\t// The default length of a jQuery object is 0\n\tlength: 0,\n\n\ttoArray: function() {\n\t\treturn slice.call( this );\n\t},\n\n\t// Get the Nth element in the matched element set OR\n\t// Get the whole matched element set as a clean array\n\tget: function( num ) {\n\t\treturn num != null ?\n\n\t\t\t// Return just the one element from the set\n\t\t\t( num < 0 ? this[ num + this.length ] : this[ num ] ) :\n\n\t\t\t// Return all the elements in a clean array\n\t\t\tslice.call( this );\n\t},\n\n\t// Take an array of elements and push it onto the stack\n\t// (returning the new matched element set)\n\tpushStack: function( elems ) {\n\n\t\t// Build a new jQuery matched element set\n\t\tvar ret = jQuery.merge( this.constructor(), elems );\n\n\t\t// Add the old object onto the stack (as a reference)\n\t\tret.prevObject = this;\n\t\tret.context = this.context;\n\n\t\t// Return the newly-formed element set\n\t\treturn ret;\n\t},\n\n\t// Execute a callback for every element in the matched set.\n\t// (You can seed the arguments with an array of args, but this is\n\t// only used internally.)\n\teach: function( callback, args ) {\n\t\treturn jQuery.each( this, callback, args );\n\t},\n\n\tmap: function( callback ) {\n\t\treturn this.pushStack( jQuery.map(this, function( elem, i ) {\n\t\t\treturn callback.call( elem, i, elem );\n\t\t}));\n\t},\n\n\tslice: function() {\n\t\treturn this.pushStack( slice.apply( this, arguments ) );\n\t},\n\n\tfirst: function() {\n\t\treturn this.eq( 0 );\n\t},\n\n\tlast: function() {\n\t\treturn this.eq( -1 );\n\t},\n\n\teq: function( i ) {\n\t\tvar len = this.length,\n\t\t\tj = +i + ( i < 0 ? len : 0 );\n\t\treturn this.pushStack( j >= 0 && j < len ? [ this[j] ] : [] );\n\t},\n\n\tend: function() {\n\t\treturn this.prevObject || this.constructor(null);\n\t},\n\n\t// For internal use only.\n\t// Behaves like an Array's method, not like a jQuery method.\n\tpush: push,\n\tsort: deletedIds.sort,\n\tsplice: deletedIds.splice\n};\n\njQuery.extend = jQuery.fn.extend = function() {\n\tvar src, copyIsArray, copy, name, options, clone,\n\t\ttarget = arguments[0] || {},\n\t\ti = 1,\n\t\tlength = arguments.length,\n\t\tdeep = false;\n\n\t// Handle a deep copy situation\n\tif ( typeof target === \"boolean\" ) {\n\t\tdeep = target;\n\n\t\t// skip the boolean and the target\n\t\ttarget = arguments[ i ] || {};\n\t\ti++;\n\t}\n\n\t// Handle case when target is a string or something (possible in deep copy)\n\tif ( typeof target !== \"object\" && !jQuery.isFunction(target) ) {\n\t\ttarget = {};\n\t}\n\n\t// extend jQuery itself if only one argument is passed\n\tif ( i === length ) {\n\t\ttarget = this;\n\t\ti--;\n\t}\n\n\tfor ( ; i < length; i++ ) {\n\t\t// Only deal with non-null/undefined values\n\t\tif ( (options = arguments[ i ]) != null ) {\n\t\t\t// Extend the base object\n\t\t\tfor ( name in options ) {\n\t\t\t\tsrc = target[ name ];\n\t\t\t\tcopy = options[ name ];\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif ( target === copy ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\tif ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {\n\t\t\t\t\tif ( copyIsArray ) {\n\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\tclone = src && jQuery.isArray(src) ? src : [];\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tclone = src && jQuery.isPlainObject(src) ? src : {};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\ttarget[ name ] = jQuery.extend( deep, clone, copy );\n\n\t\t\t\t// Don't bring in undefined values\n\t\t\t\t} else if ( copy !== undefined ) {\n\t\t\t\t\ttarget[ name ] = copy;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n\njQuery.extend({\n\t// Unique for each copy of jQuery on the page\n\texpando: \"jQuery\" + ( version + Math.random() ).replace( /\\D/g, \"\" ),\n\n\t// Assume jQuery is ready without the ready module\n\tisReady: true,\n\n\terror: function( msg ) {\n\t\tthrow new Error( msg );\n\t},\n\n\tnoop: function() {},\n\n\t// See test/unit/core.js for details concerning isFunction.\n\t// Since version 1.3, DOM methods and functions like alert\n\t// aren't supported. They return false on IE (#2968).\n\tisFunction: function( obj ) {\n\t\treturn jQuery.type(obj) === \"function\";\n\t},\n\n\tisArray: Array.isArray || function( obj ) {\n\t\treturn jQuery.type(obj) === \"array\";\n\t},\n\n\tisWindow: function( obj ) {\n\t\t/* jshint eqeqeq: false */\n\t\treturn obj != null && obj == obj.window;\n\t},\n\n\tisNumeric: function( obj ) {\n\t\t// parseFloat NaNs numeric-cast false positives (null|true|false|\"\")\n\t\t// ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n\t\t// subtraction forces infinities to NaN\n\t\t// adding 1 corrects loss of precision from parseFloat (#15100)\n\t\treturn !jQuery.isArray( obj ) && (obj - parseFloat( obj ) + 1) >= 0;\n\t},\n\n\tisEmptyObject: function( obj ) {\n\t\tvar name;\n\t\tfor ( name in obj ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t},\n\n\tisPlainObject: function( obj ) {\n\t\tvar key;\n\n\t\t// Must be an Object.\n\t\t// Because of IE, we also have to check the presence of the constructor property.\n\t\t// Make sure that DOM nodes and window objects don't pass through, as well\n\t\tif ( !obj || jQuery.type(obj) !== \"object\" || obj.nodeType || jQuery.isWindow( obj ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\ttry {\n\t\t\t// Not own constructor property must be Object\n\t\t\tif ( obj.constructor &&\n\t\t\t\t!hasOwn.call(obj, \"constructor\") &&\n\t\t\t\t!hasOwn.call(obj.constructor.prototype, \"isPrototypeOf\") ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} catch ( e ) {\n\t\t\t// IE8,9 Will throw exceptions on certain host objects #9897\n\t\t\treturn false;\n\t\t}\n\n\t\t// Support: IE<9\n\t\t// Handle iteration over inherited properties before own properties.\n\t\tif ( support.ownLast ) {\n\t\t\tfor ( key in obj ) {\n\t\t\t\treturn hasOwn.call( obj, key );\n\t\t\t}\n\t\t}\n\n\t\t// Own properties are enumerated firstly, so to speed up,\n\t\t// if last one is own, then all properties are own.\n\t\tfor ( key in obj ) {}\n\n\t\treturn key === undefined || hasOwn.call( obj, key );\n\t},\n\n\ttype: function( obj ) {\n\t\tif ( obj == null ) {\n\t\t\treturn obj + \"\";\n\t\t}\n\t\treturn typeof obj === \"object\" || typeof obj === \"function\" ?\n\t\t\tclass2type[ toString.call(obj) ] || \"object\" :\n\t\t\ttypeof obj;\n\t},\n\n\t// Evaluates a script in a global context\n\t// Workarounds based on findings by Jim Driscoll\n\t// http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context\n\tglobalEval: function( data ) {\n\t\tif ( data && jQuery.trim( data ) ) {\n\t\t\t// We use execScript on Internet Explorer\n\t\t\t// We use an anonymous function so that context is window\n\t\t\t// rather than jQuery in Firefox\n\t\t\t( window.execScript || function( data ) {\n\t\t\t\twindow[ \"eval\" ].call( window, data );\n\t\t\t} )( data );\n\t\t}\n\t},\n\n\t// Convert dashed to camelCase; used by the css and data modules\n\t// Microsoft forgot to hump their vendor prefix (#9572)\n\tcamelCase: function( string ) {\n\t\treturn string.replace( rmsPrefix, \"ms-\" ).replace( rdashAlpha, fcamelCase );\n\t},\n\n\tnodeName: function( elem, name ) {\n\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\n\t},\n\n\t// args is for internal usage only\n\teach: function( obj, callback, args ) {\n\t\tvar value,\n\t\t\ti = 0,\n\t\t\tlength = obj.length,\n\t\t\tisArray = isArraylike( obj );\n\n\t\tif ( args ) {\n\t\t\tif ( isArray ) {\n\t\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\t\tvalue = callback.apply( obj[ i ], args );\n\n\t\t\t\t\tif ( value === false ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( i in obj ) {\n\t\t\t\t\tvalue = callback.apply( obj[ i ], args );\n\n\t\t\t\t\tif ( value === false ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t// A special, fast, case for the most common use of each\n\t\t} else {\n\t\t\tif ( isArray ) {\n\t\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\t\tvalue = callback.call( obj[ i ], i, obj[ i ] );\n\n\t\t\t\t\tif ( value === false ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( i in obj ) {\n\t\t\t\t\tvalue = callback.call( obj[ i ], i, obj[ i ] );\n\n\t\t\t\t\tif ( value === false ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn obj;\n\t},\n\n\t// Support: Android<4.1, IE<9\n\ttrim: function( text ) {\n\t\treturn text == null ?\n\t\t\t\"\" :\n\t\t\t( text + \"\" ).replace( rtrim, \"\" );\n\t},\n\n\t// results is for internal usage only\n\tmakeArray: function( arr, results ) {\n\t\tvar ret = results || [];\n\n\t\tif ( arr != null ) {\n\t\t\tif ( isArraylike( Object(arr) ) ) {\n\t\t\t\tjQuery.merge( ret,\n\t\t\t\t\ttypeof arr === \"string\" ?\n\t\t\t\t\t[ arr ] : arr\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tpush.call( ret, arr );\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tinArray: function( elem, arr, i ) {\n\t\tvar len;\n\n\t\tif ( arr ) {\n\t\t\tif ( indexOf ) {\n\t\t\t\treturn indexOf.call( arr, elem, i );\n\t\t\t}\n\n\t\t\tlen = arr.length;\n\t\t\ti = i ? i < 0 ? Math.max( 0, len + i ) : i : 0;\n\n\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\t// Skip accessing in sparse arrays\n\t\t\t\tif ( i in arr && arr[ i ] === elem ) {\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn -1;\n\t},\n\n\tmerge: function( first, second ) {\n\t\tvar len = +second.length,\n\t\t\tj = 0,\n\t\t\ti = first.length;\n\n\t\twhile ( j < len ) {\n\t\t\tfirst[ i++ ] = second[ j++ ];\n\t\t}\n\n\t\t// Support: IE<9\n\t\t// Workaround casting of .length to NaN on otherwise arraylike objects (e.g., NodeLists)\n\t\tif ( len !== len ) {\n\t\t\twhile ( second[j] !== undefined ) {\n\t\t\t\tfirst[ i++ ] = second[ j++ ];\n\t\t\t}\n\t\t}\n\n\t\tfirst.length = i;\n\n\t\treturn first;\n\t},\n\n\tgrep: function( elems, callback, invert ) {\n\t\tvar callbackInverse,\n\t\t\tmatches = [],\n\t\t\ti = 0,\n\t\t\tlength = elems.length,\n\t\t\tcallbackExpect = !invert;\n\n\t\t// Go through the array, only saving the items\n\t\t// that pass the validator function\n\t\tfor ( ; i < length; i++ ) {\n\t\t\tcallbackInverse = !callback( elems[ i ], i );\n\t\t\tif ( callbackInverse !== callbackExpect ) {\n\t\t\t\tmatches.push( elems[ i ] );\n\t\t\t}\n\t\t}\n\n\t\treturn matches;\n\t},\n\n\t// arg is for internal usage only\n\tmap: function( elems, callback, arg ) {\n\t\tvar value,\n\t\t\ti = 0,\n\t\t\tlength = elems.length,\n\t\t\tisArray = isArraylike( elems ),\n\t\t\tret = [];\n\n\t\t// Go through the array, translating each of the items to their new values\n\t\tif ( isArray ) {\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret.push( value );\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Go through every key on the object,\n\t\t} else {\n\t\t\tfor ( i in elems ) {\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret.push( value );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Flatten any nested arrays\n\t\treturn concat.apply( [], ret );\n\t},\n\n\t// A global GUID counter for objects\n\tguid: 1,\n\n\t// Bind a function to a context, optionally partially applying any\n\t// arguments.\n\tproxy: function( fn, context ) {\n\t\tvar args, proxy, tmp;\n\n\t\tif ( typeof context === \"string\" ) {\n\t\t\ttmp = fn[ context ];\n\t\t\tcontext = fn;\n\t\t\tfn = tmp;\n\t\t}\n\n\t\t// Quick check to determine if target is callable, in the spec\n\t\t// this throws a TypeError, but we will just return undefined.\n\t\tif ( !jQuery.isFunction( fn ) ) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Simulated bind\n\t\targs = slice.call( arguments, 2 );\n\t\tproxy = function() {\n\t\t\treturn fn.apply( context || this, args.concat( slice.call( arguments ) ) );\n\t\t};\n\n\t\t// Set the guid of unique handler to the same of original handler, so it can be removed\n\t\tproxy.guid = fn.guid = fn.guid || jQuery.guid++;\n\n\t\treturn proxy;\n\t},\n\n\tnow: function() {\n\t\treturn +( new Date() );\n\t},\n\n\t// jQuery.support is not used in Core but other projects attach their\n\t// properties to it so it needs to exist.\n\tsupport: support\n});\n\n// Populate the class2type map\njQuery.each(\"Boolean Number String Function Array Date RegExp Object Error\".split(\" \"), function(i, name) {\n\tclass2type[ \"[object \" + name + \"]\" ] = name.toLowerCase();\n});\n\nfunction isArraylike( obj ) {\n\n\t// Support: iOS 8.2 (not reproducible in simulator)\n\t// `in` check used to prevent JIT error (gh-2145)\n\t// hasOwn isn't used here due to false negatives\n\t// regarding Nodelist length in IE\n\tvar length = \"length\" in obj && obj.length,\n\t\ttype = jQuery.type( obj );\n\n\tif ( type === \"function\" || jQuery.isWindow( obj ) ) {\n\t\treturn false;\n\t}\n\n\tif ( obj.nodeType === 1 && length ) {\n\t\treturn true;\n\t}\n\n\treturn type === \"array\" || length === 0 ||\n\t\ttypeof length === \"number\" && length > 0 && ( length - 1 ) in obj;\n}\nvar Sizzle =\n/*!\n * Sizzle CSS Selector Engine v2.2.0-pre\n * http://sizzlejs.com/\n *\n * Copyright 2008, 2014 jQuery Foundation, Inc. and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2014-12-16\n */\n(function( window ) {\n\nvar i,\n\tsupport,\n\tExpr,\n\tgetText,\n\tisXML,\n\ttokenize,\n\tcompile,\n\tselect,\n\toutermostContext,\n\tsortInput,\n\thasDuplicate,\n\n\t// Local document vars\n\tsetDocument,\n\tdocument,\n\tdocElem,\n\tdocumentIsHTML,\n\trbuggyQSA,\n\trbuggyMatches,\n\tmatches,\n\tcontains,\n\n\t// Instance-specific data\n\texpando = \"sizzle\" + 1 * new Date(),\n\tpreferredDoc = window.document,\n\tdirruns = 0,\n\tdone = 0,\n\tclassCache = createCache(),\n\ttokenCache = createCache(),\n\tcompilerCache = createCache(),\n\tsortOrder = function( a, b ) {\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t}\n\t\treturn 0;\n\t},\n\n\t// General-purpose constants\n\tMAX_NEGATIVE = 1 << 31,\n\n\t// Instance methods\n\thasOwn = ({}).hasOwnProperty,\n\tarr = [],\n\tpop = arr.pop,\n\tpush_native = arr.push,\n\tpush = arr.push,\n\tslice = arr.slice,\n\t// Use a stripped-down indexOf as it's faster than native\n\t// http://jsperf.com/thor-indexof-vs-for/5\n\tindexOf = function( list, elem ) {\n\t\tvar i = 0,\n\t\t\tlen = list.length;\n\t\tfor ( ; i < len; i++ ) {\n\t\t\tif ( list[i] === elem ) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t},\n\n\tbooleans = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",\n\n\t// Regular expressions\n\n\t// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace\n\twhitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n\t// http://www.w3.org/TR/css3-syntax/#characters\n\tcharacterEncoding = \"(?:\\\\\\\\.|[\\\\w-]|[^\\\\x00-\\\\xa0])+\",\n\n\t// Loosely modeled on CSS identifier characters\n\t// An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors\n\t// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\n\tidentifier = characterEncoding.replace( \"w\", \"w#\" ),\n\n\t// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\n\tattributes = \"\\\\[\" + whitespace + \"*(\" + characterEncoding + \")(?:\" + whitespace +\n\t\t// Operator (capture 2)\n\t\t\"*([*^$|!~]?=)\" + whitespace +\n\t\t// \"Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]\"\n\t\t\"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\" + identifier + \"))|)\" + whitespace +\n\t\t\"*\\\\]\",\n\n\tpseudos = \":(\" + characterEncoding + \")(?:\\\\((\" +\n\t\t// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\n\t\t// 1. quoted (capture 3; capture 4 or capture 5)\n\t\t\"('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|\" +\n\t\t// 2. simple (capture 6)\n\t\t\"((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + attributes + \")*)|\" +\n\t\t// 3. anything else (capture 2)\n\t\t\".*\" +\n\t\t\")\\\\)|)\",\n\n\t// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n\trwhitespace = new RegExp( whitespace + \"+\", \"g\" ),\n\trtrim = new RegExp( \"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + whitespace + \"+$\", \"g\" ),\n\n\trcomma = new RegExp( \"^\" + whitespace + \"*,\" + whitespace + \"*\" ),\n\trcombinators = new RegExp( \"^\" + whitespace + \"*([>+~]|\" + whitespace + \")\" + whitespace + \"*\" ),\n\n\trattributeQuotes = new RegExp( \"=\" + whitespace + \"*([^\\\\]'\\\"]*?)\" + whitespace + \"*\\\\]\", \"g\" ),\n\n\trpseudo = new RegExp( pseudos ),\n\tridentifier = new RegExp( \"^\" + identifier + \"$\" ),\n\n\tmatchExpr = {\n\t\t\"ID\": new RegExp( \"^#(\" + characterEncoding + \")\" ),\n\t\t\"CLASS\": new RegExp( \"^\\\\.(\" + characterEncoding + \")\" ),\n\t\t\"TAG\": new RegExp( \"^(\" + characterEncoding.replace( \"w\", \"w*\" ) + \")\" ),\n\t\t\"ATTR\": new RegExp( \"^\" + attributes ),\n\t\t\"PSEUDO\": new RegExp( \"^\" + pseudos ),\n\t\t\"CHILD\": new RegExp( \"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" + whitespace +\n\t\t\t\"*(even|odd|(([+-]|)(\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" + whitespace +\n\t\t\t\"*(\\\\d+)|))\" + whitespace + \"*\\\\)|)\", \"i\" ),\n\t\t\"bool\": new RegExp( \"^(?:\" + booleans + \")$\", \"i\" ),\n\t\t// For use in libraries implementing .is()\n\t\t// We use this for POS matching in `select`\n\t\t\"needsContext\": new RegExp( \"^\" + whitespace + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" +\n\t\t\twhitespace + \"*((?:-\\\\d)?\\\\d*)\" + whitespace + \"*\\\\)|)(?=[^-]|$)\", \"i\" )\n\t},\n\n\trinputs = /^(?:input|select|textarea|button)$/i,\n\trheader = /^h\\d$/i,\n\n\trnative = /^[^{]+\\{\\s*\\[native \\w/,\n\n\t// Easily-parseable/retrievable ID or TAG or CLASS selectors\n\trquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n\n\trsibling = /[+~]/,\n\trescape = /'|\\\\/g,\n\n\t// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n\trunescape = new RegExp( \"\\\\\\\\([\\\\da-f]{1,6}\" + whitespace + \"?|(\" + whitespace + \")|.)\", \"ig\" ),\n\tfunescape = function( _, escaped, escapedWhitespace ) {\n\t\tvar high = \"0x\" + escaped - 0x10000;\n\t\t// NaN means non-codepoint\n\t\t// Support: Firefox<24\n\t\t// Workaround erroneous numeric interpretation of +\"0x\"\n\t\treturn high !== high || escapedWhitespace ?\n\t\t\tescaped :\n\t\t\thigh < 0 ?\n\t\t\t\t// BMP codepoint\n\t\t\t\tString.fromCharCode( high + 0x10000 ) :\n\t\t\t\t// Supplemental Plane codepoint (surrogate pair)\n\t\t\t\tString.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );\n\t},\n\n\t// Used for iframes\n\t// See setDocument()\n\t// Removing the function wrapper causes a \"Permission Denied\"\n\t// error in IE\n\tunloadHandler = function() {\n\t\tsetDocument();\n\t};\n\n// Optimize for push.apply( _, NodeList )\ntry {\n\tpush.apply(\n\t\t(arr = slice.call( preferredDoc.childNodes )),\n\t\tpreferredDoc.childNodes\n\t);\n\t// Support: Android<4.0\n\t// Detect silently failing push.apply\n\tarr[ preferredDoc.childNodes.length ].nodeType;\n} catch ( e ) {\n\tpush = { apply: arr.length ?\n\n\t\t// Leverage slice if possible\n\t\tfunction( target, els ) {\n\t\t\tpush_native.apply( target, slice.call(els) );\n\t\t} :\n\n\t\t// Support: IE<9\n\t\t// Otherwise append directly\n\t\tfunction( target, els ) {\n\t\t\tvar j = target.length,\n\t\t\t\ti = 0;\n\t\t\t// Can't trust NodeList.length\n\t\t\twhile ( (target[j++] = els[i++]) ) {}\n\t\t\ttarget.length = j - 1;\n\t\t}\n\t};\n}\n\nfunction Sizzle( selector, context, results, seed ) {\n\tvar match, elem, m, nodeType,\n\t\t// QSA vars\n\t\ti, groups, old, nid, newContext, newSelector;\n\n\tif ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {\n\t\tsetDocument( context );\n\t}\n\n\tcontext = context || document;\n\tresults = results || [];\n\tnodeType = context.nodeType;\n\n\tif ( typeof selector !== \"string\" || !selector ||\n\t\tnodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {\n\n\t\treturn results;\n\t}\n\n\tif ( !seed && documentIsHTML ) {\n\n\t\t// Try to shortcut find operations when possible (e.g., not under DocumentFragment)\n\t\tif ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {\n\t\t\t// Speed-up: Sizzle(\"#ID\")\n\t\t\tif ( (m = match[1]) ) {\n\t\t\t\tif ( nodeType === 9 ) {\n\t\t\t\t\telem = context.getElementById( m );\n\t\t\t\t\t// Check parentNode to catch when Blackberry 4.6 returns\n\t\t\t\t\t// nodes that are no longer in the document (jQuery #6963)\n\t\t\t\t\tif ( elem && elem.parentNode ) {\n\t\t\t\t\t\t// Handle the case where IE, Opera, and Webkit return items\n\t\t\t\t\t\t// by name instead of ID\n\t\t\t\t\t\tif ( elem.id === m ) {\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Context is not a document\n\t\t\t\t\tif ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&\n\t\t\t\t\t\tcontains( context, elem ) && elem.id === m ) {\n\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// Speed-up: Sizzle(\"TAG\")\n\t\t\t} else if ( match[2] ) {\n\t\t\t\tpush.apply( results, context.getElementsByTagName( selector ) );\n\t\t\t\treturn results;\n\n\t\t\t// Speed-up: Sizzle(\".CLASS\")\n\t\t\t} else if ( (m = match[3]) && support.getElementsByClassName ) {\n\t\t\t\tpush.apply( results, context.getElementsByClassName( m ) );\n\t\t\t\treturn results;\n\t\t\t}\n\t\t}\n\n\t\t// QSA path\n\t\tif ( support.qsa && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {\n\t\t\tnid = old = expando;\n\t\t\tnewContext = context;\n\t\t\tnewSelector = nodeType !== 1 && selector;\n\n\t\t\t// qSA works strangely on Element-rooted queries\n\t\t\t// We can work around this by specifying an extra ID on the root\n\t\t\t// and working up from there (Thanks to Andrew Dupont for the technique)\n\t\t\t// IE 8 doesn't work on object elements\n\t\t\tif ( nodeType === 1 && context.nodeName.toLowerCase() !== \"object\" ) {\n\t\t\t\tgroups = tokenize( selector );\n\n\t\t\t\tif ( (old = context.getAttribute(\"id\")) ) {\n\t\t\t\t\tnid = old.replace( rescape, \"\\\\$&\" );\n\t\t\t\t} else {\n\t\t\t\t\tcontext.setAttribute( \"id\", nid );\n\t\t\t\t}\n\t\t\t\tnid = \"[id='\" + nid + \"'] \";\n\n\t\t\t\ti = groups.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tgroups[i] = nid + toSelector( groups[i] );\n\t\t\t\t}\n\t\t\t\tnewContext = rsibling.test( selector ) && testContext( context.parentNode ) || context;\n\t\t\t\tnewSelector = groups.join(\",\");\n\t\t\t}\n\n\t\t\tif ( newSelector ) {\n\t\t\t\ttry {\n\t\t\t\t\tpush.apply( results,\n\t\t\t\t\t\tnewContext.querySelectorAll( newSelector )\n\t\t\t\t\t);\n\t\t\t\t\treturn results;\n\t\t\t\t} catch(qsaError) {\n\t\t\t\t} finally {\n\t\t\t\t\tif ( !old ) {\n\t\t\t\t\t\tcontext.removeAttribute(\"id\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// All others\n\treturn select( selector.replace( rtrim, \"$1\" ), context, results, seed );\n}\n\n/**\n * Create key-value caches of limited size\n * @returns {Function(string, Object)} Returns the Object data after storing it on itself with\n *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n *\tdeleting the oldest entry\n */\nfunction createCache() {\n\tvar keys = [];\n\n\tfunction cache( key, value ) {\n\t\t// Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\n\t\tif ( keys.push( key + \" \" ) > Expr.cacheLength ) {\n\t\t\t// Only keep the most recent entries\n\t\t\tdelete cache[ keys.shift() ];\n\t\t}\n\t\treturn (cache[ key + \" \" ] = value);\n\t}\n\treturn cache;\n}\n\n/**\n * Mark a function for special use by Sizzle\n * @param {Function} fn The function to mark\n */\nfunction markFunction( fn ) {\n\tfn[ expando ] = true;\n\treturn fn;\n}\n\n/**\n * Support testing using an element\n * @param {Function} fn Passed the created div and expects a boolean result\n */\nfunction assert( fn ) {\n\tvar div = document.createElement(\"div\");\n\n\ttry {\n\t\treturn !!fn( div );\n\t} catch (e) {\n\t\treturn false;\n\t} finally {\n\t\t// Remove from its parent by default\n\t\tif ( div.parentNode ) {\n\t\t\tdiv.parentNode.removeChild( div );\n\t\t}\n\t\t// release memory in IE\n\t\tdiv = null;\n\t}\n}\n\n/**\n * Adds the same handler for all of the specified attrs\n * @param {String} attrs Pipe-separated list of attributes\n * @param {Function} handler The method that will be applied\n */\nfunction addHandle( attrs, handler ) {\n\tvar arr = attrs.split(\"|\"),\n\t\ti = attrs.length;\n\n\twhile ( i-- ) {\n\t\tExpr.attrHandle[ arr[i] ] = handler;\n\t}\n}\n\n/**\n * Checks document order of two siblings\n * @param {Element} a\n * @param {Element} b\n * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\n */\nfunction siblingCheck( a, b ) {\n\tvar cur = b && a,\n\t\tdiff = cur && a.nodeType === 1 && b.nodeType === 1 &&\n\t\t\t( ~b.sourceIndex || MAX_NEGATIVE ) -\n\t\t\t( ~a.sourceIndex || MAX_NEGATIVE );\n\n\t// Use IE sourceIndex if available on both nodes\n\tif ( diff ) {\n\t\treturn diff;\n\t}\n\n\t// Check if b follows a\n\tif ( cur ) {\n\t\twhile ( (cur = cur.nextSibling) ) {\n\t\t\tif ( cur === b ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn a ? 1 : -1;\n}\n\n/**\n * Returns a function to use in pseudos for input types\n * @param {String} type\n */\nfunction createInputPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn name === \"input\" && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for buttons\n * @param {String} type\n */\nfunction createButtonPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn (name === \"input\" || name === \"button\") && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for positionals\n * @param {Function} fn\n */\nfunction createPositionalPseudo( fn ) {\n\treturn markFunction(function( argument ) {\n\t\targument = +argument;\n\t\treturn markFunction(function( seed, matches ) {\n\t\t\tvar j,\n\t\t\t\tmatchIndexes = fn( [], seed.length, argument ),\n\t\t\t\ti = matchIndexes.length;\n\n\t\t\t// Match elements found at the specified indexes\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( seed[ (j = matchIndexes[i]) ] ) {\n\t\t\t\t\tseed[j] = !(matches[j] = seed[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n}\n\n/**\n * Checks a node for validity as a Sizzle context\n * @param {Element|Object=} context\n * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\n */\nfunction testContext( context ) {\n\treturn context && typeof context.getElementsByTagName !== \"undefined\" && context;\n}\n\n// Expose support vars for convenience\nsupport = Sizzle.support = {};\n\n/**\n * Detects XML nodes\n * @param {Element|Object} elem An element or a document\n * @returns {Boolean} True iff elem is a non-HTML XML node\n */\nisXML = Sizzle.isXML = function( elem ) {\n\t// documentElement is verified for cases where it doesn't yet exist\n\t// (such as loading iframes in IE - #4833)\n\tvar documentElement = elem && (elem.ownerDocument || elem).documentElement;\n\treturn documentElement ? documentElement.nodeName !== \"HTML\" : false;\n};\n\n/**\n * Sets document-related variables once based on the current document\n * @param {Element|Object} [doc] An element or document object to use to set the document\n * @returns {Object} Returns the current document\n */\nsetDocument = Sizzle.setDocument = function( node ) {\n\tvar hasCompare, parent,\n\t\tdoc = node ? node.ownerDocument || node : preferredDoc;\n\n\t// If no document and documentElement is available, return\n\tif ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {\n\t\treturn document;\n\t}\n\n\t// Set our document\n\tdocument = doc;\n\tdocElem = doc.documentElement;\n\tparent = doc.defaultView;\n\n\t// Support: IE>8\n\t// If iframe document is assigned to \"document\" variable and if iframe has been reloaded,\n\t// IE will throw \"permission denied\" error when accessing \"document\" variable, see jQuery #13936\n\t// IE6-8 do not support the defaultView property so parent will be undefined\n\tif ( parent && parent !== parent.top ) {\n\t\t// IE11 does not have attachEvent, so all must suffer\n\t\tif ( parent.addEventListener ) {\n\t\t\tparent.addEventListener( \"unload\", unloadHandler, false );\n\t\t} else if ( parent.attachEvent ) {\n\t\t\tparent.attachEvent( \"onunload\", unloadHandler );\n\t\t}\n\t}\n\n\t/* Support tests\n\t---------------------------------------------------------------------- */\n\tdocumentIsHTML = !isXML( doc );\n\n\t/* Attributes\n\t---------------------------------------------------------------------- */\n\n\t// Support: IE<8\n\t// Verify that getAttribute really returns attributes and not properties\n\t// (excepting IE8 booleans)\n\tsupport.attributes = assert(function( div ) {\n\t\tdiv.className = \"i\";\n\t\treturn !div.getAttribute(\"className\");\n\t});\n\n\t/* getElement(s)By*\n\t---------------------------------------------------------------------- */\n\n\t// Check if getElementsByTagName(\"*\") returns only elements\n\tsupport.getElementsByTagName = assert(function( div ) {\n\t\tdiv.appendChild( doc.createComment(\"\") );\n\t\treturn !div.getElementsByTagName(\"*\").length;\n\t});\n\n\t// Support: IE<9\n\tsupport.getElementsByClassName = rnative.test( doc.getElementsByClassName );\n\n\t// Support: IE<10\n\t// Check if getElementById returns elements by name\n\t// The broken getElementById methods don't pick up programatically-set names,\n\t// so use a roundabout getElementsByName test\n\tsupport.getById = assert(function( div ) {\n\t\tdocElem.appendChild( div ).id = expando;\n\t\treturn !doc.getElementsByName || !doc.getElementsByName( expando ).length;\n\t});\n\n\t// ID find and filter\n\tif ( support.getById ) {\n\t\tExpr.find[\"ID\"] = function( id, context ) {\n\t\t\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\n\t\t\t\tvar m = context.getElementById( id );\n\t\t\t\t// Check parentNode to catch when Blackberry 4.6 returns\n\t\t\t\t// nodes that are no longer in the document #6963\n\t\t\t\treturn m && m.parentNode ? [ m ] : [];\n\t\t\t}\n\t\t};\n\t\tExpr.filter[\"ID\"] = function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn elem.getAttribute(\"id\") === attrId;\n\t\t\t};\n\t\t};\n\t} else {\n\t\t// Support: IE6/7\n\t\t// getElementById is not reliable as a find shortcut\n\t\tdelete Expr.find[\"ID\"];\n\n\t\tExpr.filter[\"ID\"] =  function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\tvar node = typeof elem.getAttributeNode !== \"undefined\" && elem.getAttributeNode(\"id\");\n\t\t\t\treturn node && node.value === attrId;\n\t\t\t};\n\t\t};\n\t}\n\n\t// Tag\n\tExpr.find[\"TAG\"] = support.getElementsByTagName ?\n\t\tfunction( tag, context ) {\n\t\t\tif ( typeof context.getElementsByTagName !== \"undefined\" ) {\n\t\t\t\treturn context.getElementsByTagName( tag );\n\n\t\t\t// DocumentFragment nodes don't have gEBTN\n\t\t\t} else if ( support.qsa ) {\n\t\t\t\treturn context.querySelectorAll( tag );\n\t\t\t}\n\t\t} :\n\n\t\tfunction( tag, context ) {\n\t\t\tvar elem,\n\t\t\t\ttmp = [],\n\t\t\t\ti = 0,\n\t\t\t\t// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\n\t\t\t\tresults = context.getElementsByTagName( tag );\n\n\t\t\t// Filter out possible comments\n\t\t\tif ( tag === \"*\" ) {\n\t\t\t\twhile ( (elem = results[i++]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\ttmp.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn tmp;\n\t\t\t}\n\t\t\treturn results;\n\t\t};\n\n\t// Class\n\tExpr.find[\"CLASS\"] = support.getElementsByClassName && function( className, context ) {\n\t\tif ( documentIsHTML ) {\n\t\t\treturn context.getElementsByClassName( className );\n\t\t}\n\t};\n\n\t/* QSA/matchesSelector\n\t---------------------------------------------------------------------- */\n\n\t// QSA and matchesSelector support\n\n\t// matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n\trbuggyMatches = [];\n\n\t// qSa(:focus) reports false when true (Chrome 21)\n\t// We allow this because of a bug in IE8/9 that throws an error\n\t// whenever `document.activeElement` is accessed on an iframe\n\t// So, we allow :focus to pass through QSA all the time to avoid the IE error\n\t// See http://bugs.jquery.com/ticket/13378\n\trbuggyQSA = [];\n\n\tif ( (support.qsa = rnative.test( doc.querySelectorAll )) ) {\n\t\t// Build QSA regex\n\t\t// Regex strategy adopted from Diego Perini\n\t\tassert(function( div ) {\n\t\t\t// Select is set to empty string on purpose\n\t\t\t// This is to test IE's treatment of not explicitly\n\t\t\t// setting a boolean content attribute,\n\t\t\t// since its presence should be enough\n\t\t\t// http://bugs.jquery.com/ticket/12359\n\t\t\tdocElem.appendChild( div ).innerHTML = \"<a id='\" + expando + \"'></a>\" +\n\t\t\t\t\"<select id='\" + expando + \"-\\f]' msallowcapture=''>\" +\n\t\t\t\t\"<option selected=''></option></select>\";\n\n\t\t\t// Support: IE8, Opera 11-12.16\n\t\t\t// Nothing should be selected when empty strings follow ^= or $= or *=\n\t\t\t// The test attribute must be unknown in Opera but \"safe\" for WinRT\n\t\t\t// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\n\t\t\tif ( div.querySelectorAll(\"[msallowcapture^='']\").length ) {\n\t\t\t\trbuggyQSA.push( \"[*^$]=\" + whitespace + \"*(?:''|\\\"\\\")\" );\n\t\t\t}\n\n\t\t\t// Support: IE8\n\t\t\t// Boolean attributes and \"value\" are not treated correctly\n\t\t\tif ( !div.querySelectorAll(\"[selected]\").length ) {\n\t\t\t\trbuggyQSA.push( \"\\\\[\" + whitespace + \"*(?:value|\" + booleans + \")\" );\n\t\t\t}\n\n\t\t\t// Support: Chrome<29, Android<4.2+, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.7+\n\t\t\tif ( !div.querySelectorAll( \"[id~=\" + expando + \"-]\" ).length ) {\n\t\t\t\trbuggyQSA.push(\"~=\");\n\t\t\t}\n\n\t\t\t// Webkit/Opera - :checked should return selected option elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( !div.querySelectorAll(\":checked\").length ) {\n\t\t\t\trbuggyQSA.push(\":checked\");\n\t\t\t}\n\n\t\t\t// Support: Safari 8+, iOS 8+\n\t\t\t// https://bugs.webkit.org/show_bug.cgi?id=136851\n\t\t\t// In-page `selector#id sibing-combinator selector` fails\n\t\t\tif ( !div.querySelectorAll( \"a#\" + expando + \"+*\" ).length ) {\n\t\t\t\trbuggyQSA.push(\".#.+[+~]\");\n\t\t\t}\n\t\t});\n\n\t\tassert(function( div ) {\n\t\t\t// Support: Windows 8 Native Apps\n\t\t\t// The type and name attributes are restricted during .innerHTML assignment\n\t\t\tvar input = doc.createElement(\"input\");\n\t\t\tinput.setAttribute( \"type\", \"hidden\" );\n\t\t\tdiv.appendChild( input ).setAttribute( \"name\", \"D\" );\n\n\t\t\t// Support: IE8\n\t\t\t// Enforce case-sensitivity of name attribute\n\t\t\tif ( div.querySelectorAll(\"[name=d]\").length ) {\n\t\t\t\trbuggyQSA.push( \"name\" + whitespace + \"*[*^$|!~]?=\" );\n\t\t\t}\n\n\t\t\t// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( !div.querySelectorAll(\":enabled\").length ) {\n\t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\n\t\t\t}\n\n\t\t\t// Opera 10-11 does not throw on post-comma invalid pseudos\n\t\t\tdiv.querySelectorAll(\"*,:x\");\n\t\t\trbuggyQSA.push(\",.*:\");\n\t\t});\n\t}\n\n\tif ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||\n\t\tdocElem.webkitMatchesSelector ||\n\t\tdocElem.mozMatchesSelector ||\n\t\tdocElem.oMatchesSelector ||\n\t\tdocElem.msMatchesSelector) )) ) {\n\n\t\tassert(function( div ) {\n\t\t\t// Check to see if it's possible to do matchesSelector\n\t\t\t// on a disconnected node (IE 9)\n\t\t\tsupport.disconnectedMatch = matches.call( div, \"div\" );\n\n\t\t\t// This should fail with an exception\n\t\t\t// Gecko does not error, returns false instead\n\t\t\tmatches.call( div, \"[s!='']:x\" );\n\t\t\trbuggyMatches.push( \"!=\", pseudos );\n\t\t});\n\t}\n\n\trbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join(\"|\") );\n\trbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join(\"|\") );\n\n\t/* Contains\n\t---------------------------------------------------------------------- */\n\thasCompare = rnative.test( docElem.compareDocumentPosition );\n\n\t// Element contains another\n\t// Purposefully does not implement inclusive descendent\n\t// As in, an element does not contain itself\n\tcontains = hasCompare || rnative.test( docElem.contains ) ?\n\t\tfunction( a, b ) {\n\t\t\tvar adown = a.nodeType === 9 ? a.documentElement : a,\n\t\t\t\tbup = b && b.parentNode;\n\t\t\treturn a === bup || !!( bup && bup.nodeType === 1 && (\n\t\t\t\tadown.contains ?\n\t\t\t\t\tadown.contains( bup ) :\n\t\t\t\t\ta.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16\n\t\t\t));\n\t\t} :\n\t\tfunction( a, b ) {\n\t\t\tif ( b ) {\n\t\t\t\twhile ( (b = b.parentNode) ) {\n\t\t\t\t\tif ( b === a ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\n\t/* Sorting\n\t---------------------------------------------------------------------- */\n\n\t// Document order sorting\n\tsortOrder = hasCompare ?\n\tfunction( a, b ) {\n\n\t\t// Flag for duplicate removal\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Sort on method existence if only one input has compareDocumentPosition\n\t\tvar compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\n\t\tif ( compare ) {\n\t\t\treturn compare;\n\t\t}\n\n\t\t// Calculate position if both inputs belong to the same document\n\t\tcompare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?\n\t\t\ta.compareDocumentPosition( b ) :\n\n\t\t\t// Otherwise we know they are disconnected\n\t\t\t1;\n\n\t\t// Disconnected nodes\n\t\tif ( compare & 1 ||\n\t\t\t(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {\n\n\t\t\t// Choose the first element that is related to our preferred document\n\t\t\tif ( a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif ( b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\t// Maintain original order\n\t\t\treturn sortInput ?\n\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t0;\n\t\t}\n\n\t\treturn compare & 4 ? -1 : 1;\n\t} :\n\tfunction( a, b ) {\n\t\t// Exit early if the nodes are identical\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\taup = a.parentNode,\n\t\t\tbup = b.parentNode,\n\t\t\tap = [ a ],\n\t\t\tbp = [ b ];\n\n\t\t// Parentless nodes are either documents or disconnected\n\t\tif ( !aup || !bup ) {\n\t\t\treturn a === doc ? -1 :\n\t\t\t\tb === doc ? 1 :\n\t\t\t\taup ? -1 :\n\t\t\t\tbup ? 1 :\n\t\t\t\tsortInput ?\n\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t0;\n\n\t\t// If the nodes are siblings, we can do a quick check\n\t\t} else if ( aup === bup ) {\n\t\t\treturn siblingCheck( a, b );\n\t\t}\n\n\t\t// Otherwise we need full lists of their ancestors for comparison\n\t\tcur = a;\n\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\tap.unshift( cur );\n\t\t}\n\t\tcur = b;\n\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\tbp.unshift( cur );\n\t\t}\n\n\t\t// Walk down the tree looking for a discrepancy\n\t\twhile ( ap[i] === bp[i] ) {\n\t\t\ti++;\n\t\t}\n\n\t\treturn i ?\n\t\t\t// Do a sibling check if the nodes have a common ancestor\n\t\t\tsiblingCheck( ap[i], bp[i] ) :\n\n\t\t\t// Otherwise nodes in our document sort first\n\t\t\tap[i] === preferredDoc ? -1 :\n\t\t\tbp[i] === preferredDoc ? 1 :\n\t\t\t0;\n\t};\n\n\treturn doc;\n};\n\nSizzle.matches = function( expr, elements ) {\n\treturn Sizzle( expr, null, null, elements );\n};\n\nSizzle.matchesSelector = function( elem, expr ) {\n\t// Set document vars if needed\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\tsetDocument( elem );\n\t}\n\n\t// Make sure that attribute selectors are quoted\n\texpr = expr.replace( rattributeQuotes, \"='$1']\" );\n\n\tif ( support.matchesSelector && documentIsHTML &&\n\t\t( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&\n\t\t( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {\n\n\t\ttry {\n\t\t\tvar ret = matches.call( elem, expr );\n\n\t\t\t// IE 9's matchesSelector returns false on disconnected nodes\n\t\t\tif ( ret || support.disconnectedMatch ||\n\t\t\t\t\t// As well, disconnected nodes are said to be in a document\n\t\t\t\t\t// fragment in IE 9\n\t\t\t\t\telem.document && elem.document.nodeType !== 11 ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} catch (e) {}\n\t}\n\n\treturn Sizzle( expr, document, null, [ elem ] ).length > 0;\n};\n\nSizzle.contains = function( context, elem ) {\n\t// Set document vars if needed\n\tif ( ( context.ownerDocument || context ) !== document ) {\n\t\tsetDocument( context );\n\t}\n\treturn contains( context, elem );\n};\n\nSizzle.attr = function( elem, name ) {\n\t// Set document vars if needed\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\tsetDocument( elem );\n\t}\n\n\tvar fn = Expr.attrHandle[ name.toLowerCase() ],\n\t\t// Don't get fooled by Object.prototype properties (jQuery #13807)\n\t\tval = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?\n\t\t\tfn( elem, name, !documentIsHTML ) :\n\t\t\tundefined;\n\n\treturn val !== undefined ?\n\t\tval :\n\t\tsupport.attributes || !documentIsHTML ?\n\t\t\telem.getAttribute( name ) :\n\t\t\t(val = elem.getAttributeNode(name)) && val.specified ?\n\t\t\t\tval.value :\n\t\t\t\tnull;\n};\n\nSizzle.error = function( msg ) {\n\tthrow new Error( \"Syntax error, unrecognized expression: \" + msg );\n};\n\n/**\n * Document sorting and removing duplicates\n * @param {ArrayLike} results\n */\nSizzle.uniqueSort = function( results ) {\n\tvar elem,\n\t\tduplicates = [],\n\t\tj = 0,\n\t\ti = 0;\n\n\t// Unless we *know* we can detect duplicates, assume their presence\n\thasDuplicate = !support.detectDuplicates;\n\tsortInput = !support.sortStable && results.slice( 0 );\n\tresults.sort( sortOrder );\n\n\tif ( hasDuplicate ) {\n\t\twhile ( (elem = results[i++]) ) {\n\t\t\tif ( elem === results[ i ] ) {\n\t\t\t\tj = duplicates.push( i );\n\t\t\t}\n\t\t}\n\t\twhile ( j-- ) {\n\t\t\tresults.splice( duplicates[ j ], 1 );\n\t\t}\n\t}\n\n\t// Clear input after sorting to release objects\n\t// See https://github.com/jquery/sizzle/pull/225\n\tsortInput = null;\n\n\treturn results;\n};\n\n/**\n * Utility function for retrieving the text value of an array of DOM nodes\n * @param {Array|Element} elem\n */\ngetText = Sizzle.getText = function( elem ) {\n\tvar node,\n\t\tret = \"\",\n\t\ti = 0,\n\t\tnodeType = elem.nodeType;\n\n\tif ( !nodeType ) {\n\t\t// If no nodeType, this is expected to be an array\n\t\twhile ( (node = elem[i++]) ) {\n\t\t\t// Do not traverse comment nodes\n\t\t\tret += getText( node );\n\t\t}\n\t} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {\n\t\t// Use textContent for elements\n\t\t// innerText usage removed for consistency of new lines (jQuery #11153)\n\t\tif ( typeof elem.textContent === \"string\" ) {\n\t\t\treturn elem.textContent;\n\t\t} else {\n\t\t\t// Traverse its children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tret += getText( elem );\n\t\t\t}\n\t\t}\n\t} else if ( nodeType === 3 || nodeType === 4 ) {\n\t\treturn elem.nodeValue;\n\t}\n\t// Do not include comment or processing instruction nodes\n\n\treturn ret;\n};\n\nExpr = Sizzle.selectors = {\n\n\t// Can be adjusted by the user\n\tcacheLength: 50,\n\n\tcreatePseudo: markFunction,\n\n\tmatch: matchExpr,\n\n\tattrHandle: {},\n\n\tfind: {},\n\n\trelative: {\n\t\t\">\": { dir: \"parentNode\", first: true },\n\t\t\" \": { dir: \"parentNode\" },\n\t\t\"+\": { dir: \"previousSibling\", first: true },\n\t\t\"~\": { dir: \"previousSibling\" }\n\t},\n\n\tpreFilter: {\n\t\t\"ATTR\": function( match ) {\n\t\t\tmatch[1] = match[1].replace( runescape, funescape );\n\n\t\t\t// Move the given value to match[3] whether quoted or unquoted\n\t\t\tmatch[3] = ( match[3] || match[4] || match[5] || \"\" ).replace( runescape, funescape );\n\n\t\t\tif ( match[2] === \"~=\" ) {\n\t\t\t\tmatch[3] = \" \" + match[3] + \" \";\n\t\t\t}\n\n\t\t\treturn match.slice( 0, 4 );\n\t\t},\n\n\t\t\"CHILD\": function( match ) {\n\t\t\t/* matches from matchExpr[\"CHILD\"]\n\t\t\t\t1 type (only|nth|...)\n\t\t\t\t2 what (child|of-type)\n\t\t\t\t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n\t\t\t\t4 xn-component of xn+y argument ([+-]?\\d*n|)\n\t\t\t\t5 sign of xn-component\n\t\t\t\t6 x of xn-component\n\t\t\t\t7 sign of y-component\n\t\t\t\t8 y of y-component\n\t\t\t*/\n\t\t\tmatch[1] = match[1].toLowerCase();\n\n\t\t\tif ( match[1].slice( 0, 3 ) === \"nth\" ) {\n\t\t\t\t// nth-* requires argument\n\t\t\t\tif ( !match[3] ) {\n\t\t\t\t\tSizzle.error( match[0] );\n\t\t\t\t}\n\n\t\t\t\t// numeric x and y parameters for Expr.filter.CHILD\n\t\t\t\t// remember that false/true cast respectively to 0/1\n\t\t\t\tmatch[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === \"even\" || match[3] === \"odd\" ) );\n\t\t\t\tmatch[5] = +( ( match[7] + match[8] ) || match[3] === \"odd\" );\n\n\t\t\t// other types prohibit arguments\n\t\t\t} else if ( match[3] ) {\n\t\t\t\tSizzle.error( match[0] );\n\t\t\t}\n\n\t\t\treturn match;\n\t\t},\n\n\t\t\"PSEUDO\": function( match ) {\n\t\t\tvar excess,\n\t\t\t\tunquoted = !match[6] && match[2];\n\n\t\t\tif ( matchExpr[\"CHILD\"].test( match[0] ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// Accept quoted arguments as-is\n\t\t\tif ( match[3] ) {\n\t\t\t\tmatch[2] = match[4] || match[5] || \"\";\n\n\t\t\t// Strip excess characters from unquoted arguments\n\t\t\t} else if ( unquoted && rpseudo.test( unquoted ) &&\n\t\t\t\t// Get excess from tokenize (recursively)\n\t\t\t\t(excess = tokenize( unquoted, true )) &&\n\t\t\t\t// advance to the next closing parenthesis\n\t\t\t\t(excess = unquoted.indexOf( \")\", unquoted.length - excess ) - unquoted.length) ) {\n\n\t\t\t\t// excess is a negative index\n\t\t\t\tmatch[0] = match[0].slice( 0, excess );\n\t\t\t\tmatch[2] = unquoted.slice( 0, excess );\n\t\t\t}\n\n\t\t\t// Return only captures needed by the pseudo filter method (type and argument)\n\t\t\treturn match.slice( 0, 3 );\n\t\t}\n\t},\n\n\tfilter: {\n\n\t\t\"TAG\": function( nodeNameSelector ) {\n\t\t\tvar nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn nodeNameSelector === \"*\" ?\n\t\t\t\tfunction() { return true; } :\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n\t\t\t\t};\n\t\t},\n\n\t\t\"CLASS\": function( className ) {\n\t\t\tvar pattern = classCache[ className + \" \" ];\n\n\t\t\treturn pattern ||\n\t\t\t\t(pattern = new RegExp( \"(^|\" + whitespace + \")\" + className + \"(\" + whitespace + \"|$)\" )) &&\n\t\t\t\tclassCache( className, function( elem ) {\n\t\t\t\t\treturn pattern.test( typeof elem.className === \"string\" && elem.className || typeof elem.getAttribute !== \"undefined\" && elem.getAttribute(\"class\") || \"\" );\n\t\t\t\t});\n\t\t},\n\n\t\t\"ATTR\": function( name, operator, check ) {\n\t\t\treturn function( elem ) {\n\t\t\t\tvar result = Sizzle.attr( elem, name );\n\n\t\t\t\tif ( result == null ) {\n\t\t\t\t\treturn operator === \"!=\";\n\t\t\t\t}\n\t\t\t\tif ( !operator ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tresult += \"\";\n\n\t\t\t\treturn operator === \"=\" ? result === check :\n\t\t\t\t\toperator === \"!=\" ? result !== check :\n\t\t\t\t\toperator === \"^=\" ? check && result.indexOf( check ) === 0 :\n\t\t\t\t\toperator === \"*=\" ? check && result.indexOf( check ) > -1 :\n\t\t\t\t\toperator === \"$=\" ? check && result.slice( -check.length ) === check :\n\t\t\t\t\toperator === \"~=\" ? ( \" \" + result.replace( rwhitespace, \" \" ) + \" \" ).indexOf( check ) > -1 :\n\t\t\t\t\toperator === \"|=\" ? result === check || result.slice( 0, check.length + 1 ) === check + \"-\" :\n\t\t\t\t\tfalse;\n\t\t\t};\n\t\t},\n\n\t\t\"CHILD\": function( type, what, argument, first, last ) {\n\t\t\tvar simple = type.slice( 0, 3 ) !== \"nth\",\n\t\t\t\tforward = type.slice( -4 ) !== \"last\",\n\t\t\t\tofType = what === \"of-type\";\n\n\t\t\treturn first === 1 && last === 0 ?\n\n\t\t\t\t// Shortcut for :nth-*(n)\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn !!elem.parentNode;\n\t\t\t\t} :\n\n\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\tvar cache, outerCache, node, diff, nodeIndex, start,\n\t\t\t\t\t\tdir = simple !== forward ? \"nextSibling\" : \"previousSibling\",\n\t\t\t\t\t\tparent = elem.parentNode,\n\t\t\t\t\t\tname = ofType && elem.nodeName.toLowerCase(),\n\t\t\t\t\t\tuseCache = !xml && !ofType;\n\n\t\t\t\t\tif ( parent ) {\n\n\t\t\t\t\t\t// :(first|last|only)-(child|of-type)\n\t\t\t\t\t\tif ( simple ) {\n\t\t\t\t\t\t\twhile ( dir ) {\n\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\twhile ( (node = node[ dir ]) ) {\n\t\t\t\t\t\t\t\t\tif ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {\n\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Reverse direction for :only-* (if we haven't yet done so)\n\t\t\t\t\t\t\t\tstart = dir = type === \"only\" && !start && \"nextSibling\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstart = [ forward ? parent.firstChild : parent.lastChild ];\n\n\t\t\t\t\t\t// non-xml :nth-child(...) stores cache data on `parent`\n\t\t\t\t\t\tif ( forward && useCache ) {\n\t\t\t\t\t\t\t// Seek `elem` from a previously-cached index\n\t\t\t\t\t\t\touterCache = parent[ expando ] || (parent[ expando ] = {});\n\t\t\t\t\t\t\tcache = outerCache[ type ] || [];\n\t\t\t\t\t\t\tnodeIndex = cache[0] === dirruns && cache[1];\n\t\t\t\t\t\t\tdiff = cache[0] === dirruns && cache[2];\n\t\t\t\t\t\t\tnode = nodeIndex && parent.childNodes[ nodeIndex ];\n\n\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\n\t\t\t\t\t\t\t\t// Fallback to seeking `elem` from the start\n\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\t// When found, cache indexes on `parent` and break\n\t\t\t\t\t\t\t\tif ( node.nodeType === 1 && ++diff && node === elem ) {\n\t\t\t\t\t\t\t\t\touterCache[ type ] = [ dirruns, nodeIndex, diff ];\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Use previously-cached element index if available\n\t\t\t\t\t\t} else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {\n\t\t\t\t\t\t\tdiff = cache[1];\n\n\t\t\t\t\t\t// xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Use the same loop as above to seek `elem` from the start\n\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\tif ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {\n\t\t\t\t\t\t\t\t\t// Cache the index of each encountered element\n\t\t\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\t\t\t(node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif ( node === elem ) {\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Incorporate the offset, then check against cycle size\n\t\t\t\t\t\tdiff -= last;\n\t\t\t\t\t\treturn diff === first || ( diff % first === 0 && diff / first >= 0 );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t},\n\n\t\t\"PSEUDO\": function( pseudo, argument ) {\n\t\t\t// pseudo-class names are case-insensitive\n\t\t\t// http://www.w3.org/TR/selectors/#pseudo-classes\n\t\t\t// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n\t\t\t// Remember that setFilters inherits from pseudos\n\t\t\tvar args,\n\t\t\t\tfn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||\n\t\t\t\t\tSizzle.error( \"unsupported pseudo: \" + pseudo );\n\n\t\t\t// The user may use createPseudo to indicate that\n\t\t\t// arguments are needed to create the filter function\n\t\t\t// just as Sizzle does\n\t\t\tif ( fn[ expando ] ) {\n\t\t\t\treturn fn( argument );\n\t\t\t}\n\n\t\t\t// But maintain support for old signatures\n\t\t\tif ( fn.length > 1 ) {\n\t\t\t\targs = [ pseudo, pseudo, \"\", argument ];\n\t\t\t\treturn Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?\n\t\t\t\t\tmarkFunction(function( seed, matches ) {\n\t\t\t\t\t\tvar idx,\n\t\t\t\t\t\t\tmatched = fn( seed, argument ),\n\t\t\t\t\t\t\ti = matched.length;\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tidx = indexOf( seed, matched[i] );\n\t\t\t\t\t\t\tseed[ idx ] = !( matches[ idx ] = matched[i] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}) :\n\t\t\t\t\tfunction( elem ) {\n\t\t\t\t\t\treturn fn( elem, 0, args );\n\t\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn fn;\n\t\t}\n\t},\n\n\tpseudos: {\n\t\t// Potentially complex pseudos\n\t\t\"not\": markFunction(function( selector ) {\n\t\t\t// Trim the selector passed to compile\n\t\t\t// to avoid treating leading and trailing\n\t\t\t// spaces as combinators\n\t\t\tvar input = [],\n\t\t\t\tresults = [],\n\t\t\t\tmatcher = compile( selector.replace( rtrim, \"$1\" ) );\n\n\t\t\treturn matcher[ expando ] ?\n\t\t\t\tmarkFunction(function( seed, matches, context, xml ) {\n\t\t\t\t\tvar elem,\n\t\t\t\t\t\tunmatched = matcher( seed, null, xml, [] ),\n\t\t\t\t\t\ti = seed.length;\n\n\t\t\t\t\t// Match elements unmatched by `matcher`\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = unmatched[i]) ) {\n\t\t\t\t\t\t\tseed[i] = !(matches[i] = elem);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}) :\n\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\tinput[0] = elem;\n\t\t\t\t\tmatcher( input, null, xml, results );\n\t\t\t\t\t// Don't keep the element (issue #299)\n\t\t\t\t\tinput[0] = null;\n\t\t\t\t\treturn !results.pop();\n\t\t\t\t};\n\t\t}),\n\n\t\t\"has\": markFunction(function( selector ) {\n\t\t\treturn function( elem ) {\n\t\t\t\treturn Sizzle( selector, elem ).length > 0;\n\t\t\t};\n\t\t}),\n\n\t\t\"contains\": markFunction(function( text ) {\n\t\t\ttext = text.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;\n\t\t\t};\n\t\t}),\n\n\t\t// \"Whether an element is represented by a :lang() selector\n\t\t// is based solely on the element's language value\n\t\t// being equal to the identifier C,\n\t\t// or beginning with the identifier C immediately followed by \"-\".\n\t\t// The matching of C against the element's language value is performed case-insensitively.\n\t\t// The identifier C does not have to be a valid language name.\"\n\t\t// http://www.w3.org/TR/selectors/#lang-pseudo\n\t\t\"lang\": markFunction( function( lang ) {\n\t\t\t// lang value must be a valid identifier\n\t\t\tif ( !ridentifier.test(lang || \"\") ) {\n\t\t\t\tSizzle.error( \"unsupported lang: \" + lang );\n\t\t\t}\n\t\t\tlang = lang.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn function( elem ) {\n\t\t\t\tvar elemLang;\n\t\t\t\tdo {\n\t\t\t\t\tif ( (elemLang = documentIsHTML ?\n\t\t\t\t\t\telem.lang :\n\t\t\t\t\t\telem.getAttribute(\"xml:lang\") || elem.getAttribute(\"lang\")) ) {\n\n\t\t\t\t\t\telemLang = elemLang.toLowerCase();\n\t\t\t\t\t\treturn elemLang === lang || elemLang.indexOf( lang + \"-\" ) === 0;\n\t\t\t\t\t}\n\t\t\t\t} while ( (elem = elem.parentNode) && elem.nodeType === 1 );\n\t\t\t\treturn false;\n\t\t\t};\n\t\t}),\n\n\t\t// Miscellaneous\n\t\t\"target\": function( elem ) {\n\t\t\tvar hash = window.location && window.location.hash;\n\t\t\treturn hash && hash.slice( 1 ) === elem.id;\n\t\t},\n\n\t\t\"root\": function( elem ) {\n\t\t\treturn elem === docElem;\n\t\t},\n\n\t\t\"focus\": function( elem ) {\n\t\t\treturn elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\n\t\t},\n\n\t\t// Boolean properties\n\t\t\"enabled\": function( elem ) {\n\t\t\treturn elem.disabled === false;\n\t\t},\n\n\t\t\"disabled\": function( elem ) {\n\t\t\treturn elem.disabled === true;\n\t\t},\n\n\t\t\"checked\": function( elem ) {\n\t\t\t// In CSS3, :checked should return both checked and selected elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\tvar nodeName = elem.nodeName.toLowerCase();\n\t\t\treturn (nodeName === \"input\" && !!elem.checked) || (nodeName === \"option\" && !!elem.selected);\n\t\t},\n\n\t\t\"selected\": function( elem ) {\n\t\t\t// Accessing this property makes selected-by-default\n\t\t\t// options in Safari work properly\n\t\t\tif ( elem.parentNode ) {\n\t\t\t\telem.parentNode.selectedIndex;\n\t\t\t}\n\n\t\t\treturn elem.selected === true;\n\t\t},\n\n\t\t// Contents\n\t\t\"empty\": function( elem ) {\n\t\t\t// http://www.w3.org/TR/selectors/#empty-pseudo\n\t\t\t// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\n\t\t\t//   but not by others (comment: 8; processing instruction: 7; etc.)\n\t\t\t// nodeType < 6 works because attributes (2) do not appear as children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tif ( elem.nodeType < 6 ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\n\t\t\"parent\": function( elem ) {\n\t\t\treturn !Expr.pseudos[\"empty\"]( elem );\n\t\t},\n\n\t\t// Element/input types\n\t\t\"header\": function( elem ) {\n\t\t\treturn rheader.test( elem.nodeName );\n\t\t},\n\n\t\t\"input\": function( elem ) {\n\t\t\treturn rinputs.test( elem.nodeName );\n\t\t},\n\n\t\t\"button\": function( elem ) {\n\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\treturn name === \"input\" && elem.type === \"button\" || name === \"button\";\n\t\t},\n\n\t\t\"text\": function( elem ) {\n\t\t\tvar attr;\n\t\t\treturn elem.nodeName.toLowerCase() === \"input\" &&\n\t\t\t\telem.type === \"text\" &&\n\n\t\t\t\t// Support: IE<8\n\t\t\t\t// New HTML5 attribute values (e.g., \"search\") appear with elem.type === \"text\"\n\t\t\t\t( (attr = elem.getAttribute(\"type\")) == null || attr.toLowerCase() === \"text\" );\n\t\t},\n\n\t\t// Position-in-collection\n\t\t\"first\": createPositionalPseudo(function() {\n\t\t\treturn [ 0 ];\n\t\t}),\n\n\t\t\"last\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\treturn [ length - 1 ];\n\t\t}),\n\n\t\t\"eq\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\treturn [ argument < 0 ? argument + length : argument ];\n\t\t}),\n\n\t\t\"even\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\tvar i = 0;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"odd\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\tvar i = 1;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"lt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\tfor ( ; --i >= 0; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"gt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\tfor ( ; ++i < length; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t})\n\t}\n};\n\nExpr.pseudos[\"nth\"] = Expr.pseudos[\"eq\"];\n\n// Add button/input type pseudos\nfor ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {\n\tExpr.pseudos[ i ] = createInputPseudo( i );\n}\nfor ( i in { submit: true, reset: true } ) {\n\tExpr.pseudos[ i ] = createButtonPseudo( i );\n}\n\n// Easy API for creating new setFilters\nfunction setFilters() {}\nsetFilters.prototype = Expr.filters = Expr.pseudos;\nExpr.setFilters = new setFilters();\n\ntokenize = Sizzle.tokenize = function( selector, parseOnly ) {\n\tvar matched, match, tokens, type,\n\t\tsoFar, groups, preFilters,\n\t\tcached = tokenCache[ selector + \" \" ];\n\n\tif ( cached ) {\n\t\treturn parseOnly ? 0 : cached.slice( 0 );\n\t}\n\n\tsoFar = selector;\n\tgroups = [];\n\tpreFilters = Expr.preFilter;\n\n\twhile ( soFar ) {\n\n\t\t// Comma and first run\n\t\tif ( !matched || (match = rcomma.exec( soFar )) ) {\n\t\t\tif ( match ) {\n\t\t\t\t// Don't consume trailing commas as valid\n\t\t\t\tsoFar = soFar.slice( match[0].length ) || soFar;\n\t\t\t}\n\t\t\tgroups.push( (tokens = []) );\n\t\t}\n\n\t\tmatched = false;\n\n\t\t// Combinators\n\t\tif ( (match = rcombinators.exec( soFar )) ) {\n\t\t\tmatched = match.shift();\n\t\t\ttokens.push({\n\t\t\t\tvalue: matched,\n\t\t\t\t// Cast descendant combinators to space\n\t\t\t\ttype: match[0].replace( rtrim, \" \" )\n\t\t\t});\n\t\t\tsoFar = soFar.slice( matched.length );\n\t\t}\n\n\t\t// Filters\n\t\tfor ( type in Expr.filter ) {\n\t\t\tif ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||\n\t\t\t\t(match = preFilters[ type ]( match ))) ) {\n\t\t\t\tmatched = match.shift();\n\t\t\t\ttokens.push({\n\t\t\t\t\tvalue: matched,\n\t\t\t\t\ttype: type,\n\t\t\t\t\tmatches: match\n\t\t\t\t});\n\t\t\t\tsoFar = soFar.slice( matched.length );\n\t\t\t}\n\t\t}\n\n\t\tif ( !matched ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Return the length of the invalid excess\n\t// if we're just parsing\n\t// Otherwise, throw an error or return tokens\n\treturn parseOnly ?\n\t\tsoFar.length :\n\t\tsoFar ?\n\t\t\tSizzle.error( selector ) :\n\t\t\t// Cache the tokens\n\t\t\ttokenCache( selector, groups ).slice( 0 );\n};\n\nfunction toSelector( tokens ) {\n\tvar i = 0,\n\t\tlen = tokens.length,\n\t\tselector = \"\";\n\tfor ( ; i < len; i++ ) {\n\t\tselector += tokens[i].value;\n\t}\n\treturn selector;\n}\n\nfunction addCombinator( matcher, combinator, base ) {\n\tvar dir = combinator.dir,\n\t\tcheckNonElements = base && dir === \"parentNode\",\n\t\tdoneName = done++;\n\n\treturn combinator.first ?\n\t\t// Check against closest ancestor/preceding element\n\t\tfunction( elem, context, xml ) {\n\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\treturn matcher( elem, context, xml );\n\t\t\t\t}\n\t\t\t}\n\t\t} :\n\n\t\t// Check against all ancestor/preceding elements\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar oldCache, outerCache,\n\t\t\t\tnewCache = [ dirruns, doneName ];\n\n\t\t\t// We can't set arbitrary data on XML nodes, so they don't benefit from dir caching\n\t\t\tif ( xml ) {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\touterCache = elem[ expando ] || (elem[ expando ] = {});\n\t\t\t\t\t\tif ( (oldCache = outerCache[ dir ]) &&\n\t\t\t\t\t\t\toldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {\n\n\t\t\t\t\t\t\t// Assign to newCache so results back-propagate to previous elements\n\t\t\t\t\t\t\treturn (newCache[ 2 ] = oldCache[ 2 ]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Reuse newcache so results back-propagate to previous elements\n\t\t\t\t\t\t\touterCache[ dir ] = newCache;\n\n\t\t\t\t\t\t\t// A match means we're done; a fail means we have to keep checking\n\t\t\t\t\t\t\tif ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n}\n\nfunction elementMatcher( matchers ) {\n\treturn matchers.length > 1 ?\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar i = matchers.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( !matchers[i]( elem, context, xml ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} :\n\t\tmatchers[0];\n}\n\nfunction multipleContexts( selector, contexts, results ) {\n\tvar i = 0,\n\t\tlen = contexts.length;\n\tfor ( ; i < len; i++ ) {\n\t\tSizzle( selector, contexts[i], results );\n\t}\n\treturn results;\n}\n\nfunction condense( unmatched, map, filter, context, xml ) {\n\tvar elem,\n\t\tnewUnmatched = [],\n\t\ti = 0,\n\t\tlen = unmatched.length,\n\t\tmapped = map != null;\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( (elem = unmatched[i]) ) {\n\t\t\tif ( !filter || filter( elem, context, xml ) ) {\n\t\t\t\tnewUnmatched.push( elem );\n\t\t\t\tif ( mapped ) {\n\t\t\t\t\tmap.push( i );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn newUnmatched;\n}\n\nfunction setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {\n\tif ( postFilter && !postFilter[ expando ] ) {\n\t\tpostFilter = setMatcher( postFilter );\n\t}\n\tif ( postFinder && !postFinder[ expando ] ) {\n\t\tpostFinder = setMatcher( postFinder, postSelector );\n\t}\n\treturn markFunction(function( seed, results, context, xml ) {\n\t\tvar temp, i, elem,\n\t\t\tpreMap = [],\n\t\t\tpostMap = [],\n\t\t\tpreexisting = results.length,\n\n\t\t\t// Get initial elements from seed or context\n\t\t\telems = seed || multipleContexts( selector || \"*\", context.nodeType ? [ context ] : context, [] ),\n\n\t\t\t// Prefilter to get matcher input, preserving a map for seed-results synchronization\n\t\t\tmatcherIn = preFilter && ( seed || !selector ) ?\n\t\t\t\tcondense( elems, preMap, preFilter, context, xml ) :\n\t\t\t\telems,\n\n\t\t\tmatcherOut = matcher ?\n\t\t\t\t// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n\t\t\t\tpostFinder || ( seed ? preFilter : preexisting || postFilter ) ?\n\n\t\t\t\t\t// ...intermediate processing is necessary\n\t\t\t\t\t[] :\n\n\t\t\t\t\t// ...otherwise use results directly\n\t\t\t\t\tresults :\n\t\t\t\tmatcherIn;\n\n\t\t// Find primary matches\n\t\tif ( matcher ) {\n\t\t\tmatcher( matcherIn, matcherOut, context, xml );\n\t\t}\n\n\t\t// Apply postFilter\n\t\tif ( postFilter ) {\n\t\t\ttemp = condense( matcherOut, postMap );\n\t\t\tpostFilter( temp, [], context, xml );\n\n\t\t\t// Un-match failing elements by moving them back to matcherIn\n\t\t\ti = temp.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( (elem = temp[i]) ) {\n\t\t\t\t\tmatcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( seed ) {\n\t\t\tif ( postFinder || preFilter ) {\n\t\t\t\tif ( postFinder ) {\n\t\t\t\t\t// Get the final matcherOut by condensing this intermediate into postFinder contexts\n\t\t\t\t\ttemp = [];\n\t\t\t\t\ti = matcherOut.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = matcherOut[i]) ) {\n\t\t\t\t\t\t\t// Restore matcherIn since elem is not yet a final match\n\t\t\t\t\t\t\ttemp.push( (matcherIn[i] = elem) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpostFinder( null, (matcherOut = []), temp, xml );\n\t\t\t\t}\n\n\t\t\t\t// Move matched elements from seed to results to keep them synchronized\n\t\t\t\ti = matcherOut.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( (elem = matcherOut[i]) &&\n\t\t\t\t\t\t(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {\n\n\t\t\t\t\t\tseed[temp] = !(results[temp] = elem);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Add elements to results, through postFinder if defined\n\t\t} else {\n\t\t\tmatcherOut = condense(\n\t\t\t\tmatcherOut === results ?\n\t\t\t\t\tmatcherOut.splice( preexisting, matcherOut.length ) :\n\t\t\t\t\tmatcherOut\n\t\t\t);\n\t\t\tif ( postFinder ) {\n\t\t\t\tpostFinder( null, results, matcherOut, xml );\n\t\t\t} else {\n\t\t\t\tpush.apply( results, matcherOut );\n\t\t\t}\n\t\t}\n\t});\n}\n\nfunction matcherFromTokens( tokens ) {\n\tvar checkContext, matcher, j,\n\t\tlen = tokens.length,\n\t\tleadingRelative = Expr.relative[ tokens[0].type ],\n\t\timplicitRelative = leadingRelative || Expr.relative[\" \"],\n\t\ti = leadingRelative ? 1 : 0,\n\n\t\t// The foundational matcher ensures that elements are reachable from top-level context(s)\n\t\tmatchContext = addCombinator( function( elem ) {\n\t\t\treturn elem === checkContext;\n\t\t}, implicitRelative, true ),\n\t\tmatchAnyContext = addCombinator( function( elem ) {\n\t\t\treturn indexOf( checkContext, elem ) > -1;\n\t\t}, implicitRelative, true ),\n\t\tmatchers = [ function( elem, context, xml ) {\n\t\t\tvar ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (\n\t\t\t\t(checkContext = context).nodeType ?\n\t\t\t\t\tmatchContext( elem, context, xml ) :\n\t\t\t\t\tmatchAnyContext( elem, context, xml ) );\n\t\t\t// Avoid hanging onto element (issue #299)\n\t\t\tcheckContext = null;\n\t\t\treturn ret;\n\t\t} ];\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( (matcher = Expr.relative[ tokens[i].type ]) ) {\n\t\t\tmatchers = [ addCombinator(elementMatcher( matchers ), matcher) ];\n\t\t} else {\n\t\t\tmatcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );\n\n\t\t\t// Return special upon seeing a positional matcher\n\t\t\tif ( matcher[ expando ] ) {\n\t\t\t\t// Find the next relative operator (if any) for proper handling\n\t\t\t\tj = ++i;\n\t\t\t\tfor ( ; j < len; j++ ) {\n\t\t\t\t\tif ( Expr.relative[ tokens[j].type ] ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn setMatcher(\n\t\t\t\t\ti > 1 && elementMatcher( matchers ),\n\t\t\t\t\ti > 1 && toSelector(\n\t\t\t\t\t\t// If the preceding token was a descendant combinator, insert an implicit any-element `*`\n\t\t\t\t\t\ttokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === \" \" ? \"*\" : \"\" })\n\t\t\t\t\t).replace( rtrim, \"$1\" ),\n\t\t\t\t\tmatcher,\n\t\t\t\t\ti < j && matcherFromTokens( tokens.slice( i, j ) ),\n\t\t\t\t\tj < len && matcherFromTokens( (tokens = tokens.slice( j )) ),\n\t\t\t\t\tj < len && toSelector( tokens )\n\t\t\t\t);\n\t\t\t}\n\t\t\tmatchers.push( matcher );\n\t\t}\n\t}\n\n\treturn elementMatcher( matchers );\n}\n\nfunction matcherFromGroupMatchers( elementMatchers, setMatchers ) {\n\tvar bySet = setMatchers.length > 0,\n\t\tbyElement = elementMatchers.length > 0,\n\t\tsuperMatcher = function( seed, context, xml, results, outermost ) {\n\t\t\tvar elem, j, matcher,\n\t\t\t\tmatchedCount = 0,\n\t\t\t\ti = \"0\",\n\t\t\t\tunmatched = seed && [],\n\t\t\t\tsetMatched = [],\n\t\t\t\tcontextBackup = outermostContext,\n\t\t\t\t// We must always have either seed elements or outermost context\n\t\t\t\telems = seed || byElement && Expr.find[\"TAG\"]( \"*\", outermost ),\n\t\t\t\t// Use integer dirruns iff this is the outermost matcher\n\t\t\t\tdirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),\n\t\t\t\tlen = elems.length;\n\n\t\t\tif ( outermost ) {\n\t\t\t\toutermostContext = context !== document && context;\n\t\t\t}\n\n\t\t\t// Add elements passing elementMatchers directly to results\n\t\t\t// Keep `i` a string if there are no elements so `matchedCount` will be \"00\" below\n\t\t\t// Support: IE<9, Safari\n\t\t\t// Tolerate NodeList properties (IE: \"length\"; Safari: <number>) matching elements by id\n\t\t\tfor ( ; i !== len && (elem = elems[i]) != null; i++ ) {\n\t\t\t\tif ( byElement && elem ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( (matcher = elementMatchers[j++]) ) {\n\t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( outermost ) {\n\t\t\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Track unmatched elements for set filters\n\t\t\t\tif ( bySet ) {\n\t\t\t\t\t// They will have gone through all possible matchers\n\t\t\t\t\tif ( (elem = !matcher && elem) ) {\n\t\t\t\t\t\tmatchedCount--;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Lengthen the array for every element, matched or not\n\t\t\t\t\tif ( seed ) {\n\t\t\t\t\t\tunmatched.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Apply set filters to unmatched elements\n\t\t\tmatchedCount += i;\n\t\t\tif ( bySet && i !== matchedCount ) {\n\t\t\t\tj = 0;\n\t\t\t\twhile ( (matcher = setMatchers[j++]) ) {\n\t\t\t\t\tmatcher( unmatched, setMatched, context, xml );\n\t\t\t\t}\n\n\t\t\t\tif ( seed ) {\n\t\t\t\t\t// Reintegrate element matches to eliminate the need for sorting\n\t\t\t\t\tif ( matchedCount > 0 ) {\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tif ( !(unmatched[i] || setMatched[i]) ) {\n\t\t\t\t\t\t\t\tsetMatched[i] = pop.call( results );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Discard index placeholder values to get only actual matches\n\t\t\t\t\tsetMatched = condense( setMatched );\n\t\t\t\t}\n\n\t\t\t\t// Add matches to results\n\t\t\t\tpush.apply( results, setMatched );\n\n\t\t\t\t// Seedless set matches succeeding multiple successful matchers stipulate sorting\n\t\t\t\tif ( outermost && !seed && setMatched.length > 0 &&\n\t\t\t\t\t( matchedCount + setMatchers.length ) > 1 ) {\n\n\t\t\t\t\tSizzle.uniqueSort( results );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Override manipulation of globals by nested matchers\n\t\t\tif ( outermost ) {\n\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\toutermostContext = contextBackup;\n\t\t\t}\n\n\t\t\treturn unmatched;\n\t\t};\n\n\treturn bySet ?\n\t\tmarkFunction( superMatcher ) :\n\t\tsuperMatcher;\n}\n\ncompile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {\n\tvar i,\n\t\tsetMatchers = [],\n\t\telementMatchers = [],\n\t\tcached = compilerCache[ selector + \" \" ];\n\n\tif ( !cached ) {\n\t\t// Generate a function of recursive functions that can be used to check each element\n\t\tif ( !match ) {\n\t\t\tmatch = tokenize( selector );\n\t\t}\n\t\ti = match.length;\n\t\twhile ( i-- ) {\n\t\t\tcached = matcherFromTokens( match[i] );\n\t\t\tif ( cached[ expando ] ) {\n\t\t\t\tsetMatchers.push( cached );\n\t\t\t} else {\n\t\t\t\telementMatchers.push( cached );\n\t\t\t}\n\t\t}\n\n\t\t// Cache the compiled function\n\t\tcached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );\n\n\t\t// Save selector and tokenization\n\t\tcached.selector = selector;\n\t}\n\treturn cached;\n};\n\n/**\n * A low-level selection function that works with Sizzle's compiled\n *  selector functions\n * @param {String|Function} selector A selector or a pre-compiled\n *  selector function built with Sizzle.compile\n * @param {Element} context\n * @param {Array} [results]\n * @param {Array} [seed] A set of elements to match against\n */\nselect = Sizzle.select = function( selector, context, results, seed ) {\n\tvar i, tokens, token, type, find,\n\t\tcompiled = typeof selector === \"function\" && selector,\n\t\tmatch = !seed && tokenize( (selector = compiled.selector || selector) );\n\n\tresults = results || [];\n\n\t// Try to minimize operations if there is no seed and only one group\n\tif ( match.length === 1 ) {\n\n\t\t// Take a shortcut and set the context if the root selector is an ID\n\t\ttokens = match[0] = match[0].slice( 0 );\n\t\tif ( tokens.length > 2 && (token = tokens[0]).type === \"ID\" &&\n\t\t\t\tsupport.getById && context.nodeType === 9 && documentIsHTML &&\n\t\t\t\tExpr.relative[ tokens[1].type ] ) {\n\n\t\t\tcontext = ( Expr.find[\"ID\"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];\n\t\t\tif ( !context ) {\n\t\t\t\treturn results;\n\n\t\t\t// Precompiled matchers will still verify ancestry, so step up a level\n\t\t\t} else if ( compiled ) {\n\t\t\t\tcontext = context.parentNode;\n\t\t\t}\n\n\t\t\tselector = selector.slice( tokens.shift().value.length );\n\t\t}\n\n\t\t// Fetch a seed set for right-to-left matching\n\t\ti = matchExpr[\"needsContext\"].test( selector ) ? 0 : tokens.length;\n\t\twhile ( i-- ) {\n\t\t\ttoken = tokens[i];\n\n\t\t\t// Abort if we hit a combinator\n\t\t\tif ( Expr.relative[ (type = token.type) ] ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( (find = Expr.find[ type ]) ) {\n\t\t\t\t// Search, expanding context for leading sibling combinators\n\t\t\t\tif ( (seed = find(\n\t\t\t\t\ttoken.matches[0].replace( runescape, funescape ),\n\t\t\t\t\trsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context\n\t\t\t\t)) ) {\n\n\t\t\t\t\t// If seed is empty or no tokens remain, we can return early\n\t\t\t\t\ttokens.splice( i, 1 );\n\t\t\t\t\tselector = seed.length && toSelector( tokens );\n\t\t\t\t\tif ( !selector ) {\n\t\t\t\t\t\tpush.apply( results, seed );\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Compile and execute a filtering function if one is not provided\n\t// Provide `match` to avoid retokenization if we modified the selector above\n\t( compiled || compile( selector, match ) )(\n\t\tseed,\n\t\tcontext,\n\t\t!documentIsHTML,\n\t\tresults,\n\t\trsibling.test( selector ) && testContext( context.parentNode ) || context\n\t);\n\treturn results;\n};\n\n// One-time assignments\n\n// Sort stability\nsupport.sortStable = expando.split(\"\").sort( sortOrder ).join(\"\") === expando;\n\n// Support: Chrome 14-35+\n// Always assume duplicates if they aren't passed to the comparison function\nsupport.detectDuplicates = !!hasDuplicate;\n\n// Initialize against the default document\nsetDocument();\n\n// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\n// Detached nodes confoundingly follow *each other*\nsupport.sortDetached = assert(function( div1 ) {\n\t// Should return 1, but returns 4 (following)\n\treturn div1.compareDocumentPosition( document.createElement(\"div\") ) & 1;\n});\n\n// Support: IE<8\n// Prevent attribute/property \"interpolation\"\n// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\nif ( !assert(function( div ) {\n\tdiv.innerHTML = \"<a href='#'></a>\";\n\treturn div.firstChild.getAttribute(\"href\") === \"#\" ;\n}) ) {\n\taddHandle( \"type|href|height|width\", function( elem, name, isXML ) {\n\t\tif ( !isXML ) {\n\t\t\treturn elem.getAttribute( name, name.toLowerCase() === \"type\" ? 1 : 2 );\n\t\t}\n\t});\n}\n\n// Support: IE<9\n// Use defaultValue in place of getAttribute(\"value\")\nif ( !support.attributes || !assert(function( div ) {\n\tdiv.innerHTML = \"<input/>\";\n\tdiv.firstChild.setAttribute( \"value\", \"\" );\n\treturn div.firstChild.getAttribute( \"value\" ) === \"\";\n}) ) {\n\taddHandle( \"value\", function( elem, name, isXML ) {\n\t\tif ( !isXML && elem.nodeName.toLowerCase() === \"input\" ) {\n\t\t\treturn elem.defaultValue;\n\t\t}\n\t});\n}\n\n// Support: IE<9\n// Use getAttributeNode to fetch booleans when getAttribute lies\nif ( !assert(function( div ) {\n\treturn div.getAttribute(\"disabled\") == null;\n}) ) {\n\taddHandle( booleans, function( elem, name, isXML ) {\n\t\tvar val;\n\t\tif ( !isXML ) {\n\t\t\treturn elem[ name ] === true ? name.toLowerCase() :\n\t\t\t\t\t(val = elem.getAttributeNode( name )) && val.specified ?\n\t\t\t\t\tval.value :\n\t\t\t\tnull;\n\t\t}\n\t});\n}\n\nreturn Sizzle;\n\n})( window );\n\n\n\njQuery.find = Sizzle;\njQuery.expr = Sizzle.selectors;\njQuery.expr[\":\"] = jQuery.expr.pseudos;\njQuery.unique = Sizzle.uniqueSort;\njQuery.text = Sizzle.getText;\njQuery.isXMLDoc = Sizzle.isXML;\njQuery.contains = Sizzle.contains;\n\n\n\nvar rneedsContext = jQuery.expr.match.needsContext;\n\nvar rsingleTag = (/^<(\\w+)\\s*\\/?>(?:<\\/\\1>|)$/);\n\n\n\nvar risSimple = /^.[^:#\\[\\.,]*$/;\n\n// Implement the identical functionality for filter and not\nfunction winnow( elements, qualifier, not ) {\n\tif ( jQuery.isFunction( qualifier ) ) {\n\t\treturn jQuery.grep( elements, function( elem, i ) {\n\t\t\t/* jshint -W018 */\n\t\t\treturn !!qualifier.call( elem, i, elem ) !== not;\n\t\t});\n\n\t}\n\n\tif ( qualifier.nodeType ) {\n\t\treturn jQuery.grep( elements, function( elem ) {\n\t\t\treturn ( elem === qualifier ) !== not;\n\t\t});\n\n\t}\n\n\tif ( typeof qualifier === \"string\" ) {\n\t\tif ( risSimple.test( qualifier ) ) {\n\t\t\treturn jQuery.filter( qualifier, elements, not );\n\t\t}\n\n\t\tqualifier = jQuery.filter( qualifier, elements );\n\t}\n\n\treturn jQuery.grep( elements, function( elem ) {\n\t\treturn ( jQuery.inArray( elem, qualifier ) >= 0 ) !== not;\n\t});\n}\n\njQuery.filter = function( expr, elems, not ) {\n\tvar elem = elems[ 0 ];\n\n\tif ( not ) {\n\t\texpr = \":not(\" + expr + \")\";\n\t}\n\n\treturn elems.length === 1 && elem.nodeType === 1 ?\n\t\tjQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :\n\t\tjQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {\n\t\t\treturn elem.nodeType === 1;\n\t\t}));\n};\n\njQuery.fn.extend({\n\tfind: function( selector ) {\n\t\tvar i,\n\t\t\tret = [],\n\t\t\tself = this,\n\t\t\tlen = self.length;\n\n\t\tif ( typeof selector !== \"string\" ) {\n\t\t\treturn this.pushStack( jQuery( selector ).filter(function() {\n\t\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\t\tif ( jQuery.contains( self[ i ], this ) ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}) );\n\t\t}\n\n\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\tjQuery.find( selector, self[ i ], ret );\n\t\t}\n\n\t\t// Needed because $( selector, context ) becomes $( context ).find( selector )\n\t\tret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );\n\t\tret.selector = this.selector ? this.selector + \" \" + selector : selector;\n\t\treturn ret;\n\t},\n\tfilter: function( selector ) {\n\t\treturn this.pushStack( winnow(this, selector || [], false) );\n\t},\n\tnot: function( selector ) {\n\t\treturn this.pushStack( winnow(this, selector || [], true) );\n\t},\n\tis: function( selector ) {\n\t\treturn !!winnow(\n\t\t\tthis,\n\n\t\t\t// If this is a positional/relative selector, check membership in the returned set\n\t\t\t// so $(\"p:first\").is(\"p:last\") won't return true for a doc with two \"p\".\n\t\t\ttypeof selector === \"string\" && rneedsContext.test( selector ) ?\n\t\t\t\tjQuery( selector ) :\n\t\t\t\tselector || [],\n\t\t\tfalse\n\t\t).length;\n\t}\n});\n\n\n// Initialize a jQuery object\n\n\n// A central reference to the root jQuery(document)\nvar rootjQuery,\n\n\t// Use the correct document accordingly with window argument (sandbox)\n\tdocument = window.document,\n\n\t// A simple way to check for HTML strings\n\t// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\n\t// Strict HTML recognition (#11290: must start with <)\n\trquickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]*))$/,\n\n\tinit = jQuery.fn.init = function( selector, context ) {\n\t\tvar match, elem;\n\n\t\t// HANDLE: $(\"\"), $(null), $(undefined), $(false)\n\t\tif ( !selector ) {\n\t\t\treturn this;\n\t\t}\n\n\t\t// Handle HTML strings\n\t\tif ( typeof selector === \"string\" ) {\n\t\t\tif ( selector.charAt(0) === \"<\" && selector.charAt( selector.length - 1 ) === \">\" && selector.length >= 3 ) {\n\t\t\t\t// Assume that strings that start and end with <> are HTML and skip the regex check\n\t\t\t\tmatch = [ null, selector, null ];\n\n\t\t\t} else {\n\t\t\t\tmatch = rquickExpr.exec( selector );\n\t\t\t}\n\n\t\t\t// Match html or make sure no context is specified for #id\n\t\t\tif ( match && (match[1] || !context) ) {\n\n\t\t\t\t// HANDLE: $(html) -> $(array)\n\t\t\t\tif ( match[1] ) {\n\t\t\t\t\tcontext = context instanceof jQuery ? context[0] : context;\n\n\t\t\t\t\t// scripts is true for back-compat\n\t\t\t\t\t// Intentionally let the error be thrown if parseHTML is not present\n\t\t\t\t\tjQuery.merge( this, jQuery.parseHTML(\n\t\t\t\t\t\tmatch[1],\n\t\t\t\t\t\tcontext && context.nodeType ? context.ownerDocument || context : document,\n\t\t\t\t\t\ttrue\n\t\t\t\t\t) );\n\n\t\t\t\t\t// HANDLE: $(html, props)\n\t\t\t\t\tif ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {\n\t\t\t\t\t\tfor ( match in context ) {\n\t\t\t\t\t\t\t// Properties of context are called as methods if possible\n\t\t\t\t\t\t\tif ( jQuery.isFunction( this[ match ] ) ) {\n\t\t\t\t\t\t\t\tthis[ match ]( context[ match ] );\n\n\t\t\t\t\t\t\t// ...and otherwise set as attributes\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.attr( match, context[ match ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn this;\n\n\t\t\t\t// HANDLE: $(#id)\n\t\t\t\t} else {\n\t\t\t\t\telem = document.getElementById( match[2] );\n\n\t\t\t\t\t// Check parentNode to catch when Blackberry 4.6 returns\n\t\t\t\t\t// nodes that are no longer in the document #6963\n\t\t\t\t\tif ( elem && elem.parentNode ) {\n\t\t\t\t\t\t// Handle the case where IE and Opera return items\n\t\t\t\t\t\t// by name instead of ID\n\t\t\t\t\t\tif ( elem.id !== match[2] ) {\n\t\t\t\t\t\t\treturn rootjQuery.find( selector );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Otherwise, we inject the element directly into the jQuery object\n\t\t\t\t\t\tthis.length = 1;\n\t\t\t\t\t\tthis[0] = elem;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.context = document;\n\t\t\t\t\tthis.selector = selector;\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\n\t\t\t// HANDLE: $(expr, $(...))\n\t\t\t} else if ( !context || context.jquery ) {\n\t\t\t\treturn ( context || rootjQuery ).find( selector );\n\n\t\t\t// HANDLE: $(expr, context)\n\t\t\t// (which is just equivalent to: $(context).find(expr)\n\t\t\t} else {\n\t\t\t\treturn this.constructor( context ).find( selector );\n\t\t\t}\n\n\t\t// HANDLE: $(DOMElement)\n\t\t} else if ( selector.nodeType ) {\n\t\t\tthis.context = this[0] = selector;\n\t\t\tthis.length = 1;\n\t\t\treturn this;\n\n\t\t// HANDLE: $(function)\n\t\t// Shortcut for document ready\n\t\t} else if ( jQuery.isFunction( selector ) ) {\n\t\t\treturn typeof rootjQuery.ready !== \"undefined\" ?\n\t\t\t\trootjQuery.ready( selector ) :\n\t\t\t\t// Execute immediately if ready is not present\n\t\t\t\tselector( jQuery );\n\t\t}\n\n\t\tif ( selector.selector !== undefined ) {\n\t\t\tthis.selector = selector.selector;\n\t\t\tthis.context = selector.context;\n\t\t}\n\n\t\treturn jQuery.makeArray( selector, this );\n\t};\n\n// Give the init function the jQuery prototype for later instantiation\ninit.prototype = jQuery.fn;\n\n// Initialize central reference\nrootjQuery = jQuery( document );\n\n\nvar rparentsprev = /^(?:parents|prev(?:Until|All))/,\n\t// methods guaranteed to produce a unique set when starting from a unique set\n\tguaranteedUnique = {\n\t\tchildren: true,\n\t\tcontents: true,\n\t\tnext: true,\n\t\tprev: true\n\t};\n\njQuery.extend({\n\tdir: function( elem, dir, until ) {\n\t\tvar matched = [],\n\t\t\tcur = elem[ dir ];\n\n\t\twhile ( cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery( cur ).is( until )) ) {\n\t\t\tif ( cur.nodeType === 1 ) {\n\t\t\t\tmatched.push( cur );\n\t\t\t}\n\t\t\tcur = cur[dir];\n\t\t}\n\t\treturn matched;\n\t},\n\n\tsibling: function( n, elem ) {\n\t\tvar r = [];\n\n\t\tfor ( ; n; n = n.nextSibling ) {\n\t\t\tif ( n.nodeType === 1 && n !== elem ) {\n\t\t\t\tr.push( n );\n\t\t\t}\n\t\t}\n\n\t\treturn r;\n\t}\n});\n\njQuery.fn.extend({\n\thas: function( target ) {\n\t\tvar i,\n\t\t\ttargets = jQuery( target, this ),\n\t\t\tlen = targets.length;\n\n\t\treturn this.filter(function() {\n\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\tif ( jQuery.contains( this, targets[i] ) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t},\n\n\tclosest: function( selectors, context ) {\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\tl = this.length,\n\t\t\tmatched = [],\n\t\t\tpos = rneedsContext.test( selectors ) || typeof selectors !== \"string\" ?\n\t\t\t\tjQuery( selectors, context || this.context ) :\n\t\t\t\t0;\n\n\t\tfor ( ; i < l; i++ ) {\n\t\t\tfor ( cur = this[i]; cur && cur !== context; cur = cur.parentNode ) {\n\t\t\t\t// Always skip document fragments\n\t\t\t\tif ( cur.nodeType < 11 && (pos ?\n\t\t\t\t\tpos.index(cur) > -1 :\n\n\t\t\t\t\t// Don't pass non-elements to Sizzle\n\t\t\t\t\tcur.nodeType === 1 &&\n\t\t\t\t\t\tjQuery.find.matchesSelector(cur, selectors)) ) {\n\n\t\t\t\t\tmatched.push( cur );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this.pushStack( matched.length > 1 ? jQuery.unique( matched ) : matched );\n\t},\n\n\t// Determine the position of an element within\n\t// the matched set of elements\n\tindex: function( elem ) {\n\n\t\t// No argument, return index in parent\n\t\tif ( !elem ) {\n\t\t\treturn ( this[0] && this[0].parentNode ) ? this.first().prevAll().length : -1;\n\t\t}\n\n\t\t// index in selector\n\t\tif ( typeof elem === \"string\" ) {\n\t\t\treturn jQuery.inArray( this[0], jQuery( elem ) );\n\t\t}\n\n\t\t// Locate the position of the desired element\n\t\treturn jQuery.inArray(\n\t\t\t// If it receives a jQuery object, the first element is used\n\t\t\telem.jquery ? elem[0] : elem, this );\n\t},\n\n\tadd: function( selector, context ) {\n\t\treturn this.pushStack(\n\t\t\tjQuery.unique(\n\t\t\t\tjQuery.merge( this.get(), jQuery( selector, context ) )\n\t\t\t)\n\t\t);\n\t},\n\n\taddBack: function( selector ) {\n\t\treturn this.add( selector == null ?\n\t\t\tthis.prevObject : this.prevObject.filter(selector)\n\t\t);\n\t}\n});\n\nfunction sibling( cur, dir ) {\n\tdo {\n\t\tcur = cur[ dir ];\n\t} while ( cur && cur.nodeType !== 1 );\n\n\treturn cur;\n}\n\njQuery.each({\n\tparent: function( elem ) {\n\t\tvar parent = elem.parentNode;\n\t\treturn parent && parent.nodeType !== 11 ? parent : null;\n\t},\n\tparents: function( elem ) {\n\t\treturn jQuery.dir( elem, \"parentNode\" );\n\t},\n\tparentsUntil: function( elem, i, until ) {\n\t\treturn jQuery.dir( elem, \"parentNode\", until );\n\t},\n\tnext: function( elem ) {\n\t\treturn sibling( elem, \"nextSibling\" );\n\t},\n\tprev: function( elem ) {\n\t\treturn sibling( elem, \"previousSibling\" );\n\t},\n\tnextAll: function( elem ) {\n\t\treturn jQuery.dir( elem, \"nextSibling\" );\n\t},\n\tprevAll: function( elem ) {\n\t\treturn jQuery.dir( elem, \"previousSibling\" );\n\t},\n\tnextUntil: function( elem, i, until ) {\n\t\treturn jQuery.dir( elem, \"nextSibling\", until );\n\t},\n\tprevUntil: function( elem, i, until ) {\n\t\treturn jQuery.dir( elem, \"previousSibling\", until );\n\t},\n\tsiblings: function( elem ) {\n\t\treturn jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );\n\t},\n\tchildren: function( elem ) {\n\t\treturn jQuery.sibling( elem.firstChild );\n\t},\n\tcontents: function( elem ) {\n\t\treturn jQuery.nodeName( elem, \"iframe\" ) ?\n\t\t\telem.contentDocument || elem.contentWindow.document :\n\t\t\tjQuery.merge( [], elem.childNodes );\n\t}\n}, function( name, fn ) {\n\tjQuery.fn[ name ] = function( until, selector ) {\n\t\tvar ret = jQuery.map( this, fn, until );\n\n\t\tif ( name.slice( -5 ) !== \"Until\" ) {\n\t\t\tselector = until;\n\t\t}\n\n\t\tif ( selector && typeof selector === \"string\" ) {\n\t\t\tret = jQuery.filter( selector, ret );\n\t\t}\n\n\t\tif ( this.length > 1 ) {\n\t\t\t// Remove duplicates\n\t\t\tif ( !guaranteedUnique[ name ] ) {\n\t\t\t\tret = jQuery.unique( ret );\n\t\t\t}\n\n\t\t\t// Reverse order for parents* and prev-derivatives\n\t\t\tif ( rparentsprev.test( name ) ) {\n\t\t\t\tret = ret.reverse();\n\t\t\t}\n\t\t}\n\n\t\treturn this.pushStack( ret );\n\t};\n});\nvar rnotwhite = (/\\S+/g);\n\n\n\n// String to Object options format cache\nvar optionsCache = {};\n\n// Convert String-formatted options into Object-formatted ones and store in cache\nfunction createOptions( options ) {\n\tvar object = optionsCache[ options ] = {};\n\tjQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {\n\t\tobject[ flag ] = true;\n\t});\n\treturn object;\n}\n\n/*\n * Create a callback list using the following parameters:\n *\n *\toptions: an optional list of space-separated options that will change how\n *\t\t\tthe callback list behaves or a more traditional option object\n *\n * By default a callback list will act like an event callback list and can be\n * \"fired\" multiple times.\n *\n * Possible options:\n *\n *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n *\n *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\n *\t\t\t\t\tvalues (like a Deferred)\n *\n *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n *\n *\tstopOnFalse:\tinterrupt callings when a callback returns false\n *\n */\njQuery.Callbacks = function( options ) {\n\n\t// Convert options from String-formatted to Object-formatted if needed\n\t// (we check in cache first)\n\toptions = typeof options === \"string\" ?\n\t\t( optionsCache[ options ] || createOptions( options ) ) :\n\t\tjQuery.extend( {}, options );\n\n\tvar // Flag to know if list is currently firing\n\t\tfiring,\n\t\t// Last fire value (for non-forgettable lists)\n\t\tmemory,\n\t\t// Flag to know if list was already fired\n\t\tfired,\n\t\t// End of the loop when firing\n\t\tfiringLength,\n\t\t// Index of currently firing callback (modified by remove if needed)\n\t\tfiringIndex,\n\t\t// First callback to fire (used internally by add and fireWith)\n\t\tfiringStart,\n\t\t// Actual callback list\n\t\tlist = [],\n\t\t// Stack of fire calls for repeatable lists\n\t\tstack = !options.once && [],\n\t\t// Fire callbacks\n\t\tfire = function( data ) {\n\t\t\tmemory = options.memory && data;\n\t\t\tfired = true;\n\t\t\tfiringIndex = firingStart || 0;\n\t\t\tfiringStart = 0;\n\t\t\tfiringLength = list.length;\n\t\t\tfiring = true;\n\t\t\tfor ( ; list && firingIndex < firingLength; firingIndex++ ) {\n\t\t\t\tif ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {\n\t\t\t\t\tmemory = false; // To prevent further calls using add\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfiring = false;\n\t\t\tif ( list ) {\n\t\t\t\tif ( stack ) {\n\t\t\t\t\tif ( stack.length ) {\n\t\t\t\t\t\tfire( stack.shift() );\n\t\t\t\t\t}\n\t\t\t\t} else if ( memory ) {\n\t\t\t\t\tlist = [];\n\t\t\t\t} else {\n\t\t\t\t\tself.disable();\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t// Actual Callbacks object\n\t\tself = {\n\t\t\t// Add a callback or a collection of callbacks to the list\n\t\t\tadd: function() {\n\t\t\t\tif ( list ) {\n\t\t\t\t\t// First, we save the current length\n\t\t\t\t\tvar start = list.length;\n\t\t\t\t\t(function add( args ) {\n\t\t\t\t\t\tjQuery.each( args, function( _, arg ) {\n\t\t\t\t\t\t\tvar type = jQuery.type( arg );\n\t\t\t\t\t\t\tif ( type === \"function\" ) {\n\t\t\t\t\t\t\t\tif ( !options.unique || !self.has( arg ) ) {\n\t\t\t\t\t\t\t\t\tlist.push( arg );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if ( arg && arg.length && type !== \"string\" ) {\n\t\t\t\t\t\t\t\t// Inspect recursively\n\t\t\t\t\t\t\t\tadd( arg );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t})( arguments );\n\t\t\t\t\t// Do we need to add the callbacks to the\n\t\t\t\t\t// current firing batch?\n\t\t\t\t\tif ( firing ) {\n\t\t\t\t\t\tfiringLength = list.length;\n\t\t\t\t\t// With memory, if we're not firing then\n\t\t\t\t\t// we should call right away\n\t\t\t\t\t} else if ( memory ) {\n\t\t\t\t\t\tfiringStart = start;\n\t\t\t\t\t\tfire( memory );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Remove a callback from the list\n\t\t\tremove: function() {\n\t\t\t\tif ( list ) {\n\t\t\t\t\tjQuery.each( arguments, function( _, arg ) {\n\t\t\t\t\t\tvar index;\n\t\t\t\t\t\twhile ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {\n\t\t\t\t\t\t\tlist.splice( index, 1 );\n\t\t\t\t\t\t\t// Handle firing indexes\n\t\t\t\t\t\t\tif ( firing ) {\n\t\t\t\t\t\t\t\tif ( index <= firingLength ) {\n\t\t\t\t\t\t\t\t\tfiringLength--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif ( index <= firingIndex ) {\n\t\t\t\t\t\t\t\t\tfiringIndex--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Check if a given callback is in the list.\n\t\t\t// If no argument is given, return whether or not list has callbacks attached.\n\t\t\thas: function( fn ) {\n\t\t\t\treturn fn ? jQuery.inArray( fn, list ) > -1 : !!( list && list.length );\n\t\t\t},\n\t\t\t// Remove all callbacks from the list\n\t\t\tempty: function() {\n\t\t\t\tlist = [];\n\t\t\t\tfiringLength = 0;\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Have the list do nothing anymore\n\t\t\tdisable: function() {\n\t\t\t\tlist = stack = memory = undefined;\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Is it disabled?\n\t\t\tdisabled: function() {\n\t\t\t\treturn !list;\n\t\t\t},\n\t\t\t// Lock the list in its current state\n\t\t\tlock: function() {\n\t\t\t\tstack = undefined;\n\t\t\t\tif ( !memory ) {\n\t\t\t\t\tself.disable();\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Is it locked?\n\t\t\tlocked: function() {\n\t\t\t\treturn !stack;\n\t\t\t},\n\t\t\t// Call all callbacks with the given context and arguments\n\t\t\tfireWith: function( context, args ) {\n\t\t\t\tif ( list && ( !fired || stack ) ) {\n\t\t\t\t\targs = args || [];\n\t\t\t\t\targs = [ context, args.slice ? args.slice() : args ];\n\t\t\t\t\tif ( firing ) {\n\t\t\t\t\t\tstack.push( args );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfire( args );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Call all the callbacks with the given arguments\n\t\t\tfire: function() {\n\t\t\t\tself.fireWith( this, arguments );\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// To know if the callbacks have already been called at least once\n\t\t\tfired: function() {\n\t\t\t\treturn !!fired;\n\t\t\t}\n\t\t};\n\n\treturn self;\n};\n\n\njQuery.extend({\n\n\tDeferred: function( func ) {\n\t\tvar tuples = [\n\t\t\t\t// action, add listener, listener list, final state\n\t\t\t\t[ \"resolve\", \"done\", jQuery.Callbacks(\"once memory\"), \"resolved\" ],\n\t\t\t\t[ \"reject\", \"fail\", jQuery.Callbacks(\"once memory\"), \"rejected\" ],\n\t\t\t\t[ \"notify\", \"progress\", jQuery.Callbacks(\"memory\") ]\n\t\t\t],\n\t\t\tstate = \"pending\",\n\t\t\tpromise = {\n\t\t\t\tstate: function() {\n\t\t\t\t\treturn state;\n\t\t\t\t},\n\t\t\t\talways: function() {\n\t\t\t\t\tdeferred.done( arguments ).fail( arguments );\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\tthen: function( /* fnDone, fnFail, fnProgress */ ) {\n\t\t\t\t\tvar fns = arguments;\n\t\t\t\t\treturn jQuery.Deferred(function( newDefer ) {\n\t\t\t\t\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\t\t\t\t\t\tvar fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];\n\t\t\t\t\t\t\t// deferred[ done | fail | progress ] for forwarding actions to newDefer\n\t\t\t\t\t\t\tdeferred[ tuple[1] ](function() {\n\t\t\t\t\t\t\t\tvar returned = fn && fn.apply( this, arguments );\n\t\t\t\t\t\t\t\tif ( returned && jQuery.isFunction( returned.promise ) ) {\n\t\t\t\t\t\t\t\t\treturned.promise()\n\t\t\t\t\t\t\t\t\t\t.done( newDefer.resolve )\n\t\t\t\t\t\t\t\t\t\t.fail( newDefer.reject )\n\t\t\t\t\t\t\t\t\t\t.progress( newDefer.notify );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tnewDefer[ tuple[ 0 ] + \"With\" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t\tfns = null;\n\t\t\t\t\t}).promise();\n\t\t\t\t},\n\t\t\t\t// Get a promise for this deferred\n\t\t\t\t// If obj is provided, the promise aspect is added to the object\n\t\t\t\tpromise: function( obj ) {\n\t\t\t\t\treturn obj != null ? jQuery.extend( obj, promise ) : promise;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdeferred = {};\n\n\t\t// Keep pipe for back-compat\n\t\tpromise.pipe = promise.then;\n\n\t\t// Add list-specific methods\n\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\t\tvar list = tuple[ 2 ],\n\t\t\t\tstateString = tuple[ 3 ];\n\n\t\t\t// promise[ done | fail | progress ] = list.add\n\t\t\tpromise[ tuple[1] ] = list.add;\n\n\t\t\t// Handle state\n\t\t\tif ( stateString ) {\n\t\t\t\tlist.add(function() {\n\t\t\t\t\t// state = [ resolved | rejected ]\n\t\t\t\t\tstate = stateString;\n\n\t\t\t\t// [ reject_list | resolve_list ].disable; progress_list.lock\n\t\t\t\t}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );\n\t\t\t}\n\n\t\t\t// deferred[ resolve | reject | notify ]\n\t\t\tdeferred[ tuple[0] ] = function() {\n\t\t\t\tdeferred[ tuple[0] + \"With\" ]( this === deferred ? promise : this, arguments );\n\t\t\t\treturn this;\n\t\t\t};\n\t\t\tdeferred[ tuple[0] + \"With\" ] = list.fireWith;\n\t\t});\n\n\t\t// Make the deferred a promise\n\t\tpromise.promise( deferred );\n\n\t\t// Call given func if any\n\t\tif ( func ) {\n\t\t\tfunc.call( deferred, deferred );\n\t\t}\n\n\t\t// All done!\n\t\treturn deferred;\n\t},\n\n\t// Deferred helper\n\twhen: function( subordinate /* , ..., subordinateN */ ) {\n\t\tvar i = 0,\n\t\t\tresolveValues = slice.call( arguments ),\n\t\t\tlength = resolveValues.length,\n\n\t\t\t// the count of uncompleted subordinates\n\t\t\tremaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,\n\n\t\t\t// the master Deferred. If resolveValues consist of only a single Deferred, just use that.\n\t\t\tdeferred = remaining === 1 ? subordinate : jQuery.Deferred(),\n\n\t\t\t// Update function for both resolve and progress values\n\t\t\tupdateFunc = function( i, contexts, values ) {\n\t\t\t\treturn function( value ) {\n\t\t\t\t\tcontexts[ i ] = this;\n\t\t\t\t\tvalues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;\n\t\t\t\t\tif ( values === progressValues ) {\n\t\t\t\t\t\tdeferred.notifyWith( contexts, values );\n\n\t\t\t\t\t} else if ( !(--remaining) ) {\n\t\t\t\t\t\tdeferred.resolveWith( contexts, values );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t},\n\n\t\t\tprogressValues, progressContexts, resolveContexts;\n\n\t\t// add listeners to Deferred subordinates; treat others as resolved\n\t\tif ( length > 1 ) {\n\t\t\tprogressValues = new Array( length );\n\t\t\tprogressContexts = new Array( length );\n\t\t\tresolveContexts = new Array( length );\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tif ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {\n\t\t\t\t\tresolveValues[ i ].promise()\n\t\t\t\t\t\t.done( updateFunc( i, resolveContexts, resolveValues ) )\n\t\t\t\t\t\t.fail( deferred.reject )\n\t\t\t\t\t\t.progress( updateFunc( i, progressContexts, progressValues ) );\n\t\t\t\t} else {\n\t\t\t\t\t--remaining;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// if we're not waiting on anything, resolve the master\n\t\tif ( !remaining ) {\n\t\t\tdeferred.resolveWith( resolveContexts, resolveValues );\n\t\t}\n\n\t\treturn deferred.promise();\n\t}\n});\n\n\n// The deferred used on DOM ready\nvar readyList;\n\njQuery.fn.ready = function( fn ) {\n\t// Add the callback\n\tjQuery.ready.promise().done( fn );\n\n\treturn this;\n};\n\njQuery.extend({\n\t// Is the DOM ready to be used? Set to true once it occurs.\n\tisReady: false,\n\n\t// A counter to track how many items to wait for before\n\t// the ready event fires. See #6781\n\treadyWait: 1,\n\n\t// Hold (or release) the ready event\n\tholdReady: function( hold ) {\n\t\tif ( hold ) {\n\t\t\tjQuery.readyWait++;\n\t\t} else {\n\t\t\tjQuery.ready( true );\n\t\t}\n\t},\n\n\t// Handle when the DOM is ready\n\tready: function( wait ) {\n\n\t\t// Abort if there are pending holds or we're already ready\n\t\tif ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).\n\t\tif ( !document.body ) {\n\t\t\treturn setTimeout( jQuery.ready );\n\t\t}\n\n\t\t// Remember that the DOM is ready\n\t\tjQuery.isReady = true;\n\n\t\t// If a normal DOM Ready event fired, decrement, and wait if need be\n\t\tif ( wait !== true && --jQuery.readyWait > 0 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If there are functions bound, to execute\n\t\treadyList.resolveWith( document, [ jQuery ] );\n\n\t\t// Trigger any bound ready events\n\t\tif ( jQuery.fn.triggerHandler ) {\n\t\t\tjQuery( document ).triggerHandler( \"ready\" );\n\t\t\tjQuery( document ).off( \"ready\" );\n\t\t}\n\t}\n});\n\n/**\n * Clean-up method for dom ready events\n */\nfunction detach() {\n\tif ( document.addEventListener ) {\n\t\tdocument.removeEventListener( \"DOMContentLoaded\", completed, false );\n\t\twindow.removeEventListener( \"load\", completed, false );\n\n\t} else {\n\t\tdocument.detachEvent( \"onreadystatechange\", completed );\n\t\twindow.detachEvent( \"onload\", completed );\n\t}\n}\n\n/**\n * The ready event handler and self cleanup method\n */\nfunction completed() {\n\t// readyState === \"complete\" is good enough for us to call the dom ready in oldIE\n\tif ( document.addEventListener || event.type === \"load\" || document.readyState === \"complete\" ) {\n\t\tdetach();\n\t\tjQuery.ready();\n\t}\n}\n\njQuery.ready.promise = function( obj ) {\n\tif ( !readyList ) {\n\n\t\treadyList = jQuery.Deferred();\n\n\t\t// Catch cases where $(document).ready() is called after the browser event has already occurred.\n\t\t// we once tried to use readyState \"interactive\" here, but it caused issues like the one\n\t\t// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15\n\t\tif ( document.readyState === \"complete\" ) {\n\t\t\t// Handle it asynchronously to allow scripts the opportunity to delay ready\n\t\t\tsetTimeout( jQuery.ready );\n\n\t\t// Standards-based browsers support DOMContentLoaded\n\t\t} else if ( document.addEventListener ) {\n\t\t\t// Use the handy event callback\n\t\t\tdocument.addEventListener( \"DOMContentLoaded\", completed, false );\n\n\t\t\t// A fallback to window.onload, that will always work\n\t\t\twindow.addEventListener( \"load\", completed, false );\n\n\t\t// If IE event model is used\n\t\t} else {\n\t\t\t// Ensure firing before onload, maybe late but safe also for iframes\n\t\t\tdocument.attachEvent( \"onreadystatechange\", completed );\n\n\t\t\t// A fallback to window.onload, that will always work\n\t\t\twindow.attachEvent( \"onload\", completed );\n\n\t\t\t// If IE and not a frame\n\t\t\t// continually check to see if the document is ready\n\t\t\tvar top = false;\n\n\t\t\ttry {\n\t\t\t\ttop = window.frameElement == null && document.documentElement;\n\t\t\t} catch(e) {}\n\n\t\t\tif ( top && top.doScroll ) {\n\t\t\t\t(function doScrollCheck() {\n\t\t\t\t\tif ( !jQuery.isReady ) {\n\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t// Use the trick by Diego Perini\n\t\t\t\t\t\t\t// http://javascript.nwbox.com/IEContentLoaded/\n\t\t\t\t\t\t\ttop.doScroll(\"left\");\n\t\t\t\t\t\t} catch(e) {\n\t\t\t\t\t\t\treturn setTimeout( doScrollCheck, 50 );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// detach all dom ready events\n\t\t\t\t\t\tdetach();\n\n\t\t\t\t\t\t// and execute any waiting functions\n\t\t\t\t\t\tjQuery.ready();\n\t\t\t\t\t}\n\t\t\t\t})();\n\t\t\t}\n\t\t}\n\t}\n\treturn readyList.promise( obj );\n};\n\n\nvar strundefined = typeof undefined;\n\n\n\n// Support: IE<9\n// Iteration over object's inherited properties before its own\nvar i;\nfor ( i in jQuery( support ) ) {\n\tbreak;\n}\nsupport.ownLast = i !== \"0\";\n\n// Note: most support tests are defined in their respective modules.\n// false until the test is run\nsupport.inlineBlockNeedsLayout = false;\n\n// Execute ASAP in case we need to set body.style.zoom\njQuery(function() {\n\t// Minified: var a,b,c,d\n\tvar val, div, body, container;\n\n\tbody = document.getElementsByTagName( \"body\" )[ 0 ];\n\tif ( !body || !body.style ) {\n\t\t// Return for frameset docs that don't have a body\n\t\treturn;\n\t}\n\n\t// Setup\n\tdiv = document.createElement( \"div\" );\n\tcontainer = document.createElement( \"div\" );\n\tcontainer.style.cssText = \"position:absolute;border:0;width:0;height:0;top:0;left:-9999px\";\n\tbody.appendChild( container ).appendChild( div );\n\n\tif ( typeof div.style.zoom !== strundefined ) {\n\t\t// Support: IE<8\n\t\t// Check if natively block-level elements act like inline-block\n\t\t// elements when setting their display to 'inline' and giving\n\t\t// them layout\n\t\tdiv.style.cssText = \"display:inline;margin:0;border:0;padding:1px;width:1px;zoom:1\";\n\n\t\tsupport.inlineBlockNeedsLayout = val = div.offsetWidth === 3;\n\t\tif ( val ) {\n\t\t\t// Prevent IE 6 from affecting layout for positioned elements #11048\n\t\t\t// Prevent IE from shrinking the body in IE 7 mode #12869\n\t\t\t// Support: IE<8\n\t\t\tbody.style.zoom = 1;\n\t\t}\n\t}\n\n\tbody.removeChild( container );\n});\n\n\n\n\n(function() {\n\tvar div = document.createElement( \"div\" );\n\n\t// Execute the test only if not already executed in another module.\n\tif (support.deleteExpando == null) {\n\t\t// Support: IE<9\n\t\tsupport.deleteExpando = true;\n\t\ttry {\n\t\t\tdelete div.test;\n\t\t} catch( e ) {\n\t\t\tsupport.deleteExpando = false;\n\t\t}\n\t}\n\n\t// Null elements to avoid leaks in IE.\n\tdiv = null;\n})();\n\n\n/**\n * Determines whether an object can have data\n */\njQuery.acceptData = function( elem ) {\n\tvar noData = jQuery.noData[ (elem.nodeName + \" \").toLowerCase() ],\n\t\tnodeType = +elem.nodeType || 1;\n\n\t// Do not set data on non-element DOM nodes because it will not be cleared (#8335).\n\treturn nodeType !== 1 && nodeType !== 9 ?\n\t\tfalse :\n\n\t\t// Nodes accept data unless otherwise specified; rejection can be conditional\n\t\t!noData || noData !== true && elem.getAttribute(\"classid\") === noData;\n};\n\n\nvar rbrace = /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,\n\trmultiDash = /([A-Z])/g;\n\nfunction dataAttr( elem, key, data ) {\n\t// If nothing was found internally, try to fetch any\n\t// data from the HTML5 data-* attribute\n\tif ( data === undefined && elem.nodeType === 1 ) {\n\n\t\tvar name = \"data-\" + key.replace( rmultiDash, \"-$1\" ).toLowerCase();\n\n\t\tdata = elem.getAttribute( name );\n\n\t\tif ( typeof data === \"string\" ) {\n\t\t\ttry {\n\t\t\t\tdata = data === \"true\" ? true :\n\t\t\t\t\tdata === \"false\" ? false :\n\t\t\t\t\tdata === \"null\" ? null :\n\t\t\t\t\t// Only convert to a number if it doesn't change the string\n\t\t\t\t\t+data + \"\" === data ? +data :\n\t\t\t\t\trbrace.test( data ) ? jQuery.parseJSON( data ) :\n\t\t\t\t\tdata;\n\t\t\t} catch( e ) {}\n\n\t\t\t// Make sure we set the data so it isn't changed later\n\t\t\tjQuery.data( elem, key, data );\n\n\t\t} else {\n\t\t\tdata = undefined;\n\t\t}\n\t}\n\n\treturn data;\n}\n\n// checks a cache object for emptiness\nfunction isEmptyDataObject( obj ) {\n\tvar name;\n\tfor ( name in obj ) {\n\n\t\t// if the public data object is empty, the private is still empty\n\t\tif ( name === \"data\" && jQuery.isEmptyObject( obj[name] ) ) {\n\t\t\tcontinue;\n\t\t}\n\t\tif ( name !== \"toJSON\" ) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nfunction internalData( elem, name, data, pvt /* Internal Use Only */ ) {\n\tif ( !jQuery.acceptData( elem ) ) {\n\t\treturn;\n\t}\n\n\tvar ret, thisCache,\n\t\tinternalKey = jQuery.expando,\n\n\t\t// We have to handle DOM nodes and JS objects differently because IE6-7\n\t\t// can't GC object references properly across the DOM-JS boundary\n\t\tisNode = elem.nodeType,\n\n\t\t// Only DOM nodes need the global jQuery cache; JS object data is\n\t\t// attached directly to the object so GC can occur automatically\n\t\tcache = isNode ? jQuery.cache : elem,\n\n\t\t// Only defining an ID for JS objects if its cache already exists allows\n\t\t// the code to shortcut on the same path as a DOM node with no cache\n\t\tid = isNode ? elem[ internalKey ] : elem[ internalKey ] && internalKey;\n\n\t// Avoid doing any more work than we need to when trying to get data on an\n\t// object that has no data at all\n\tif ( (!id || !cache[id] || (!pvt && !cache[id].data)) && data === undefined && typeof name === \"string\" ) {\n\t\treturn;\n\t}\n\n\tif ( !id ) {\n\t\t// Only DOM nodes need a new unique ID for each element since their data\n\t\t// ends up in the global cache\n\t\tif ( isNode ) {\n\t\t\tid = elem[ internalKey ] = deletedIds.pop() || jQuery.guid++;\n\t\t} else {\n\t\t\tid = internalKey;\n\t\t}\n\t}\n\n\tif ( !cache[ id ] ) {\n\t\t// Avoid exposing jQuery metadata on plain JS objects when the object\n\t\t// is serialized using JSON.stringify\n\t\tcache[ id ] = isNode ? {} : { toJSON: jQuery.noop };\n\t}\n\n\t// An object can be passed to jQuery.data instead of a key/value pair; this gets\n\t// shallow copied over onto the existing cache\n\tif ( typeof name === \"object\" || typeof name === \"function\" ) {\n\t\tif ( pvt ) {\n\t\t\tcache[ id ] = jQuery.extend( cache[ id ], name );\n\t\t} else {\n\t\t\tcache[ id ].data = jQuery.extend( cache[ id ].data, name );\n\t\t}\n\t}\n\n\tthisCache = cache[ id ];\n\n\t// jQuery data() is stored in a separate object inside the object's internal data\n\t// cache in order to avoid key collisions between internal data and user-defined\n\t// data.\n\tif ( !pvt ) {\n\t\tif ( !thisCache.data ) {\n\t\t\tthisCache.data = {};\n\t\t}\n\n\t\tthisCache = thisCache.data;\n\t}\n\n\tif ( data !== undefined ) {\n\t\tthisCache[ jQuery.camelCase( name ) ] = data;\n\t}\n\n\t// Check for both converted-to-camel and non-converted data property names\n\t// If a data property was specified\n\tif ( typeof name === \"string\" ) {\n\n\t\t// First Try to find as-is property data\n\t\tret = thisCache[ name ];\n\n\t\t// Test for null|undefined property data\n\t\tif ( ret == null ) {\n\n\t\t\t// Try to find the camelCased property\n\t\t\tret = thisCache[ jQuery.camelCase( name ) ];\n\t\t}\n\t} else {\n\t\tret = thisCache;\n\t}\n\n\treturn ret;\n}\n\nfunction internalRemoveData( elem, name, pvt ) {\n\tif ( !jQuery.acceptData( elem ) ) {\n\t\treturn;\n\t}\n\n\tvar thisCache, i,\n\t\tisNode = elem.nodeType,\n\n\t\t// See jQuery.data for more information\n\t\tcache = isNode ? jQuery.cache : elem,\n\t\tid = isNode ? elem[ jQuery.expando ] : jQuery.expando;\n\n\t// If there is already no cache entry for this object, there is no\n\t// purpose in continuing\n\tif ( !cache[ id ] ) {\n\t\treturn;\n\t}\n\n\tif ( name ) {\n\n\t\tthisCache = pvt ? cache[ id ] : cache[ id ].data;\n\n\t\tif ( thisCache ) {\n\n\t\t\t// Support array or space separated string names for data keys\n\t\t\tif ( !jQuery.isArray( name ) ) {\n\n\t\t\t\t// try the string as a key before any manipulation\n\t\t\t\tif ( name in thisCache ) {\n\t\t\t\t\tname = [ name ];\n\t\t\t\t} else {\n\n\t\t\t\t\t// split the camel cased version by spaces unless a key with the spaces exists\n\t\t\t\t\tname = jQuery.camelCase( name );\n\t\t\t\t\tif ( name in thisCache ) {\n\t\t\t\t\t\tname = [ name ];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tname = name.split(\" \");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// If \"name\" is an array of keys...\n\t\t\t\t// When data is initially created, via (\"key\", \"val\") signature,\n\t\t\t\t// keys will be converted to camelCase.\n\t\t\t\t// Since there is no way to tell _how_ a key was added, remove\n\t\t\t\t// both plain key and camelCase key. #12786\n\t\t\t\t// This will only penalize the array argument path.\n\t\t\t\tname = name.concat( jQuery.map( name, jQuery.camelCase ) );\n\t\t\t}\n\n\t\t\ti = name.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tdelete thisCache[ name[i] ];\n\t\t\t}\n\n\t\t\t// If there is no data left in the cache, we want to continue\n\t\t\t// and let the cache object itself get destroyed\n\t\t\tif ( pvt ? !isEmptyDataObject(thisCache) : !jQuery.isEmptyObject(thisCache) ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\t// See jQuery.data for more information\n\tif ( !pvt ) {\n\t\tdelete cache[ id ].data;\n\n\t\t// Don't destroy the parent cache unless the internal data object\n\t\t// had been the only thing left in it\n\t\tif ( !isEmptyDataObject( cache[ id ] ) ) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// Destroy the cache\n\tif ( isNode ) {\n\t\tjQuery.cleanData( [ elem ], true );\n\n\t// Use delete when supported for expandos or `cache` is not a window per isWindow (#10080)\n\t/* jshint eqeqeq: false */\n\t} else if ( support.deleteExpando || cache != cache.window ) {\n\t\t/* jshint eqeqeq: true */\n\t\tdelete cache[ id ];\n\n\t// When all else fails, null\n\t} else {\n\t\tcache[ id ] = null;\n\t}\n}\n\njQuery.extend({\n\tcache: {},\n\n\t// The following elements (space-suffixed to avoid Object.prototype collisions)\n\t// throw uncatchable exceptions if you attempt to set expando properties\n\tnoData: {\n\t\t\"applet \": true,\n\t\t\"embed \": true,\n\t\t// ...but Flash objects (which have this classid) *can* handle expandos\n\t\t\"object \": \"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000\"\n\t},\n\n\thasData: function( elem ) {\n\t\telem = elem.nodeType ? jQuery.cache[ elem[jQuery.expando] ] : elem[ jQuery.expando ];\n\t\treturn !!elem && !isEmptyDataObject( elem );\n\t},\n\n\tdata: function( elem, name, data ) {\n\t\treturn internalData( elem, name, data );\n\t},\n\n\tremoveData: function( elem, name ) {\n\t\treturn internalRemoveData( elem, name );\n\t},\n\n\t// For internal use only.\n\t_data: function( elem, name, data ) {\n\t\treturn internalData( elem, name, data, true );\n\t},\n\n\t_removeData: function( elem, name ) {\n\t\treturn internalRemoveData( elem, name, true );\n\t}\n});\n\njQuery.fn.extend({\n\tdata: function( key, value ) {\n\t\tvar i, name, data,\n\t\t\telem = this[0],\n\t\t\tattrs = elem && elem.attributes;\n\n\t\t// Special expections of .data basically thwart jQuery.access,\n\t\t// so implement the relevant behavior ourselves\n\n\t\t// Gets all values\n\t\tif ( key === undefined ) {\n\t\t\tif ( this.length ) {\n\t\t\t\tdata = jQuery.data( elem );\n\n\t\t\t\tif ( elem.nodeType === 1 && !jQuery._data( elem, \"parsedAttrs\" ) ) {\n\t\t\t\t\ti = attrs.length;\n\t\t\t\t\twhile ( i-- ) {\n\n\t\t\t\t\t\t// Support: IE11+\n\t\t\t\t\t\t// The attrs elements can be null (#14894)\n\t\t\t\t\t\tif ( attrs[ i ] ) {\n\t\t\t\t\t\t\tname = attrs[ i ].name;\n\t\t\t\t\t\t\tif ( name.indexOf( \"data-\" ) === 0 ) {\n\t\t\t\t\t\t\t\tname = jQuery.camelCase( name.slice(5) );\n\t\t\t\t\t\t\t\tdataAttr( elem, name, data[ name ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tjQuery._data( elem, \"parsedAttrs\", true );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\t// Sets multiple values\n\t\tif ( typeof key === \"object\" ) {\n\t\t\treturn this.each(function() {\n\t\t\t\tjQuery.data( this, key );\n\t\t\t});\n\t\t}\n\n\t\treturn arguments.length > 1 ?\n\n\t\t\t// Sets one value\n\t\t\tthis.each(function() {\n\t\t\t\tjQuery.data( this, key, value );\n\t\t\t}) :\n\n\t\t\t// Gets one value\n\t\t\t// Try to fetch any internally stored data first\n\t\t\telem ? dataAttr( elem, key, jQuery.data( elem, key ) ) : undefined;\n\t},\n\n\tremoveData: function( key ) {\n\t\treturn this.each(function() {\n\t\t\tjQuery.removeData( this, key );\n\t\t});\n\t}\n});\n\n\njQuery.extend({\n\tqueue: function( elem, type, data ) {\n\t\tvar queue;\n\n\t\tif ( elem ) {\n\t\t\ttype = ( type || \"fx\" ) + \"queue\";\n\t\t\tqueue = jQuery._data( elem, type );\n\n\t\t\t// Speed up dequeue by getting out quickly if this is just a lookup\n\t\t\tif ( data ) {\n\t\t\t\tif ( !queue || jQuery.isArray(data) ) {\n\t\t\t\t\tqueue = jQuery._data( elem, type, jQuery.makeArray(data) );\n\t\t\t\t} else {\n\t\t\t\t\tqueue.push( data );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn queue || [];\n\t\t}\n\t},\n\n\tdequeue: function( elem, type ) {\n\t\ttype = type || \"fx\";\n\n\t\tvar queue = jQuery.queue( elem, type ),\n\t\t\tstartLength = queue.length,\n\t\t\tfn = queue.shift(),\n\t\t\thooks = jQuery._queueHooks( elem, type ),\n\t\t\tnext = function() {\n\t\t\t\tjQuery.dequeue( elem, type );\n\t\t\t};\n\n\t\t// If the fx queue is dequeued, always remove the progress sentinel\n\t\tif ( fn === \"inprogress\" ) {\n\t\t\tfn = queue.shift();\n\t\t\tstartLength--;\n\t\t}\n\n\t\tif ( fn ) {\n\n\t\t\t// Add a progress sentinel to prevent the fx queue from being\n\t\t\t// automatically dequeued\n\t\t\tif ( type === \"fx\" ) {\n\t\t\t\tqueue.unshift( \"inprogress\" );\n\t\t\t}\n\n\t\t\t// clear up the last queue stop function\n\t\t\tdelete hooks.stop;\n\t\t\tfn.call( elem, next, hooks );\n\t\t}\n\n\t\tif ( !startLength && hooks ) {\n\t\t\thooks.empty.fire();\n\t\t}\n\t},\n\n\t// not intended for public consumption - generates a queueHooks object, or returns the current one\n\t_queueHooks: function( elem, type ) {\n\t\tvar key = type + \"queueHooks\";\n\t\treturn jQuery._data( elem, key ) || jQuery._data( elem, key, {\n\t\t\tempty: jQuery.Callbacks(\"once memory\").add(function() {\n\t\t\t\tjQuery._removeData( elem, type + \"queue\" );\n\t\t\t\tjQuery._removeData( elem, key );\n\t\t\t})\n\t\t});\n\t}\n});\n\njQuery.fn.extend({\n\tqueue: function( type, data ) {\n\t\tvar setter = 2;\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tdata = type;\n\t\t\ttype = \"fx\";\n\t\t\tsetter--;\n\t\t}\n\n\t\tif ( arguments.length < setter ) {\n\t\t\treturn jQuery.queue( this[0], type );\n\t\t}\n\n\t\treturn data === undefined ?\n\t\t\tthis :\n\t\t\tthis.each(function() {\n\t\t\t\tvar queue = jQuery.queue( this, type, data );\n\n\t\t\t\t// ensure a hooks for this queue\n\t\t\t\tjQuery._queueHooks( this, type );\n\n\t\t\t\tif ( type === \"fx\" && queue[0] !== \"inprogress\" ) {\n\t\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t\t}\n\t\t\t});\n\t},\n\tdequeue: function( type ) {\n\t\treturn this.each(function() {\n\t\t\tjQuery.dequeue( this, type );\n\t\t});\n\t},\n\tclearQueue: function( type ) {\n\t\treturn this.queue( type || \"fx\", [] );\n\t},\n\t// Get a promise resolved when queues of a certain type\n\t// are emptied (fx is the type by default)\n\tpromise: function( type, obj ) {\n\t\tvar tmp,\n\t\t\tcount = 1,\n\t\t\tdefer = jQuery.Deferred(),\n\t\t\telements = this,\n\t\t\ti = this.length,\n\t\t\tresolve = function() {\n\t\t\t\tif ( !( --count ) ) {\n\t\t\t\t\tdefer.resolveWith( elements, [ elements ] );\n\t\t\t\t}\n\t\t\t};\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tobj = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\ttype = type || \"fx\";\n\n\t\twhile ( i-- ) {\n\t\t\ttmp = jQuery._data( elements[ i ], type + \"queueHooks\" );\n\t\t\tif ( tmp && tmp.empty ) {\n\t\t\t\tcount++;\n\t\t\t\ttmp.empty.add( resolve );\n\t\t\t}\n\t\t}\n\t\tresolve();\n\t\treturn defer.promise( obj );\n\t}\n});\nvar pnum = (/[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/).source;\n\nvar cssExpand = [ \"Top\", \"Right\", \"Bottom\", \"Left\" ];\n\nvar isHidden = function( elem, el ) {\n\t\t// isHidden might be called from jQuery#filter function;\n\t\t// in that case, element will be second argument\n\t\telem = el || elem;\n\t\treturn jQuery.css( elem, \"display\" ) === \"none\" || !jQuery.contains( elem.ownerDocument, elem );\n\t};\n\n\n\n// Multifunctional method to get and set values of a collection\n// The value/s can optionally be executed if it's a function\nvar access = jQuery.access = function( elems, fn, key, value, chainable, emptyGet, raw ) {\n\tvar i = 0,\n\t\tlength = elems.length,\n\t\tbulk = key == null;\n\n\t// Sets many values\n\tif ( jQuery.type( key ) === \"object\" ) {\n\t\tchainable = true;\n\t\tfor ( i in key ) {\n\t\t\tjQuery.access( elems, fn, i, key[i], true, emptyGet, raw );\n\t\t}\n\n\t// Sets one value\n\t} else if ( value !== undefined ) {\n\t\tchainable = true;\n\n\t\tif ( !jQuery.isFunction( value ) ) {\n\t\t\traw = true;\n\t\t}\n\n\t\tif ( bulk ) {\n\t\t\t// Bulk operations run against the entire set\n\t\t\tif ( raw ) {\n\t\t\t\tfn.call( elems, value );\n\t\t\t\tfn = null;\n\n\t\t\t// ...except when executing function values\n\t\t\t} else {\n\t\t\t\tbulk = fn;\n\t\t\t\tfn = function( elem, key, value ) {\n\t\t\t\t\treturn bulk.call( jQuery( elem ), value );\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tif ( fn ) {\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tfn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn chainable ?\n\t\telems :\n\n\t\t// Gets\n\t\tbulk ?\n\t\t\tfn.call( elems ) :\n\t\t\tlength ? fn( elems[0], key ) : emptyGet;\n};\nvar rcheckableType = (/^(?:checkbox|radio)$/i);\n\n\n\n(function() {\n\t// Minified: var a,b,c\n\tvar input = document.createElement( \"input\" ),\n\t\tdiv = document.createElement( \"div\" ),\n\t\tfragment = document.createDocumentFragment();\n\n\t// Setup\n\tdiv.innerHTML = \"  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>\";\n\n\t// IE strips leading whitespace when .innerHTML is used\n\tsupport.leadingWhitespace = div.firstChild.nodeType === 3;\n\n\t// Make sure that tbody elements aren't automatically inserted\n\t// IE will insert them into empty tables\n\tsupport.tbody = !div.getElementsByTagName( \"tbody\" ).length;\n\n\t// Make sure that link elements get serialized correctly by innerHTML\n\t// This requires a wrapper element in IE\n\tsupport.htmlSerialize = !!div.getElementsByTagName( \"link\" ).length;\n\n\t// Makes sure cloning an html5 element does not cause problems\n\t// Where outerHTML is undefined, this still works\n\tsupport.html5Clone =\n\t\tdocument.createElement( \"nav\" ).cloneNode( true ).outerHTML !== \"<:nav></:nav>\";\n\n\t// Check if a disconnected checkbox will retain its checked\n\t// value of true after appended to the DOM (IE6/7)\n\tinput.type = \"checkbox\";\n\tinput.checked = true;\n\tfragment.appendChild( input );\n\tsupport.appendChecked = input.checked;\n\n\t// Make sure textarea (and checkbox) defaultValue is properly cloned\n\t// Support: IE6-IE11+\n\tdiv.innerHTML = \"<textarea>x</textarea>\";\n\tsupport.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;\n\n\t// #11217 - WebKit loses check when the name is after the checked attribute\n\tfragment.appendChild( div );\n\tdiv.innerHTML = \"<input type='radio' checked='checked' name='t'/>\";\n\n\t// Support: Safari 5.1, iOS 5.1, Android 4.x, Android 2.3\n\t// old WebKit doesn't clone checked state correctly in fragments\n\tsupport.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;\n\n\t// Support: IE<9\n\t// Opera does not clone events (and typeof div.attachEvent === undefined).\n\t// IE9-10 clones events bound via attachEvent, but they don't trigger with .click()\n\tsupport.noCloneEvent = true;\n\tif ( div.attachEvent ) {\n\t\tdiv.attachEvent( \"onclick\", function() {\n\t\t\tsupport.noCloneEvent = false;\n\t\t});\n\n\t\tdiv.cloneNode( true ).click();\n\t}\n\n\t// Execute the test only if not already executed in another module.\n\tif (support.deleteExpando == null) {\n\t\t// Support: IE<9\n\t\tsupport.deleteExpando = true;\n\t\ttry {\n\t\t\tdelete div.test;\n\t\t} catch( e ) {\n\t\t\tsupport.deleteExpando = false;\n\t\t}\n\t}\n})();\n\n\n(function() {\n\tvar i, eventName,\n\t\tdiv = document.createElement( \"div\" );\n\n\t// Support: IE<9 (lack submit/change bubble), Firefox 23+ (lack focusin event)\n\tfor ( i in { submit: true, change: true, focusin: true }) {\n\t\teventName = \"on\" + i;\n\n\t\tif ( !(support[ i + \"Bubbles\" ] = eventName in window) ) {\n\t\t\t// Beware of CSP restrictions (https://developer.mozilla.org/en/Security/CSP)\n\t\t\tdiv.setAttribute( eventName, \"t\" );\n\t\t\tsupport[ i + \"Bubbles\" ] = div.attributes[ eventName ].expando === false;\n\t\t}\n\t}\n\n\t// Null elements to avoid leaks in IE.\n\tdiv = null;\n})();\n\n\nvar rformElems = /^(?:input|select|textarea)$/i,\n\trkeyEvent = /^key/,\n\trmouseEvent = /^(?:mouse|pointer|contextmenu)|click/,\n\trfocusMorph = /^(?:focusinfocus|focusoutblur)$/,\n\trtypenamespace = /^([^.]*)(?:\\.(.+)|)$/;\n\nfunction returnTrue() {\n\treturn true;\n}\n\nfunction returnFalse() {\n\treturn false;\n}\n\nfunction safeActiveElement() {\n\ttry {\n\t\treturn document.activeElement;\n\t} catch ( err ) { }\n}\n\n/*\n * Helper functions for managing events -- not part of the public interface.\n * Props to Dean Edwards' addEvent library for many of the ideas.\n */\njQuery.event = {\n\n\tglobal: {},\n\n\tadd: function( elem, types, handler, data, selector ) {\n\t\tvar tmp, events, t, handleObjIn,\n\t\t\tspecial, eventHandle, handleObj,\n\t\t\thandlers, type, namespaces, origType,\n\t\t\telemData = jQuery._data( elem );\n\n\t\t// Don't attach events to noData or text/comment nodes (but allow plain objects)\n\t\tif ( !elemData ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Caller can pass in an object of custom data in lieu of the handler\n\t\tif ( handler.handler ) {\n\t\t\thandleObjIn = handler;\n\t\t\thandler = handleObjIn.handler;\n\t\t\tselector = handleObjIn.selector;\n\t\t}\n\n\t\t// Make sure that the handler has a unique ID, used to find/remove it later\n\t\tif ( !handler.guid ) {\n\t\t\thandler.guid = jQuery.guid++;\n\t\t}\n\n\t\t// Init the element's event structure and main handler, if this is the first\n\t\tif ( !(events = elemData.events) ) {\n\t\t\tevents = elemData.events = {};\n\t\t}\n\t\tif ( !(eventHandle = elemData.handle) ) {\n\t\t\teventHandle = elemData.handle = function( e ) {\n\t\t\t\t// Discard the second event of a jQuery.event.trigger() and\n\t\t\t\t// when an event is called after a page has unloaded\n\t\t\t\treturn typeof jQuery !== strundefined && (!e || jQuery.event.triggered !== e.type) ?\n\t\t\t\t\tjQuery.event.dispatch.apply( eventHandle.elem, arguments ) :\n\t\t\t\t\tundefined;\n\t\t\t};\n\t\t\t// Add elem as a property of the handle fn to prevent a memory leak with IE non-native events\n\t\t\teventHandle.elem = elem;\n\t\t}\n\n\t\t// Handle multiple events separated by a space\n\t\ttypes = ( types || \"\" ).match( rnotwhite ) || [ \"\" ];\n\t\tt = types.length;\n\t\twhile ( t-- ) {\n\t\t\ttmp = rtypenamespace.exec( types[t] ) || [];\n\t\t\ttype = origType = tmp[1];\n\t\t\tnamespaces = ( tmp[2] || \"\" ).split( \".\" ).sort();\n\n\t\t\t// There *must* be a type, no attaching namespace-only handlers\n\t\t\tif ( !type ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// If event changes its type, use the special event handlers for the changed type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// If selector defined, determine special event api type, otherwise given type\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\n\t\t\t// Update special based on newly reset type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// handleObj is passed to all event handlers\n\t\t\thandleObj = jQuery.extend({\n\t\t\t\ttype: type,\n\t\t\t\torigType: origType,\n\t\t\t\tdata: data,\n\t\t\t\thandler: handler,\n\t\t\t\tguid: handler.guid,\n\t\t\t\tselector: selector,\n\t\t\t\tneedsContext: selector && jQuery.expr.match.needsContext.test( selector ),\n\t\t\t\tnamespace: namespaces.join(\".\")\n\t\t\t}, handleObjIn );\n\n\t\t\t// Init the event handler queue if we're the first\n\t\t\tif ( !(handlers = events[ type ]) ) {\n\t\t\t\thandlers = events[ type ] = [];\n\t\t\t\thandlers.delegateCount = 0;\n\n\t\t\t\t// Only use addEventListener/attachEvent if the special events handler returns false\n\t\t\t\tif ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {\n\t\t\t\t\t// Bind the global event handler to the element\n\t\t\t\t\tif ( elem.addEventListener ) {\n\t\t\t\t\t\telem.addEventListener( type, eventHandle, false );\n\n\t\t\t\t\t} else if ( elem.attachEvent ) {\n\t\t\t\t\t\telem.attachEvent( \"on\" + type, eventHandle );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( special.add ) {\n\t\t\t\tspecial.add.call( elem, handleObj );\n\n\t\t\t\tif ( !handleObj.handler.guid ) {\n\t\t\t\t\thandleObj.handler.guid = handler.guid;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add to the element's handler list, delegates in front\n\t\t\tif ( selector ) {\n\t\t\t\thandlers.splice( handlers.delegateCount++, 0, handleObj );\n\t\t\t} else {\n\t\t\t\thandlers.push( handleObj );\n\t\t\t}\n\n\t\t\t// Keep track of which events have ever been used, for event optimization\n\t\t\tjQuery.event.global[ type ] = true;\n\t\t}\n\n\t\t// Nullify elem to prevent memory leaks in IE\n\t\telem = null;\n\t},\n\n\t// Detach an event or set of events from an element\n\tremove: function( elem, types, handler, selector, mappedTypes ) {\n\t\tvar j, handleObj, tmp,\n\t\t\torigCount, t, events,\n\t\t\tspecial, handlers, type,\n\t\t\tnamespaces, origType,\n\t\t\telemData = jQuery.hasData( elem ) && jQuery._data( elem );\n\n\t\tif ( !elemData || !(events = elemData.events) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Once for each type.namespace in types; type may be omitted\n\t\ttypes = ( types || \"\" ).match( rnotwhite ) || [ \"\" ];\n\t\tt = types.length;\n\t\twhile ( t-- ) {\n\t\t\ttmp = rtypenamespace.exec( types[t] ) || [];\n\t\t\ttype = origType = tmp[1];\n\t\t\tnamespaces = ( tmp[2] || \"\" ).split( \".\" ).sort();\n\n\t\t\t// Unbind all events (on this namespace, if provided) for the element\n\t\t\tif ( !type ) {\n\t\t\t\tfor ( type in events ) {\n\t\t\t\t\tjQuery.event.remove( elem, type + types[ t ], handler, selector, true );\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\t\t\thandlers = events[ type ] || [];\n\t\t\ttmp = tmp[2] && new RegExp( \"(^|\\\\.)\" + namespaces.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\" );\n\n\t\t\t// Remove matching events\n\t\t\torigCount = j = handlers.length;\n\t\t\twhile ( j-- ) {\n\t\t\t\thandleObj = handlers[ j ];\n\n\t\t\t\tif ( ( mappedTypes || origType === handleObj.origType ) &&\n\t\t\t\t\t( !handler || handler.guid === handleObj.guid ) &&\n\t\t\t\t\t( !tmp || tmp.test( handleObj.namespace ) ) &&\n\t\t\t\t\t( !selector || selector === handleObj.selector || selector === \"**\" && handleObj.selector ) ) {\n\t\t\t\t\thandlers.splice( j, 1 );\n\n\t\t\t\t\tif ( handleObj.selector ) {\n\t\t\t\t\t\thandlers.delegateCount--;\n\t\t\t\t\t}\n\t\t\t\t\tif ( special.remove ) {\n\t\t\t\t\t\tspecial.remove.call( elem, handleObj );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove generic event handler if we removed something and no more handlers exist\n\t\t\t// (avoids potential for endless recursion during removal of special event handlers)\n\t\t\tif ( origCount && !handlers.length ) {\n\t\t\t\tif ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {\n\t\t\t\t\tjQuery.removeEvent( elem, type, elemData.handle );\n\t\t\t\t}\n\n\t\t\t\tdelete events[ type ];\n\t\t\t}\n\t\t}\n\n\t\t// Remove the expando if it's no longer used\n\t\tif ( jQuery.isEmptyObject( events ) ) {\n\t\t\tdelete elemData.handle;\n\n\t\t\t// removeData also checks for emptiness and clears the expando if empty\n\t\t\t// so use it instead of delete\n\t\t\tjQuery._removeData( elem, \"events\" );\n\t\t}\n\t},\n\n\ttrigger: function( event, data, elem, onlyHandlers ) {\n\t\tvar handle, ontype, cur,\n\t\t\tbubbleType, special, tmp, i,\n\t\t\teventPath = [ elem || document ],\n\t\t\ttype = hasOwn.call( event, \"type\" ) ? event.type : event,\n\t\t\tnamespaces = hasOwn.call( event, \"namespace\" ) ? event.namespace.split(\".\") : [];\n\n\t\tcur = tmp = elem = elem || document;\n\n\t\t// Don't do events on text and comment nodes\n\t\tif ( elem.nodeType === 3 || elem.nodeType === 8 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// focus/blur morphs to focusin/out; ensure we're not firing them right now\n\t\tif ( rfocusMorph.test( type + jQuery.event.triggered ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( type.indexOf(\".\") >= 0 ) {\n\t\t\t// Namespaced trigger; create a regexp to match event type in handle()\n\t\t\tnamespaces = type.split(\".\");\n\t\t\ttype = namespaces.shift();\n\t\t\tnamespaces.sort();\n\t\t}\n\t\tontype = type.indexOf(\":\") < 0 && \"on\" + type;\n\n\t\t// Caller can pass in a jQuery.Event object, Object, or just an event type string\n\t\tevent = event[ jQuery.expando ] ?\n\t\t\tevent :\n\t\t\tnew jQuery.Event( type, typeof event === \"object\" && event );\n\n\t\t// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\n\t\tevent.isTrigger = onlyHandlers ? 2 : 3;\n\t\tevent.namespace = namespaces.join(\".\");\n\t\tevent.namespace_re = event.namespace ?\n\t\t\tnew RegExp( \"(^|\\\\.)\" + namespaces.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\" ) :\n\t\t\tnull;\n\n\t\t// Clean up the event in case it is being reused\n\t\tevent.result = undefined;\n\t\tif ( !event.target ) {\n\t\t\tevent.target = elem;\n\t\t}\n\n\t\t// Clone any incoming data and prepend the event, creating the handler arg list\n\t\tdata = data == null ?\n\t\t\t[ event ] :\n\t\t\tjQuery.makeArray( data, [ event ] );\n\n\t\t// Allow special events to draw outside the lines\n\t\tspecial = jQuery.event.special[ type ] || {};\n\t\tif ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine event propagation path in advance, per W3C events spec (#9951)\n\t\t// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\n\t\tif ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {\n\n\t\t\tbubbleType = special.delegateType || type;\n\t\t\tif ( !rfocusMorph.test( bubbleType + type ) ) {\n\t\t\t\tcur = cur.parentNode;\n\t\t\t}\n\t\t\tfor ( ; cur; cur = cur.parentNode ) {\n\t\t\t\teventPath.push( cur );\n\t\t\t\ttmp = cur;\n\t\t\t}\n\n\t\t\t// Only add window if we got to document (e.g., not plain obj or detached DOM)\n\t\t\tif ( tmp === (elem.ownerDocument || document) ) {\n\t\t\t\teventPath.push( tmp.defaultView || tmp.parentWindow || window );\n\t\t\t}\n\t\t}\n\n\t\t// Fire handlers on the event path\n\t\ti = 0;\n\t\twhile ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {\n\n\t\t\tevent.type = i > 1 ?\n\t\t\t\tbubbleType :\n\t\t\t\tspecial.bindType || type;\n\n\t\t\t// jQuery handler\n\t\t\thandle = ( jQuery._data( cur, \"events\" ) || {} )[ event.type ] && jQuery._data( cur, \"handle\" );\n\t\t\tif ( handle ) {\n\t\t\t\thandle.apply( cur, data );\n\t\t\t}\n\n\t\t\t// Native handler\n\t\t\thandle = ontype && cur[ ontype ];\n\t\t\tif ( handle && handle.apply && jQuery.acceptData( cur ) ) {\n\t\t\t\tevent.result = handle.apply( cur, data );\n\t\t\t\tif ( event.result === false ) {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tevent.type = type;\n\n\t\t// If nobody prevented the default action, do it now\n\t\tif ( !onlyHandlers && !event.isDefaultPrevented() ) {\n\n\t\t\tif ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &&\n\t\t\t\tjQuery.acceptData( elem ) ) {\n\n\t\t\t\t// Call a native DOM method on the target with the same name name as the event.\n\t\t\t\t// Can't use an .isFunction() check here because IE6/7 fails that test.\n\t\t\t\t// Don't do default actions on window, that's where global variables be (#6170)\n\t\t\t\tif ( ontype && elem[ type ] && !jQuery.isWindow( elem ) ) {\n\n\t\t\t\t\t// Don't re-trigger an onFOO event when we call its FOO() method\n\t\t\t\t\ttmp = elem[ ontype ];\n\n\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\telem[ ontype ] = null;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Prevent re-triggering of the same event, since we already bubbled it above\n\t\t\t\t\tjQuery.event.triggered = type;\n\t\t\t\t\ttry {\n\t\t\t\t\t\telem[ type ]();\n\t\t\t\t\t} catch ( e ) {\n\t\t\t\t\t\t// IE<9 dies on focus/blur to hidden element (#1486,#12518)\n\t\t\t\t\t\t// only reproducible on winXP IE8 native, not IE9 in IE8 mode\n\t\t\t\t\t}\n\t\t\t\t\tjQuery.event.triggered = undefined;\n\n\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\telem[ ontype ] = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\tdispatch: function( event ) {\n\n\t\t// Make a writable jQuery.Event from the native event object\n\t\tevent = jQuery.event.fix( event );\n\n\t\tvar i, ret, handleObj, matched, j,\n\t\t\thandlerQueue = [],\n\t\t\targs = slice.call( arguments ),\n\t\t\thandlers = ( jQuery._data( this, \"events\" ) || {} )[ event.type ] || [],\n\t\t\tspecial = jQuery.event.special[ event.type ] || {};\n\n\t\t// Use the fix-ed jQuery.Event rather than the (read-only) native event\n\t\targs[0] = event;\n\t\tevent.delegateTarget = this;\n\n\t\t// Call the preDispatch hook for the mapped type, and let it bail if desired\n\t\tif ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine handlers\n\t\thandlerQueue = jQuery.event.handlers.call( this, event, handlers );\n\n\t\t// Run delegates first; they may want to stop propagation beneath us\n\t\ti = 0;\n\t\twhile ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {\n\t\t\tevent.currentTarget = matched.elem;\n\n\t\t\tj = 0;\n\t\t\twhile ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {\n\n\t\t\t\t// Triggered event must either 1) have no namespace, or\n\t\t\t\t// 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).\n\t\t\t\tif ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {\n\n\t\t\t\t\tevent.handleObj = handleObj;\n\t\t\t\t\tevent.data = handleObj.data;\n\n\t\t\t\t\tret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )\n\t\t\t\t\t\t\t.apply( matched.elem, args );\n\n\t\t\t\t\tif ( ret !== undefined ) {\n\t\t\t\t\t\tif ( (event.result = ret) === false ) {\n\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Call the postDispatch hook for the mapped type\n\t\tif ( special.postDispatch ) {\n\t\t\tspecial.postDispatch.call( this, event );\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\thandlers: function( event, handlers ) {\n\t\tvar sel, handleObj, matches, i,\n\t\t\thandlerQueue = [],\n\t\t\tdelegateCount = handlers.delegateCount,\n\t\t\tcur = event.target;\n\n\t\t// Find delegate handlers\n\t\t// Black-hole SVG <use> instance trees (#13180)\n\t\t// Avoid non-left-click bubbling in Firefox (#3861)\n\t\tif ( delegateCount && cur.nodeType && (!event.button || event.type !== \"click\") ) {\n\n\t\t\t/* jshint eqeqeq: false */\n\t\t\tfor ( ; cur != this; cur = cur.parentNode || this ) {\n\t\t\t\t/* jshint eqeqeq: true */\n\n\t\t\t\t// Don't check non-elements (#13208)\n\t\t\t\t// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)\n\t\t\t\tif ( cur.nodeType === 1 && (cur.disabled !== true || event.type !== \"click\") ) {\n\t\t\t\t\tmatches = [];\n\t\t\t\t\tfor ( i = 0; i < delegateCount; i++ ) {\n\t\t\t\t\t\thandleObj = handlers[ i ];\n\n\t\t\t\t\t\t// Don't conflict with Object.prototype properties (#13203)\n\t\t\t\t\t\tsel = handleObj.selector + \" \";\n\n\t\t\t\t\t\tif ( matches[ sel ] === undefined ) {\n\t\t\t\t\t\t\tmatches[ sel ] = handleObj.needsContext ?\n\t\t\t\t\t\t\t\tjQuery( sel, this ).index( cur ) >= 0 :\n\t\t\t\t\t\t\t\tjQuery.find( sel, this, null, [ cur ] ).length;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( matches[ sel ] ) {\n\t\t\t\t\t\t\tmatches.push( handleObj );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( matches.length ) {\n\t\t\t\t\t\thandlerQueue.push({ elem: cur, handlers: matches });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Add the remaining (directly-bound) handlers\n\t\tif ( delegateCount < handlers.length ) {\n\t\t\thandlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });\n\t\t}\n\n\t\treturn handlerQueue;\n\t},\n\n\tfix: function( event ) {\n\t\tif ( event[ jQuery.expando ] ) {\n\t\t\treturn event;\n\t\t}\n\n\t\t// Create a writable copy of the event object and normalize some properties\n\t\tvar i, prop, copy,\n\t\t\ttype = event.type,\n\t\t\toriginalEvent = event,\n\t\t\tfixHook = this.fixHooks[ type ];\n\n\t\tif ( !fixHook ) {\n\t\t\tthis.fixHooks[ type ] = fixHook =\n\t\t\t\trmouseEvent.test( type ) ? this.mouseHooks :\n\t\t\t\trkeyEvent.test( type ) ? this.keyHooks :\n\t\t\t\t{};\n\t\t}\n\t\tcopy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;\n\n\t\tevent = new jQuery.Event( originalEvent );\n\n\t\ti = copy.length;\n\t\twhile ( i-- ) {\n\t\t\tprop = copy[ i ];\n\t\t\tevent[ prop ] = originalEvent[ prop ];\n\t\t}\n\n\t\t// Support: IE<9\n\t\t// Fix target property (#1925)\n\t\tif ( !event.target ) {\n\t\t\tevent.target = originalEvent.srcElement || document;\n\t\t}\n\n\t\t// Support: Chrome 23+, Safari?\n\t\t// Target should not be a text node (#504, #13143)\n\t\tif ( event.target.nodeType === 3 ) {\n\t\t\tevent.target = event.target.parentNode;\n\t\t}\n\n\t\t// Support: IE<9\n\t\t// For mouse/key events, metaKey==false if it's undefined (#3368, #11328)\n\t\tevent.metaKey = !!event.metaKey;\n\n\t\treturn fixHook.filter ? fixHook.filter( event, originalEvent ) : event;\n\t},\n\n\t// Includes some event props shared by KeyEvent and MouseEvent\n\tprops: \"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which\".split(\" \"),\n\n\tfixHooks: {},\n\n\tkeyHooks: {\n\t\tprops: \"char charCode key keyCode\".split(\" \"),\n\t\tfilter: function( event, original ) {\n\n\t\t\t// Add which for key events\n\t\t\tif ( event.which == null ) {\n\t\t\t\tevent.which = original.charCode != null ? original.charCode : original.keyCode;\n\t\t\t}\n\n\t\t\treturn event;\n\t\t}\n\t},\n\n\tmouseHooks: {\n\t\tprops: \"button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement\".split(\" \"),\n\t\tfilter: function( event, original ) {\n\t\t\tvar body, eventDoc, doc,\n\t\t\t\tbutton = original.button,\n\t\t\t\tfromElement = original.fromElement;\n\n\t\t\t// Calculate pageX/Y if missing and clientX/Y available\n\t\t\tif ( event.pageX == null && original.clientX != null ) {\n\t\t\t\teventDoc = event.target.ownerDocument || document;\n\t\t\t\tdoc = eventDoc.documentElement;\n\t\t\t\tbody = eventDoc.body;\n\n\t\t\t\tevent.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );\n\t\t\t\tevent.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );\n\t\t\t}\n\n\t\t\t// Add relatedTarget, if necessary\n\t\t\tif ( !event.relatedTarget && fromElement ) {\n\t\t\t\tevent.relatedTarget = fromElement === event.target ? original.toElement : fromElement;\n\t\t\t}\n\n\t\t\t// Add which for click: 1 === left; 2 === middle; 3 === right\n\t\t\t// Note: button is not normalized, so don't use it\n\t\t\tif ( !event.which && button !== undefined ) {\n\t\t\t\tevent.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );\n\t\t\t}\n\n\t\t\treturn event;\n\t\t}\n\t},\n\n\tspecial: {\n\t\tload: {\n\t\t\t// Prevent triggered image.load events from bubbling to window.load\n\t\t\tnoBubble: true\n\t\t},\n\t\tfocus: {\n\t\t\t// Fire native event if possible so blur/focus sequence is correct\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this !== safeActiveElement() && this.focus ) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tthis.focus();\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t} catch ( e ) {\n\t\t\t\t\t\t// Support: IE<9\n\t\t\t\t\t\t// If we error on focus to hidden element (#1486, #12518),\n\t\t\t\t\t\t// let .trigger() run the handlers\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tdelegateType: \"focusin\"\n\t\t},\n\t\tblur: {\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this === safeActiveElement() && this.blur ) {\n\t\t\t\t\tthis.blur();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdelegateType: \"focusout\"\n\t\t},\n\t\tclick: {\n\t\t\t// For checkbox, fire native event so checked state will be right\n\t\t\ttrigger: function() {\n\t\t\t\tif ( jQuery.nodeName( this, \"input\" ) && this.type === \"checkbox\" && this.click ) {\n\t\t\t\t\tthis.click();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// For cross-browser consistency, don't fire native .click() on links\n\t\t\t_default: function( event ) {\n\t\t\t\treturn jQuery.nodeName( event.target, \"a\" );\n\t\t\t}\n\t\t},\n\n\t\tbeforeunload: {\n\t\t\tpostDispatch: function( event ) {\n\n\t\t\t\t// Support: Firefox 20+\n\t\t\t\t// Firefox doesn't alert if the returnValue field is not set.\n\t\t\t\tif ( event.result !== undefined && event.originalEvent ) {\n\t\t\t\t\tevent.originalEvent.returnValue = event.result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\tsimulate: function( type, elem, event, bubble ) {\n\t\t// Piggyback on a donor event to simulate a different one.\n\t\t// Fake originalEvent to avoid donor's stopPropagation, but if the\n\t\t// simulated event prevents default then we do the same on the donor.\n\t\tvar e = jQuery.extend(\n\t\t\tnew jQuery.Event(),\n\t\t\tevent,\n\t\t\t{\n\t\t\t\ttype: type,\n\t\t\t\tisSimulated: true,\n\t\t\t\toriginalEvent: {}\n\t\t\t}\n\t\t);\n\t\tif ( bubble ) {\n\t\t\tjQuery.event.trigger( e, null, elem );\n\t\t} else {\n\t\t\tjQuery.event.dispatch.call( elem, e );\n\t\t}\n\t\tif ( e.isDefaultPrevented() ) {\n\t\t\tevent.preventDefault();\n\t\t}\n\t}\n};\n\njQuery.removeEvent = document.removeEventListener ?\n\tfunction( elem, type, handle ) {\n\t\tif ( elem.removeEventListener ) {\n\t\t\telem.removeEventListener( type, handle, false );\n\t\t}\n\t} :\n\tfunction( elem, type, handle ) {\n\t\tvar name = \"on\" + type;\n\n\t\tif ( elem.detachEvent ) {\n\n\t\t\t// #8545, #7054, preventing memory leaks for custom events in IE6-8\n\t\t\t// detachEvent needed property on element, by name of that event, to properly expose it to GC\n\t\t\tif ( typeof elem[ name ] === strundefined ) {\n\t\t\t\telem[ name ] = null;\n\t\t\t}\n\n\t\t\telem.detachEvent( name, handle );\n\t\t}\n\t};\n\njQuery.Event = function( src, props ) {\n\t// Allow instantiation without the 'new' keyword\n\tif ( !(this instanceof jQuery.Event) ) {\n\t\treturn new jQuery.Event( src, props );\n\t}\n\n\t// Event object\n\tif ( src && src.type ) {\n\t\tthis.originalEvent = src;\n\t\tthis.type = src.type;\n\n\t\t// Events bubbling up the document may have been marked as prevented\n\t\t// by a handler lower down the tree; reflect the correct value.\n\t\tthis.isDefaultPrevented = src.defaultPrevented ||\n\t\t\t\tsrc.defaultPrevented === undefined &&\n\t\t\t\t// Support: IE < 9, Android < 4.0\n\t\t\t\tsrc.returnValue === false ?\n\t\t\treturnTrue :\n\t\t\treturnFalse;\n\n\t// Event type\n\t} else {\n\t\tthis.type = src;\n\t}\n\n\t// Put explicitly provided properties onto the event object\n\tif ( props ) {\n\t\tjQuery.extend( this, props );\n\t}\n\n\t// Create a timestamp if incoming event doesn't have one\n\tthis.timeStamp = src && src.timeStamp || jQuery.now();\n\n\t// Mark it as fixed\n\tthis[ jQuery.expando ] = true;\n};\n\n// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\njQuery.Event.prototype = {\n\tisDefaultPrevented: returnFalse,\n\tisPropagationStopped: returnFalse,\n\tisImmediatePropagationStopped: returnFalse,\n\n\tpreventDefault: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isDefaultPrevented = returnTrue;\n\t\tif ( !e ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If preventDefault exists, run it on the original event\n\t\tif ( e.preventDefault ) {\n\t\t\te.preventDefault();\n\n\t\t// Support: IE\n\t\t// Otherwise set the returnValue property of the original event to false\n\t\t} else {\n\t\t\te.returnValue = false;\n\t\t}\n\t},\n\tstopPropagation: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isPropagationStopped = returnTrue;\n\t\tif ( !e ) {\n\t\t\treturn;\n\t\t}\n\t\t// If stopPropagation exists, run it on the original event\n\t\tif ( e.stopPropagation ) {\n\t\t\te.stopPropagation();\n\t\t}\n\n\t\t// Support: IE\n\t\t// Set the cancelBubble property of the original event to true\n\t\te.cancelBubble = true;\n\t},\n\tstopImmediatePropagation: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isImmediatePropagationStopped = returnTrue;\n\n\t\tif ( e && e.stopImmediatePropagation ) {\n\t\t\te.stopImmediatePropagation();\n\t\t}\n\n\t\tthis.stopPropagation();\n\t}\n};\n\n// Create mouseenter/leave events using mouseover/out and event-time checks\njQuery.each({\n\tmouseenter: \"mouseover\",\n\tmouseleave: \"mouseout\",\n\tpointerenter: \"pointerover\",\n\tpointerleave: \"pointerout\"\n}, function( orig, fix ) {\n\tjQuery.event.special[ orig ] = {\n\t\tdelegateType: fix,\n\t\tbindType: fix,\n\n\t\thandle: function( event ) {\n\t\t\tvar ret,\n\t\t\t\ttarget = this,\n\t\t\t\trelated = event.relatedTarget,\n\t\t\t\thandleObj = event.handleObj;\n\n\t\t\t// For mousenter/leave call the handler if related is outside the target.\n\t\t\t// NB: No relatedTarget if the mouse left/entered the browser window\n\t\t\tif ( !related || (related !== target && !jQuery.contains( target, related )) ) {\n\t\t\t\tevent.type = handleObj.origType;\n\t\t\t\tret = handleObj.handler.apply( this, arguments );\n\t\t\t\tevent.type = fix;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t};\n});\n\n// IE submit delegation\nif ( !support.submitBubbles ) {\n\n\tjQuery.event.special.submit = {\n\t\tsetup: function() {\n\t\t\t// Only need this for delegated form submit events\n\t\t\tif ( jQuery.nodeName( this, \"form\" ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Lazy-add a submit handler when a descendant form may potentially be submitted\n\t\t\tjQuery.event.add( this, \"click._submit keypress._submit\", function( e ) {\n\t\t\t\t// Node name check avoids a VML-related crash in IE (#9807)\n\t\t\t\tvar elem = e.target,\n\t\t\t\t\tform = jQuery.nodeName( elem, \"input\" ) || jQuery.nodeName( elem, \"button\" ) ? elem.form : undefined;\n\t\t\t\tif ( form && !jQuery._data( form, \"submitBubbles\" ) ) {\n\t\t\t\t\tjQuery.event.add( form, \"submit._submit\", function( event ) {\n\t\t\t\t\t\tevent._submit_bubble = true;\n\t\t\t\t\t});\n\t\t\t\t\tjQuery._data( form, \"submitBubbles\", true );\n\t\t\t\t}\n\t\t\t});\n\t\t\t// return undefined since we don't need an event listener\n\t\t},\n\n\t\tpostDispatch: function( event ) {\n\t\t\t// If form was submitted by the user, bubble the event up the tree\n\t\t\tif ( event._submit_bubble ) {\n\t\t\t\tdelete event._submit_bubble;\n\t\t\t\tif ( this.parentNode && !event.isTrigger ) {\n\t\t\t\t\tjQuery.event.simulate( \"submit\", this.parentNode, event, true );\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tteardown: function() {\n\t\t\t// Only need this for delegated form submit events\n\t\t\tif ( jQuery.nodeName( this, \"form\" ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Remove delegated handlers; cleanData eventually reaps submit handlers attached above\n\t\t\tjQuery.event.remove( this, \"._submit\" );\n\t\t}\n\t};\n}\n\n// IE change delegation and checkbox/radio fix\nif ( !support.changeBubbles ) {\n\n\tjQuery.event.special.change = {\n\n\t\tsetup: function() {\n\n\t\t\tif ( rformElems.test( this.nodeName ) ) {\n\t\t\t\t// IE doesn't fire change on a check/radio until blur; trigger it on click\n\t\t\t\t// after a propertychange. Eat the blur-change in special.change.handle.\n\t\t\t\t// This still fires onchange a second time for check/radio after blur.\n\t\t\t\tif ( this.type === \"checkbox\" || this.type === \"radio\" ) {\n\t\t\t\t\tjQuery.event.add( this, \"propertychange._change\", function( event ) {\n\t\t\t\t\t\tif ( event.originalEvent.propertyName === \"checked\" ) {\n\t\t\t\t\t\t\tthis._just_changed = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tjQuery.event.add( this, \"click._change\", function( event ) {\n\t\t\t\t\t\tif ( this._just_changed && !event.isTrigger ) {\n\t\t\t\t\t\t\tthis._just_changed = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Allow triggered, simulated change events (#11500)\n\t\t\t\t\t\tjQuery.event.simulate( \"change\", this, event, true );\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t// Delegated event; lazy-add a change handler on descendant inputs\n\t\t\tjQuery.event.add( this, \"beforeactivate._change\", function( e ) {\n\t\t\t\tvar elem = e.target;\n\n\t\t\t\tif ( rformElems.test( elem.nodeName ) && !jQuery._data( elem, \"changeBubbles\" ) ) {\n\t\t\t\t\tjQuery.event.add( elem, \"change._change\", function( event ) {\n\t\t\t\t\t\tif ( this.parentNode && !event.isSimulated && !event.isTrigger ) {\n\t\t\t\t\t\t\tjQuery.event.simulate( \"change\", this.parentNode, event, true );\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tjQuery._data( elem, \"changeBubbles\", true );\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\thandle: function( event ) {\n\t\t\tvar elem = event.target;\n\n\t\t\t// Swallow native change events from checkbox/radio, we already triggered them above\n\t\t\tif ( this !== elem || event.isSimulated || event.isTrigger || (elem.type !== \"radio\" && elem.type !== \"checkbox\") ) {\n\t\t\t\treturn event.handleObj.handler.apply( this, arguments );\n\t\t\t}\n\t\t},\n\n\t\tteardown: function() {\n\t\t\tjQuery.event.remove( this, \"._change\" );\n\n\t\t\treturn !rformElems.test( this.nodeName );\n\t\t}\n\t};\n}\n\n// Create \"bubbling\" focus and blur events\nif ( !support.focusinBubbles ) {\n\tjQuery.each({ focus: \"focusin\", blur: \"focusout\" }, function( orig, fix ) {\n\n\t\t// Attach a single capturing handler on the document while someone wants focusin/focusout\n\t\tvar handler = function( event ) {\n\t\t\t\tjQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );\n\t\t\t};\n\n\t\tjQuery.event.special[ fix ] = {\n\t\t\tsetup: function() {\n\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\tattaches = jQuery._data( doc, fix );\n\n\t\t\t\tif ( !attaches ) {\n\t\t\t\t\tdoc.addEventListener( orig, handler, true );\n\t\t\t\t}\n\t\t\t\tjQuery._data( doc, fix, ( attaches || 0 ) + 1 );\n\t\t\t},\n\t\t\tteardown: function() {\n\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\tattaches = jQuery._data( doc, fix ) - 1;\n\n\t\t\t\tif ( !attaches ) {\n\t\t\t\t\tdoc.removeEventListener( orig, handler, true );\n\t\t\t\t\tjQuery._removeData( doc, fix );\n\t\t\t\t} else {\n\t\t\t\t\tjQuery._data( doc, fix, attaches );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t});\n}\n\njQuery.fn.extend({\n\n\ton: function( types, selector, data, fn, /*INTERNAL*/ one ) {\n\t\tvar type, origFn;\n\n\t\t// Types can be a map of types/handlers\n\t\tif ( typeof types === \"object\" ) {\n\t\t\t// ( types-Object, selector, data )\n\t\t\tif ( typeof selector !== \"string\" ) {\n\t\t\t\t// ( types-Object, data )\n\t\t\t\tdata = data || selector;\n\t\t\t\tselector = undefined;\n\t\t\t}\n\t\t\tfor ( type in types ) {\n\t\t\t\tthis.on( type, selector, data, types[ type ], one );\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tif ( data == null && fn == null ) {\n\t\t\t// ( types, fn )\n\t\t\tfn = selector;\n\t\t\tdata = selector = undefined;\n\t\t} else if ( fn == null ) {\n\t\t\tif ( typeof selector === \"string\" ) {\n\t\t\t\t// ( types, selector, fn )\n\t\t\t\tfn = data;\n\t\t\t\tdata = undefined;\n\t\t\t} else {\n\t\t\t\t// ( types, data, fn )\n\t\t\t\tfn = data;\n\t\t\t\tdata = selector;\n\t\t\t\tselector = undefined;\n\t\t\t}\n\t\t}\n\t\tif ( fn === false ) {\n\t\t\tfn = returnFalse;\n\t\t} else if ( !fn ) {\n\t\t\treturn this;\n\t\t}\n\n\t\tif ( one === 1 ) {\n\t\t\torigFn = fn;\n\t\t\tfn = function( event ) {\n\t\t\t\t// Can use an empty set, since event contains the info\n\t\t\t\tjQuery().off( event );\n\t\t\t\treturn origFn.apply( this, arguments );\n\t\t\t};\n\t\t\t// Use same guid so caller can remove using origFn\n\t\t\tfn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );\n\t\t}\n\t\treturn this.each( function() {\n\t\t\tjQuery.event.add( this, types, fn, data, selector );\n\t\t});\n\t},\n\tone: function( types, selector, data, fn ) {\n\t\treturn this.on( types, selector, data, fn, 1 );\n\t},\n\toff: function( types, selector, fn ) {\n\t\tvar handleObj, type;\n\t\tif ( types && types.preventDefault && types.handleObj ) {\n\t\t\t// ( event )  dispatched jQuery.Event\n\t\t\thandleObj = types.handleObj;\n\t\t\tjQuery( types.delegateTarget ).off(\n\t\t\t\thandleObj.namespace ? handleObj.origType + \".\" + handleObj.namespace : handleObj.origType,\n\t\t\t\thandleObj.selector,\n\t\t\t\thandleObj.handler\n\t\t\t);\n\t\t\treturn this;\n\t\t}\n\t\tif ( typeof types === \"object\" ) {\n\t\t\t// ( types-object [, selector] )\n\t\t\tfor ( type in types ) {\n\t\t\t\tthis.off( type, selector, types[ type ] );\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t\tif ( selector === false || typeof selector === \"function\" ) {\n\t\t\t// ( types [, fn] )\n\t\t\tfn = selector;\n\t\t\tselector = undefined;\n\t\t}\n\t\tif ( fn === false ) {\n\t\t\tfn = returnFalse;\n\t\t}\n\t\treturn this.each(function() {\n\t\t\tjQuery.event.remove( this, types, fn, selector );\n\t\t});\n\t},\n\n\ttrigger: function( type, data ) {\n\t\treturn this.each(function() {\n\t\t\tjQuery.event.trigger( type, data, this );\n\t\t});\n\t},\n\ttriggerHandler: function( type, data ) {\n\t\tvar elem = this[0];\n\t\tif ( elem ) {\n\t\t\treturn jQuery.event.trigger( type, data, elem, true );\n\t\t}\n\t}\n});\n\n\nfunction createSafeFragment( document ) {\n\tvar list = nodeNames.split( \"|\" ),\n\t\tsafeFrag = document.createDocumentFragment();\n\n\tif ( safeFrag.createElement ) {\n\t\twhile ( list.length ) {\n\t\t\tsafeFrag.createElement(\n\t\t\t\tlist.pop()\n\t\t\t);\n\t\t}\n\t}\n\treturn safeFrag;\n}\n\nvar nodeNames = \"abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|\" +\n\t\t\"header|hgroup|mark|meter|nav|output|progress|section|summary|time|video\",\n\trinlinejQuery = / jQuery\\d+=\"(?:null|\\d+)\"/g,\n\trnoshimcache = new RegExp(\"<(?:\" + nodeNames + \")[\\\\s/>]\", \"i\"),\n\trleadingWhitespace = /^\\s+/,\n\trxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^>]*)\\/>/gi,\n\trtagName = /<([\\w:]+)/,\n\trtbody = /<tbody/i,\n\trhtml = /<|&#?\\w+;/,\n\trnoInnerhtml = /<(?:script|style|link)/i,\n\t// checked=\"checked\" or checked\n\trchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n\trscriptType = /^$|\\/(?:java|ecma)script/i,\n\trscriptTypeMasked = /^true\\/(.*)/,\n\trcleanScript = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g,\n\n\t// We have to close these tags to support XHTML (#13200)\n\twrapMap = {\n\t\toption: [ 1, \"<select multiple='multiple'>\", \"</select>\" ],\n\t\tlegend: [ 1, \"<fieldset>\", \"</fieldset>\" ],\n\t\tarea: [ 1, \"<map>\", \"</map>\" ],\n\t\tparam: [ 1, \"<object>\", \"</object>\" ],\n\t\tthead: [ 1, \"<table>\", \"</table>\" ],\n\t\ttr: [ 2, \"<table><tbody>\", \"</tbody></table>\" ],\n\t\tcol: [ 2, \"<table><tbody></tbody><colgroup>\", \"</colgroup></table>\" ],\n\t\ttd: [ 3, \"<table><tbody><tr>\", \"</tr></tbody></table>\" ],\n\n\t\t// IE6-8 can't serialize link, script, style, or any html5 (NoScope) tags,\n\t\t// unless wrapped in a div with non-breaking characters in front of it.\n\t\t_default: support.htmlSerialize ? [ 0, \"\", \"\" ] : [ 1, \"X<div>\", \"</div>\"  ]\n\t},\n\tsafeFragment = createSafeFragment( document ),\n\tfragmentDiv = safeFragment.appendChild( document.createElement(\"div\") );\n\nwrapMap.optgroup = wrapMap.option;\nwrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\nwrapMap.th = wrapMap.td;\n\nfunction getAll( context, tag ) {\n\tvar elems, elem,\n\t\ti = 0,\n\t\tfound = typeof context.getElementsByTagName !== strundefined ? context.getElementsByTagName( tag || \"*\" ) :\n\t\t\ttypeof context.querySelectorAll !== strundefined ? context.querySelectorAll( tag || \"*\" ) :\n\t\t\tundefined;\n\n\tif ( !found ) {\n\t\tfor ( found = [], elems = context.childNodes || context; (elem = elems[i]) != null; i++ ) {\n\t\t\tif ( !tag || jQuery.nodeName( elem, tag ) ) {\n\t\t\t\tfound.push( elem );\n\t\t\t} else {\n\t\t\t\tjQuery.merge( found, getAll( elem, tag ) );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn tag === undefined || tag && jQuery.nodeName( context, tag ) ?\n\t\tjQuery.merge( [ context ], found ) :\n\t\tfound;\n}\n\n// Used in buildFragment, fixes the defaultChecked property\nfunction fixDefaultChecked( elem ) {\n\tif ( rcheckableType.test( elem.type ) ) {\n\t\telem.defaultChecked = elem.checked;\n\t}\n}\n\n// Support: IE<8\n// Manipulating tables requires a tbody\nfunction manipulationTarget( elem, content ) {\n\treturn jQuery.nodeName( elem, \"table\" ) &&\n\t\tjQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, \"tr\" ) ?\n\n\t\telem.getElementsByTagName(\"tbody\")[0] ||\n\t\t\telem.appendChild( elem.ownerDocument.createElement(\"tbody\") ) :\n\t\telem;\n}\n\n// Replace/restore the type attribute of script elements for safe DOM manipulation\nfunction disableScript( elem ) {\n\telem.type = (jQuery.find.attr( elem, \"type\" ) !== null) + \"/\" + elem.type;\n\treturn elem;\n}\nfunction restoreScript( elem ) {\n\tvar match = rscriptTypeMasked.exec( elem.type );\n\tif ( match ) {\n\t\telem.type = match[1];\n\t} else {\n\t\telem.removeAttribute(\"type\");\n\t}\n\treturn elem;\n}\n\n// Mark scripts as having already been evaluated\nfunction setGlobalEval( elems, refElements ) {\n\tvar elem,\n\t\ti = 0;\n\tfor ( ; (elem = elems[i]) != null; i++ ) {\n\t\tjQuery._data( elem, \"globalEval\", !refElements || jQuery._data( refElements[i], \"globalEval\" ) );\n\t}\n}\n\nfunction cloneCopyEvent( src, dest ) {\n\n\tif ( dest.nodeType !== 1 || !jQuery.hasData( src ) ) {\n\t\treturn;\n\t}\n\n\tvar type, i, l,\n\t\toldData = jQuery._data( src ),\n\t\tcurData = jQuery._data( dest, oldData ),\n\t\tevents = oldData.events;\n\n\tif ( events ) {\n\t\tdelete curData.handle;\n\t\tcurData.events = {};\n\n\t\tfor ( type in events ) {\n\t\t\tfor ( i = 0, l = events[ type ].length; i < l; i++ ) {\n\t\t\t\tjQuery.event.add( dest, type, events[ type ][ i ] );\n\t\t\t}\n\t\t}\n\t}\n\n\t// make the cloned public data object a copy from the original\n\tif ( curData.data ) {\n\t\tcurData.data = jQuery.extend( {}, curData.data );\n\t}\n}\n\nfunction fixCloneNodeIssues( src, dest ) {\n\tvar nodeName, e, data;\n\n\t// We do not need to do anything for non-Elements\n\tif ( dest.nodeType !== 1 ) {\n\t\treturn;\n\t}\n\n\tnodeName = dest.nodeName.toLowerCase();\n\n\t// IE6-8 copies events bound via attachEvent when using cloneNode.\n\tif ( !support.noCloneEvent && dest[ jQuery.expando ] ) {\n\t\tdata = jQuery._data( dest );\n\n\t\tfor ( e in data.events ) {\n\t\t\tjQuery.removeEvent( dest, e, data.handle );\n\t\t}\n\n\t\t// Event data gets referenced instead of copied if the expando gets copied too\n\t\tdest.removeAttribute( jQuery.expando );\n\t}\n\n\t// IE blanks contents when cloning scripts, and tries to evaluate newly-set text\n\tif ( nodeName === \"script\" && dest.text !== src.text ) {\n\t\tdisableScript( dest ).text = src.text;\n\t\trestoreScript( dest );\n\n\t// IE6-10 improperly clones children of object elements using classid.\n\t// IE10 throws NoModificationAllowedError if parent is null, #12132.\n\t} else if ( nodeName === \"object\" ) {\n\t\tif ( dest.parentNode ) {\n\t\t\tdest.outerHTML = src.outerHTML;\n\t\t}\n\n\t\t// This path appears unavoidable for IE9. When cloning an object\n\t\t// element in IE9, the outerHTML strategy above is not sufficient.\n\t\t// If the src has innerHTML and the destination does not,\n\t\t// copy the src.innerHTML into the dest.innerHTML. #10324\n\t\tif ( support.html5Clone && ( src.innerHTML && !jQuery.trim(dest.innerHTML) ) ) {\n\t\t\tdest.innerHTML = src.innerHTML;\n\t\t}\n\n\t} else if ( nodeName === \"input\" && rcheckableType.test( src.type ) ) {\n\t\t// IE6-8 fails to persist the checked state of a cloned checkbox\n\t\t// or radio button. Worse, IE6-7 fail to give the cloned element\n\t\t// a checked appearance if the defaultChecked value isn't also set\n\n\t\tdest.defaultChecked = dest.checked = src.checked;\n\n\t\t// IE6-7 get confused and end up setting the value of a cloned\n\t\t// checkbox/radio button to an empty string instead of \"on\"\n\t\tif ( dest.value !== src.value ) {\n\t\t\tdest.value = src.value;\n\t\t}\n\n\t// IE6-8 fails to return the selected option to the default selected\n\t// state when cloning options\n\t} else if ( nodeName === \"option\" ) {\n\t\tdest.defaultSelected = dest.selected = src.defaultSelected;\n\n\t// IE6-8 fails to set the defaultValue to the correct value when\n\t// cloning other types of input fields\n\t} else if ( nodeName === \"input\" || nodeName === \"textarea\" ) {\n\t\tdest.defaultValue = src.defaultValue;\n\t}\n}\n\njQuery.extend({\n\tclone: function( elem, dataAndEvents, deepDataAndEvents ) {\n\t\tvar destElements, node, clone, i, srcElements,\n\t\t\tinPage = jQuery.contains( elem.ownerDocument, elem );\n\n\t\tif ( support.html5Clone || jQuery.isXMLDoc(elem) || !rnoshimcache.test( \"<\" + elem.nodeName + \">\" ) ) {\n\t\t\tclone = elem.cloneNode( true );\n\n\t\t// IE<=8 does not properly clone detached, unknown element nodes\n\t\t} else {\n\t\t\tfragmentDiv.innerHTML = elem.outerHTML;\n\t\t\tfragmentDiv.removeChild( clone = fragmentDiv.firstChild );\n\t\t}\n\n\t\tif ( (!support.noCloneEvent || !support.noCloneChecked) &&\n\t\t\t\t(elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem) ) {\n\n\t\t\t// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2\n\t\t\tdestElements = getAll( clone );\n\t\t\tsrcElements = getAll( elem );\n\n\t\t\t// Fix all IE cloning issues\n\t\t\tfor ( i = 0; (node = srcElements[i]) != null; ++i ) {\n\t\t\t\t// Ensure that the destination node is not null; Fixes #9587\n\t\t\t\tif ( destElements[i] ) {\n\t\t\t\t\tfixCloneNodeIssues( node, destElements[i] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Copy the events from the original to the clone\n\t\tif ( dataAndEvents ) {\n\t\t\tif ( deepDataAndEvents ) {\n\t\t\t\tsrcElements = srcElements || getAll( elem );\n\t\t\t\tdestElements = destElements || getAll( clone );\n\n\t\t\t\tfor ( i = 0; (node = srcElements[i]) != null; i++ ) {\n\t\t\t\t\tcloneCopyEvent( node, destElements[i] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcloneCopyEvent( elem, clone );\n\t\t\t}\n\t\t}\n\n\t\t// Preserve script evaluation history\n\t\tdestElements = getAll( clone, \"script\" );\n\t\tif ( destElements.length > 0 ) {\n\t\t\tsetGlobalEval( destElements, !inPage && getAll( elem, \"script\" ) );\n\t\t}\n\n\t\tdestElements = srcElements = node = null;\n\n\t\t// Return the cloned set\n\t\treturn clone;\n\t},\n\n\tbuildFragment: function( elems, context, scripts, selection ) {\n\t\tvar j, elem, contains,\n\t\t\ttmp, tag, tbody, wrap,\n\t\t\tl = elems.length,\n\n\t\t\t// Ensure a safe fragment\n\t\t\tsafe = createSafeFragment( context ),\n\n\t\t\tnodes = [],\n\t\t\ti = 0;\n\n\t\tfor ( ; i < l; i++ ) {\n\t\t\telem = elems[ i ];\n\n\t\t\tif ( elem || elem === 0 ) {\n\n\t\t\t\t// Add nodes directly\n\t\t\t\tif ( jQuery.type( elem ) === \"object\" ) {\n\t\t\t\t\tjQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );\n\n\t\t\t\t// Convert non-html into a text node\n\t\t\t\t} else if ( !rhtml.test( elem ) ) {\n\t\t\t\t\tnodes.push( context.createTextNode( elem ) );\n\n\t\t\t\t// Convert html into DOM nodes\n\t\t\t\t} else {\n\t\t\t\t\ttmp = tmp || safe.appendChild( context.createElement(\"div\") );\n\n\t\t\t\t\t// Deserialize a standard representation\n\t\t\t\t\ttag = (rtagName.exec( elem ) || [ \"\", \"\" ])[ 1 ].toLowerCase();\n\t\t\t\t\twrap = wrapMap[ tag ] || wrapMap._default;\n\n\t\t\t\t\ttmp.innerHTML = wrap[1] + elem.replace( rxhtmlTag, \"<$1></$2>\" ) + wrap[2];\n\n\t\t\t\t\t// Descend through wrappers to the right content\n\t\t\t\t\tj = wrap[0];\n\t\t\t\t\twhile ( j-- ) {\n\t\t\t\t\t\ttmp = tmp.lastChild;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Manually add leading whitespace removed by IE\n\t\t\t\t\tif ( !support.leadingWhitespace && rleadingWhitespace.test( elem ) ) {\n\t\t\t\t\t\tnodes.push( context.createTextNode( rleadingWhitespace.exec( elem )[0] ) );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Remove IE's autoinserted <tbody> from table fragments\n\t\t\t\t\tif ( !support.tbody ) {\n\n\t\t\t\t\t\t// String was a <table>, *may* have spurious <tbody>\n\t\t\t\t\t\telem = tag === \"table\" && !rtbody.test( elem ) ?\n\t\t\t\t\t\t\ttmp.firstChild :\n\n\t\t\t\t\t\t\t// String was a bare <thead> or <tfoot>\n\t\t\t\t\t\t\twrap[1] === \"<table>\" && !rtbody.test( elem ) ?\n\t\t\t\t\t\t\t\ttmp :\n\t\t\t\t\t\t\t\t0;\n\n\t\t\t\t\t\tj = elem && elem.childNodes.length;\n\t\t\t\t\t\twhile ( j-- ) {\n\t\t\t\t\t\t\tif ( jQuery.nodeName( (tbody = elem.childNodes[j]), \"tbody\" ) && !tbody.childNodes.length ) {\n\t\t\t\t\t\t\t\telem.removeChild( tbody );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tjQuery.merge( nodes, tmp.childNodes );\n\n\t\t\t\t\t// Fix #12392 for WebKit and IE > 9\n\t\t\t\t\ttmp.textContent = \"\";\n\n\t\t\t\t\t// Fix #12392 for oldIE\n\t\t\t\t\twhile ( tmp.firstChild ) {\n\t\t\t\t\t\ttmp.removeChild( tmp.firstChild );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Remember the top-level container for proper cleanup\n\t\t\t\t\ttmp = safe.lastChild;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Fix #11356: Clear elements from fragment\n\t\tif ( tmp ) {\n\t\t\tsafe.removeChild( tmp );\n\t\t}\n\n\t\t// Reset defaultChecked for any radios and checkboxes\n\t\t// about to be appended to the DOM in IE 6/7 (#8060)\n\t\tif ( !support.appendChecked ) {\n\t\t\tjQuery.grep( getAll( nodes, \"input\" ), fixDefaultChecked );\n\t\t}\n\n\t\ti = 0;\n\t\twhile ( (elem = nodes[ i++ ]) ) {\n\n\t\t\t// #4087 - If origin and destination elements are the same, and this is\n\t\t\t// that element, do not do anything\n\t\t\tif ( selection && jQuery.inArray( elem, selection ) !== -1 ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcontains = jQuery.contains( elem.ownerDocument, elem );\n\n\t\t\t// Append to fragment\n\t\t\ttmp = getAll( safe.appendChild( elem ), \"script\" );\n\n\t\t\t// Preserve script evaluation history\n\t\t\tif ( contains ) {\n\t\t\t\tsetGlobalEval( tmp );\n\t\t\t}\n\n\t\t\t// Capture executables\n\t\t\tif ( scripts ) {\n\t\t\t\tj = 0;\n\t\t\t\twhile ( (elem = tmp[ j++ ]) ) {\n\t\t\t\t\tif ( rscriptType.test( elem.type || \"\" ) ) {\n\t\t\t\t\t\tscripts.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ttmp = null;\n\n\t\treturn safe;\n\t},\n\n\tcleanData: function( elems, /* internal */ acceptData ) {\n\t\tvar elem, type, id, data,\n\t\t\ti = 0,\n\t\t\tinternalKey = jQuery.expando,\n\t\t\tcache = jQuery.cache,\n\t\t\tdeleteExpando = support.deleteExpando,\n\t\t\tspecial = jQuery.event.special;\n\n\t\tfor ( ; (elem = elems[i]) != null; i++ ) {\n\t\t\tif ( acceptData || jQuery.acceptData( elem ) ) {\n\n\t\t\t\tid = elem[ internalKey ];\n\t\t\t\tdata = id && cache[ id ];\n\n\t\t\t\tif ( data ) {\n\t\t\t\t\tif ( data.events ) {\n\t\t\t\t\t\tfor ( type in data.events ) {\n\t\t\t\t\t\t\tif ( special[ type ] ) {\n\t\t\t\t\t\t\t\tjQuery.event.remove( elem, type );\n\n\t\t\t\t\t\t\t// This is a shortcut to avoid jQuery.event.remove's overhead\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tjQuery.removeEvent( elem, type, data.handle );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Remove cache only if it was not already removed by jQuery.event.remove\n\t\t\t\t\tif ( cache[ id ] ) {\n\n\t\t\t\t\t\tdelete cache[ id ];\n\n\t\t\t\t\t\t// IE does not allow us to delete expando properties from nodes,\n\t\t\t\t\t\t// nor does it have a removeAttribute function on Document nodes;\n\t\t\t\t\t\t// we must handle all of these cases\n\t\t\t\t\t\tif ( deleteExpando ) {\n\t\t\t\t\t\t\tdelete elem[ internalKey ];\n\n\t\t\t\t\t\t} else if ( typeof elem.removeAttribute !== strundefined ) {\n\t\t\t\t\t\t\telem.removeAttribute( internalKey );\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\telem[ internalKey ] = null;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdeletedIds.push( id );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n});\n\njQuery.fn.extend({\n\ttext: function( value ) {\n\t\treturn access( this, function( value ) {\n\t\t\treturn value === undefined ?\n\t\t\t\tjQuery.text( this ) :\n\t\t\t\tthis.empty().append( ( this[0] && this[0].ownerDocument || document ).createTextNode( value ) );\n\t\t}, null, value, arguments.length );\n\t},\n\n\tappend: function() {\n\t\treturn this.domManip( arguments, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\ttarget.appendChild( elem );\n\t\t\t}\n\t\t});\n\t},\n\n\tprepend: function() {\n\t\treturn this.domManip( arguments, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\ttarget.insertBefore( elem, target.firstChild );\n\t\t\t}\n\t\t});\n\t},\n\n\tbefore: function() {\n\t\treturn this.domManip( arguments, function( elem ) {\n\t\t\tif ( this.parentNode ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this );\n\t\t\t}\n\t\t});\n\t},\n\n\tafter: function() {\n\t\treturn this.domManip( arguments, function( elem ) {\n\t\t\tif ( this.parentNode ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this.nextSibling );\n\t\t\t}\n\t\t});\n\t},\n\n\tremove: function( selector, keepData /* Internal Use Only */ ) {\n\t\tvar elem,\n\t\t\telems = selector ? jQuery.filter( selector, this ) : this,\n\t\t\ti = 0;\n\n\t\tfor ( ; (elem = elems[i]) != null; i++ ) {\n\n\t\t\tif ( !keepData && elem.nodeType === 1 ) {\n\t\t\t\tjQuery.cleanData( getAll( elem ) );\n\t\t\t}\n\n\t\t\tif ( elem.parentNode ) {\n\t\t\t\tif ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {\n\t\t\t\t\tsetGlobalEval( getAll( elem, \"script\" ) );\n\t\t\t\t}\n\t\t\t\telem.parentNode.removeChild( elem );\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tempty: function() {\n\t\tvar elem,\n\t\t\ti = 0;\n\n\t\tfor ( ; (elem = this[i]) != null; i++ ) {\n\t\t\t// Remove element nodes and prevent memory leaks\n\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\t\t\t}\n\n\t\t\t// Remove any remaining nodes\n\t\t\twhile ( elem.firstChild ) {\n\t\t\t\telem.removeChild( elem.firstChild );\n\t\t\t}\n\n\t\t\t// If this is a select, ensure that it displays empty (#12336)\n\t\t\t// Support: IE<9\n\t\t\tif ( elem.options && jQuery.nodeName( elem, \"select\" ) ) {\n\t\t\t\telem.options.length = 0;\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tclone: function( dataAndEvents, deepDataAndEvents ) {\n\t\tdataAndEvents = dataAndEvents == null ? false : dataAndEvents;\n\t\tdeepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\n\n\t\treturn this.map(function() {\n\t\t\treturn jQuery.clone( this, dataAndEvents, deepDataAndEvents );\n\t\t});\n\t},\n\n\thtml: function( value ) {\n\t\treturn access( this, function( value ) {\n\t\t\tvar elem = this[ 0 ] || {},\n\t\t\t\ti = 0,\n\t\t\t\tl = this.length;\n\n\t\t\tif ( value === undefined ) {\n\t\t\t\treturn elem.nodeType === 1 ?\n\t\t\t\t\telem.innerHTML.replace( rinlinejQuery, \"\" ) :\n\t\t\t\t\tundefined;\n\t\t\t}\n\n\t\t\t// See if we can take a shortcut and just use innerHTML\n\t\t\tif ( typeof value === \"string\" && !rnoInnerhtml.test( value ) &&\n\t\t\t\t( support.htmlSerialize || !rnoshimcache.test( value )  ) &&\n\t\t\t\t( support.leadingWhitespace || !rleadingWhitespace.test( value ) ) &&\n\t\t\t\t!wrapMap[ (rtagName.exec( value ) || [ \"\", \"\" ])[ 1 ].toLowerCase() ] ) {\n\n\t\t\t\tvalue = value.replace( rxhtmlTag, \"<$1></$2>\" );\n\n\t\t\t\ttry {\n\t\t\t\t\tfor (; i < l; i++ ) {\n\t\t\t\t\t\t// Remove element nodes and prevent memory leaks\n\t\t\t\t\t\telem = this[i] || {};\n\t\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\t\t\t\t\t\t\telem.innerHTML = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telem = 0;\n\n\t\t\t\t// If using innerHTML throws an exception, use the fallback method\n\t\t\t\t} catch(e) {}\n\t\t\t}\n\n\t\t\tif ( elem ) {\n\t\t\t\tthis.empty().append( value );\n\t\t\t}\n\t\t}, null, value, arguments.length );\n\t},\n\n\treplaceWith: function() {\n\t\tvar arg = arguments[ 0 ];\n\n\t\t// Make the changes, replacing each context element with the new content\n\t\tthis.domManip( arguments, function( elem ) {\n\t\t\targ = this.parentNode;\n\n\t\t\tjQuery.cleanData( getAll( this ) );\n\n\t\t\tif ( arg ) {\n\t\t\t\targ.replaceChild( elem, this );\n\t\t\t}\n\t\t});\n\n\t\t// Force removal if there was no new content (e.g., from empty arguments)\n\t\treturn arg && (arg.length || arg.nodeType) ? this : this.remove();\n\t},\n\n\tdetach: function( selector ) {\n\t\treturn this.remove( selector, true );\n\t},\n\n\tdomManip: function( args, callback ) {\n\n\t\t// Flatten any nested arrays\n\t\targs = concat.apply( [], args );\n\n\t\tvar first, node, hasScripts,\n\t\t\tscripts, doc, fragment,\n\t\t\ti = 0,\n\t\t\tl = this.length,\n\t\t\tset = this,\n\t\t\tiNoClone = l - 1,\n\t\t\tvalue = args[0],\n\t\t\tisFunction = jQuery.isFunction( value );\n\n\t\t// We can't cloneNode fragments that contain checked, in WebKit\n\t\tif ( isFunction ||\n\t\t\t\t( l > 1 && typeof value === \"string\" &&\n\t\t\t\t\t!support.checkClone && rchecked.test( value ) ) ) {\n\t\t\treturn this.each(function( index ) {\n\t\t\t\tvar self = set.eq( index );\n\t\t\t\tif ( isFunction ) {\n\t\t\t\t\targs[0] = value.call( this, index, self.html() );\n\t\t\t\t}\n\t\t\t\tself.domManip( args, callback );\n\t\t\t});\n\t\t}\n\n\t\tif ( l ) {\n\t\t\tfragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, this );\n\t\t\tfirst = fragment.firstChild;\n\n\t\t\tif ( fragment.childNodes.length === 1 ) {\n\t\t\t\tfragment = first;\n\t\t\t}\n\n\t\t\tif ( first ) {\n\t\t\t\tscripts = jQuery.map( getAll( fragment, \"script\" ), disableScript );\n\t\t\t\thasScripts = scripts.length;\n\n\t\t\t\t// Use the original fragment for the last item instead of the first because it can end up\n\t\t\t\t// being emptied incorrectly in certain situations (#8070).\n\t\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\t\tnode = fragment;\n\n\t\t\t\t\tif ( i !== iNoClone ) {\n\t\t\t\t\t\tnode = jQuery.clone( node, true, true );\n\n\t\t\t\t\t\t// Keep references to cloned scripts for later restoration\n\t\t\t\t\t\tif ( hasScripts ) {\n\t\t\t\t\t\t\tjQuery.merge( scripts, getAll( node, \"script\" ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tcallback.call( this[i], node, i );\n\t\t\t\t}\n\n\t\t\t\tif ( hasScripts ) {\n\t\t\t\t\tdoc = scripts[ scripts.length - 1 ].ownerDocument;\n\n\t\t\t\t\t// Reenable scripts\n\t\t\t\t\tjQuery.map( scripts, restoreScript );\n\n\t\t\t\t\t// Evaluate executable scripts on first document insertion\n\t\t\t\t\tfor ( i = 0; i < hasScripts; i++ ) {\n\t\t\t\t\t\tnode = scripts[ i ];\n\t\t\t\t\t\tif ( rscriptType.test( node.type || \"\" ) &&\n\t\t\t\t\t\t\t!jQuery._data( node, \"globalEval\" ) && jQuery.contains( doc, node ) ) {\n\n\t\t\t\t\t\t\tif ( node.src ) {\n\t\t\t\t\t\t\t\t// Optional AJAX dependency, but won't run scripts if not present\n\t\t\t\t\t\t\t\tif ( jQuery._evalUrl ) {\n\t\t\t\t\t\t\t\t\tjQuery._evalUrl( node.src );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tjQuery.globalEval( ( node.text || node.textContent || node.innerHTML || \"\" ).replace( rcleanScript, \"\" ) );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Fix #11809: Avoid leaking memory\n\t\t\t\tfragment = first = null;\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t}\n});\n\njQuery.each({\n\tappendTo: \"append\",\n\tprependTo: \"prepend\",\n\tinsertBefore: \"before\",\n\tinsertAfter: \"after\",\n\treplaceAll: \"replaceWith\"\n}, function( name, original ) {\n\tjQuery.fn[ name ] = function( selector ) {\n\t\tvar elems,\n\t\t\ti = 0,\n\t\t\tret = [],\n\t\t\tinsert = jQuery( selector ),\n\t\t\tlast = insert.length - 1;\n\n\t\tfor ( ; i <= last; i++ ) {\n\t\t\telems = i === last ? this : this.clone(true);\n\t\t\tjQuery( insert[i] )[ original ]( elems );\n\n\t\t\t// Modern browsers can apply jQuery collections as arrays, but oldIE needs a .get()\n\t\t\tpush.apply( ret, elems.get() );\n\t\t}\n\n\t\treturn this.pushStack( ret );\n\t};\n});\n\n\nvar iframe,\n\telemdisplay = {};\n\n/**\n * Retrieve the actual display of a element\n * @param {String} name nodeName of the element\n * @param {Object} doc Document object\n */\n// Called only from within defaultDisplay\nfunction actualDisplay( name, doc ) {\n\tvar style,\n\t\telem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),\n\n\t\t// getDefaultComputedStyle might be reliably used only on attached element\n\t\tdisplay = window.getDefaultComputedStyle && ( style = window.getDefaultComputedStyle( elem[ 0 ] ) ) ?\n\n\t\t\t// Use of this method is a temporary fix (more like optmization) until something better comes along,\n\t\t\t// since it was removed from specification and supported only in FF\n\t\t\tstyle.display : jQuery.css( elem[ 0 ], \"display\" );\n\n\t// We don't have any data stored on the element,\n\t// so use \"detach\" method as fast way to get rid of the element\n\telem.detach();\n\n\treturn display;\n}\n\n/**\n * Try to determine the default display value of an element\n * @param {String} nodeName\n */\nfunction defaultDisplay( nodeName ) {\n\tvar doc = document,\n\t\tdisplay = elemdisplay[ nodeName ];\n\n\tif ( !display ) {\n\t\tdisplay = actualDisplay( nodeName, doc );\n\n\t\t// If the simple way fails, read from inside an iframe\n\t\tif ( display === \"none\" || !display ) {\n\n\t\t\t// Use the already-created iframe if possible\n\t\t\tiframe = (iframe || jQuery( \"<iframe frameborder='0' width='0' height='0'/>\" )).appendTo( doc.documentElement );\n\n\t\t\t// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse\n\t\t\tdoc = ( iframe[ 0 ].contentWindow || iframe[ 0 ].contentDocument ).document;\n\n\t\t\t// Support: IE\n\t\t\tdoc.write();\n\t\t\tdoc.close();\n\n\t\t\tdisplay = actualDisplay( nodeName, doc );\n\t\t\tiframe.detach();\n\t\t}\n\n\t\t// Store the correct default display\n\t\telemdisplay[ nodeName ] = display;\n\t}\n\n\treturn display;\n}\n\n\n(function() {\n\tvar shrinkWrapBlocksVal;\n\n\tsupport.shrinkWrapBlocks = function() {\n\t\tif ( shrinkWrapBlocksVal != null ) {\n\t\t\treturn shrinkWrapBlocksVal;\n\t\t}\n\n\t\t// Will be changed later if needed.\n\t\tshrinkWrapBlocksVal = false;\n\n\t\t// Minified: var b,c,d\n\t\tvar div, body, container;\n\n\t\tbody = document.getElementsByTagName( \"body\" )[ 0 ];\n\t\tif ( !body || !body.style ) {\n\t\t\t// Test fired too early or in an unsupported environment, exit.\n\t\t\treturn;\n\t\t}\n\n\t\t// Setup\n\t\tdiv = document.createElement( \"div\" );\n\t\tcontainer = document.createElement( \"div\" );\n\t\tcontainer.style.cssText = \"position:absolute;border:0;width:0;height:0;top:0;left:-9999px\";\n\t\tbody.appendChild( container ).appendChild( div );\n\n\t\t// Support: IE6\n\t\t// Check if elements with layout shrink-wrap their children\n\t\tif ( typeof div.style.zoom !== strundefined ) {\n\t\t\t// Reset CSS: box-sizing; display; margin; border\n\t\t\tdiv.style.cssText =\n\t\t\t\t// Support: Firefox<29, Android 2.3\n\t\t\t\t// Vendor-prefix box-sizing\n\t\t\t\t\"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;\" +\n\t\t\t\t\"box-sizing:content-box;display:block;margin:0;border:0;\" +\n\t\t\t\t\"padding:1px;width:1px;zoom:1\";\n\t\t\tdiv.appendChild( document.createElement( \"div\" ) ).style.width = \"5px\";\n\t\t\tshrinkWrapBlocksVal = div.offsetWidth !== 3;\n\t\t}\n\n\t\tbody.removeChild( container );\n\n\t\treturn shrinkWrapBlocksVal;\n\t};\n\n})();\nvar rmargin = (/^margin/);\n\nvar rnumnonpx = new RegExp( \"^(\" + pnum + \")(?!px)[a-z%]+$\", \"i\" );\n\n\n\nvar getStyles, curCSS,\n\trposition = /^(top|right|bottom|left)$/;\n\nif ( window.getComputedStyle ) {\n\tgetStyles = function( elem ) {\n\t\t// Support: IE<=11+, Firefox<=30+ (#15098, #14150)\n\t\t// IE throws on elements created in popups\n\t\t// FF meanwhile throws on frame elements through \"defaultView.getComputedStyle\"\n\t\tif ( elem.ownerDocument.defaultView.opener ) {\n\t\t\treturn elem.ownerDocument.defaultView.getComputedStyle( elem, null );\n\t\t}\n\n\t\treturn window.getComputedStyle( elem, null );\n\t};\n\n\tcurCSS = function( elem, name, computed ) {\n\t\tvar width, minWidth, maxWidth, ret,\n\t\t\tstyle = elem.style;\n\n\t\tcomputed = computed || getStyles( elem );\n\n\t\t// getPropertyValue is only needed for .css('filter') in IE9, see #12537\n\t\tret = computed ? computed.getPropertyValue( name ) || computed[ name ] : undefined;\n\n\t\tif ( computed ) {\n\n\t\t\tif ( ret === \"\" && !jQuery.contains( elem.ownerDocument, elem ) ) {\n\t\t\t\tret = jQuery.style( elem, name );\n\t\t\t}\n\n\t\t\t// A tribute to the \"awesome hack by Dean Edwards\"\n\t\t\t// Chrome < 17 and Safari 5.0 uses \"computed value\" instead of \"used value\" for margin-right\n\t\t\t// Safari 5.1.7 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels\n\t\t\t// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values\n\t\t\tif ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {\n\n\t\t\t\t// Remember the original values\n\t\t\t\twidth = style.width;\n\t\t\t\tminWidth = style.minWidth;\n\t\t\t\tmaxWidth = style.maxWidth;\n\n\t\t\t\t// Put in the new values to get a computed value out\n\t\t\t\tstyle.minWidth = style.maxWidth = style.width = ret;\n\t\t\t\tret = computed.width;\n\n\t\t\t\t// Revert the changed values\n\t\t\t\tstyle.width = width;\n\t\t\t\tstyle.minWidth = minWidth;\n\t\t\t\tstyle.maxWidth = maxWidth;\n\t\t\t}\n\t\t}\n\n\t\t// Support: IE\n\t\t// IE returns zIndex value as an integer.\n\t\treturn ret === undefined ?\n\t\t\tret :\n\t\t\tret + \"\";\n\t};\n} else if ( document.documentElement.currentStyle ) {\n\tgetStyles = function( elem ) {\n\t\treturn elem.currentStyle;\n\t};\n\n\tcurCSS = function( elem, name, computed ) {\n\t\tvar left, rs, rsLeft, ret,\n\t\t\tstyle = elem.style;\n\n\t\tcomputed = computed || getStyles( elem );\n\t\tret = computed ? computed[ name ] : undefined;\n\n\t\t// Avoid setting ret to empty string here\n\t\t// so we don't default to auto\n\t\tif ( ret == null && style && style[ name ] ) {\n\t\t\tret = style[ name ];\n\t\t}\n\n\t\t// From the awesome hack by Dean Edwards\n\t\t// http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291\n\n\t\t// If we're not dealing with a regular pixel number\n\t\t// but a number that has a weird ending, we need to convert it to pixels\n\t\t// but not position css attributes, as those are proportional to the parent element instead\n\t\t// and we can't measure the parent instead because it might trigger a \"stacking dolls\" problem\n\t\tif ( rnumnonpx.test( ret ) && !rposition.test( name ) ) {\n\n\t\t\t// Remember the original values\n\t\t\tleft = style.left;\n\t\t\trs = elem.runtimeStyle;\n\t\t\trsLeft = rs && rs.left;\n\n\t\t\t// Put in the new values to get a computed value out\n\t\t\tif ( rsLeft ) {\n\t\t\t\trs.left = elem.currentStyle.left;\n\t\t\t}\n\t\t\tstyle.left = name === \"fontSize\" ? \"1em\" : ret;\n\t\t\tret = style.pixelLeft + \"px\";\n\n\t\t\t// Revert the changed values\n\t\t\tstyle.left = left;\n\t\t\tif ( rsLeft ) {\n\t\t\t\trs.left = rsLeft;\n\t\t\t}\n\t\t}\n\n\t\t// Support: IE\n\t\t// IE returns zIndex value as an integer.\n\t\treturn ret === undefined ?\n\t\t\tret :\n\t\t\tret + \"\" || \"auto\";\n\t};\n}\n\n\n\n\nfunction addGetHookIf( conditionFn, hookFn ) {\n\t// Define the hook, we'll check on the first run if it's really needed.\n\treturn {\n\t\tget: function() {\n\t\t\tvar condition = conditionFn();\n\n\t\t\tif ( condition == null ) {\n\t\t\t\t// The test was not ready at this point; screw the hook this time\n\t\t\t\t// but check again when needed next time.\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( condition ) {\n\t\t\t\t// Hook not needed (or it's not possible to use it due to missing dependency),\n\t\t\t\t// remove it.\n\t\t\t\t// Since there are no other hooks for marginRight, remove the whole object.\n\t\t\t\tdelete this.get;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Hook needed; redefine it so that the support test is not executed again.\n\n\t\t\treturn (this.get = hookFn).apply( this, arguments );\n\t\t}\n\t};\n}\n\n\n(function() {\n\t// Minified: var b,c,d,e,f,g, h,i\n\tvar div, style, a, pixelPositionVal, boxSizingReliableVal,\n\t\treliableHiddenOffsetsVal, reliableMarginRightVal;\n\n\t// Setup\n\tdiv = document.createElement( \"div\" );\n\tdiv.innerHTML = \"  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>\";\n\ta = div.getElementsByTagName( \"a\" )[ 0 ];\n\tstyle = a && a.style;\n\n\t// Finish early in limited (non-browser) environments\n\tif ( !style ) {\n\t\treturn;\n\t}\n\n\tstyle.cssText = \"float:left;opacity:.5\";\n\n\t// Support: IE<9\n\t// Make sure that element opacity exists (as opposed to filter)\n\tsupport.opacity = style.opacity === \"0.5\";\n\n\t// Verify style float existence\n\t// (IE uses styleFloat instead of cssFloat)\n\tsupport.cssFloat = !!style.cssFloat;\n\n\tdiv.style.backgroundClip = \"content-box\";\n\tdiv.cloneNode( true ).style.backgroundClip = \"\";\n\tsupport.clearCloneStyle = div.style.backgroundClip === \"content-box\";\n\n\t// Support: Firefox<29, Android 2.3\n\t// Vendor-prefix box-sizing\n\tsupport.boxSizing = style.boxSizing === \"\" || style.MozBoxSizing === \"\" ||\n\t\tstyle.WebkitBoxSizing === \"\";\n\n\tjQuery.extend(support, {\n\t\treliableHiddenOffsets: function() {\n\t\t\tif ( reliableHiddenOffsetsVal == null ) {\n\t\t\t\tcomputeStyleTests();\n\t\t\t}\n\t\t\treturn reliableHiddenOffsetsVal;\n\t\t},\n\n\t\tboxSizingReliable: function() {\n\t\t\tif ( boxSizingReliableVal == null ) {\n\t\t\t\tcomputeStyleTests();\n\t\t\t}\n\t\t\treturn boxSizingReliableVal;\n\t\t},\n\n\t\tpixelPosition: function() {\n\t\t\tif ( pixelPositionVal == null ) {\n\t\t\t\tcomputeStyleTests();\n\t\t\t}\n\t\t\treturn pixelPositionVal;\n\t\t},\n\n\t\t// Support: Android 2.3\n\t\treliableMarginRight: function() {\n\t\t\tif ( reliableMarginRightVal == null ) {\n\t\t\t\tcomputeStyleTests();\n\t\t\t}\n\t\t\treturn reliableMarginRightVal;\n\t\t}\n\t});\n\n\tfunction computeStyleTests() {\n\t\t// Minified: var b,c,d,j\n\t\tvar div, body, container, contents;\n\n\t\tbody = document.getElementsByTagName( \"body\" )[ 0 ];\n\t\tif ( !body || !body.style ) {\n\t\t\t// Test fired too early or in an unsupported environment, exit.\n\t\t\treturn;\n\t\t}\n\n\t\t// Setup\n\t\tdiv = document.createElement( \"div\" );\n\t\tcontainer = document.createElement( \"div\" );\n\t\tcontainer.style.cssText = \"position:absolute;border:0;width:0;height:0;top:0;left:-9999px\";\n\t\tbody.appendChild( container ).appendChild( div );\n\n\t\tdiv.style.cssText =\n\t\t\t// Support: Firefox<29, Android 2.3\n\t\t\t// Vendor-prefix box-sizing\n\t\t\t\"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;\" +\n\t\t\t\"box-sizing:border-box;display:block;margin-top:1%;top:1%;\" +\n\t\t\t\"border:1px;padding:1px;width:4px;position:absolute\";\n\n\t\t// Support: IE<9\n\t\t// Assume reasonable values in the absence of getComputedStyle\n\t\tpixelPositionVal = boxSizingReliableVal = false;\n\t\treliableMarginRightVal = true;\n\n\t\t// Check for getComputedStyle so that this code is not run in IE<9.\n\t\tif ( window.getComputedStyle ) {\n\t\t\tpixelPositionVal = ( window.getComputedStyle( div, null ) || {} ).top !== \"1%\";\n\t\t\tboxSizingReliableVal =\n\t\t\t\t( window.getComputedStyle( div, null ) || { width: \"4px\" } ).width === \"4px\";\n\n\t\t\t// Support: Android 2.3\n\t\t\t// Div with explicit width and no margin-right incorrectly\n\t\t\t// gets computed margin-right based on width of container (#3333)\n\t\t\t// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right\n\t\t\tcontents = div.appendChild( document.createElement( \"div\" ) );\n\n\t\t\t// Reset CSS: box-sizing; display; margin; border; padding\n\t\t\tcontents.style.cssText = div.style.cssText =\n\t\t\t\t// Support: Firefox<29, Android 2.3\n\t\t\t\t// Vendor-prefix box-sizing\n\t\t\t\t\"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;\" +\n\t\t\t\t\"box-sizing:content-box;display:block;margin:0;border:0;padding:0\";\n\t\t\tcontents.style.marginRight = contents.style.width = \"0\";\n\t\t\tdiv.style.width = \"1px\";\n\n\t\t\treliableMarginRightVal =\n\t\t\t\t!parseFloat( ( window.getComputedStyle( contents, null ) || {} ).marginRight );\n\n\t\t\tdiv.removeChild( contents );\n\t\t}\n\n\t\t// Support: IE8\n\t\t// Check if table cells still have offsetWidth/Height when they are set\n\t\t// to display:none and there are still other visible table cells in a\n\t\t// table row; if so, offsetWidth/Height are not reliable for use when\n\t\t// determining if an element has been hidden directly using\n\t\t// display:none (it is still safe to use offsets if a parent element is\n\t\t// hidden; don safety goggles and see bug #4512 for more information).\n\t\tdiv.innerHTML = \"<table><tr><td></td><td>t</td></tr></table>\";\n\t\tcontents = div.getElementsByTagName( \"td\" );\n\t\tcontents[ 0 ].style.cssText = \"margin:0;border:0;padding:0;display:none\";\n\t\treliableHiddenOffsetsVal = contents[ 0 ].offsetHeight === 0;\n\t\tif ( reliableHiddenOffsetsVal ) {\n\t\t\tcontents[ 0 ].style.display = \"\";\n\t\t\tcontents[ 1 ].style.display = \"none\";\n\t\t\treliableHiddenOffsetsVal = contents[ 0 ].offsetHeight === 0;\n\t\t}\n\n\t\tbody.removeChild( container );\n\t}\n\n})();\n\n\n// A method for quickly swapping in/out CSS properties to get correct calculations.\njQuery.swap = function( elem, options, callback, args ) {\n\tvar ret, name,\n\t\told = {};\n\n\t// Remember the old values, and insert the new ones\n\tfor ( name in options ) {\n\t\told[ name ] = elem.style[ name ];\n\t\telem.style[ name ] = options[ name ];\n\t}\n\n\tret = callback.apply( elem, args || [] );\n\n\t// Revert the old values\n\tfor ( name in options ) {\n\t\telem.style[ name ] = old[ name ];\n\t}\n\n\treturn ret;\n};\n\n\nvar\n\t\tralpha = /alpha\\([^)]*\\)/i,\n\tropacity = /opacity\\s*=\\s*([^)]*)/,\n\n\t// swappable if display is none or starts with table except \"table\", \"table-cell\", or \"table-caption\"\n\t// see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\n\trdisplayswap = /^(none|table(?!-c[ea]).+)/,\n\trnumsplit = new RegExp( \"^(\" + pnum + \")(.*)$\", \"i\" ),\n\trrelNum = new RegExp( \"^([+-])=(\" + pnum + \")\", \"i\" ),\n\n\tcssShow = { position: \"absolute\", visibility: \"hidden\", display: \"block\" },\n\tcssNormalTransform = {\n\t\tletterSpacing: \"0\",\n\t\tfontWeight: \"400\"\n\t},\n\n\tcssPrefixes = [ \"Webkit\", \"O\", \"Moz\", \"ms\" ];\n\n\n// return a css property mapped to a potentially vendor prefixed property\nfunction vendorPropName( style, name ) {\n\n\t// shortcut for names that are not vendor prefixed\n\tif ( name in style ) {\n\t\treturn name;\n\t}\n\n\t// check for vendor prefixed names\n\tvar capName = name.charAt(0).toUpperCase() + name.slice(1),\n\t\torigName = name,\n\t\ti = cssPrefixes.length;\n\n\twhile ( i-- ) {\n\t\tname = cssPrefixes[ i ] + capName;\n\t\tif ( name in style ) {\n\t\t\treturn name;\n\t\t}\n\t}\n\n\treturn origName;\n}\n\nfunction showHide( elements, show ) {\n\tvar display, elem, hidden,\n\t\tvalues = [],\n\t\tindex = 0,\n\t\tlength = elements.length;\n\n\tfor ( ; index < length; index++ ) {\n\t\telem = elements[ index ];\n\t\tif ( !elem.style ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tvalues[ index ] = jQuery._data( elem, \"olddisplay\" );\n\t\tdisplay = elem.style.display;\n\t\tif ( show ) {\n\t\t\t// Reset the inline display of this element to learn if it is\n\t\t\t// being hidden by cascaded rules or not\n\t\t\tif ( !values[ index ] && display === \"none\" ) {\n\t\t\t\telem.style.display = \"\";\n\t\t\t}\n\n\t\t\t// Set elements which have been overridden with display: none\n\t\t\t// in a stylesheet to whatever the default browser style is\n\t\t\t// for such an element\n\t\t\tif ( elem.style.display === \"\" && isHidden( elem ) ) {\n\t\t\t\tvalues[ index ] = jQuery._data( elem, \"olddisplay\", defaultDisplay(elem.nodeName) );\n\t\t\t}\n\t\t} else {\n\t\t\thidden = isHidden( elem );\n\n\t\t\tif ( display && display !== \"none\" || !hidden ) {\n\t\t\t\tjQuery._data( elem, \"olddisplay\", hidden ? display : jQuery.css( elem, \"display\" ) );\n\t\t\t}\n\t\t}\n\t}\n\n\t// Set the display of most of the elements in a second loop\n\t// to avoid the constant reflow\n\tfor ( index = 0; index < length; index++ ) {\n\t\telem = elements[ index ];\n\t\tif ( !elem.style ) {\n\t\t\tcontinue;\n\t\t}\n\t\tif ( !show || elem.style.display === \"none\" || elem.style.display === \"\" ) {\n\t\t\telem.style.display = show ? values[ index ] || \"\" : \"none\";\n\t\t}\n\t}\n\n\treturn elements;\n}\n\nfunction setPositiveNumber( elem, value, subtract ) {\n\tvar matches = rnumsplit.exec( value );\n\treturn matches ?\n\t\t// Guard against undefined \"subtract\", e.g., when used as in cssHooks\n\t\tMath.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || \"px\" ) :\n\t\tvalue;\n}\n\nfunction augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {\n\tvar i = extra === ( isBorderBox ? \"border\" : \"content\" ) ?\n\t\t// If we already have the right measurement, avoid augmentation\n\t\t4 :\n\t\t// Otherwise initialize for horizontal or vertical properties\n\t\tname === \"width\" ? 1 : 0,\n\n\t\tval = 0;\n\n\tfor ( ; i < 4; i += 2 ) {\n\t\t// both box models exclude margin, so add it if we want it\n\t\tif ( extra === \"margin\" ) {\n\t\t\tval += jQuery.css( elem, extra + cssExpand[ i ], true, styles );\n\t\t}\n\n\t\tif ( isBorderBox ) {\n\t\t\t// border-box includes padding, so remove it if we want content\n\t\t\tif ( extra === \"content\" ) {\n\t\t\t\tval -= jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\t\t\t}\n\n\t\t\t// at this point, extra isn't border nor margin, so remove border\n\t\t\tif ( extra !== \"margin\" ) {\n\t\t\t\tval -= jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\t\t\t}\n\t\t} else {\n\t\t\t// at this point, extra isn't content, so add padding\n\t\t\tval += jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\n\t\t\t// at this point, extra isn't content nor padding, so add border\n\t\t\tif ( extra !== \"padding\" ) {\n\t\t\t\tval += jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn val;\n}\n\nfunction getWidthOrHeight( elem, name, extra ) {\n\n\t// Start with offset property, which is equivalent to the border-box value\n\tvar valueIsBorderBox = true,\n\t\tval = name === \"width\" ? elem.offsetWidth : elem.offsetHeight,\n\t\tstyles = getStyles( elem ),\n\t\tisBorderBox = support.boxSizing && jQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\";\n\n\t// some non-html elements return undefined for offsetWidth, so check for null/undefined\n\t// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285\n\t// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668\n\tif ( val <= 0 || val == null ) {\n\t\t// Fall back to computed then uncomputed css if necessary\n\t\tval = curCSS( elem, name, styles );\n\t\tif ( val < 0 || val == null ) {\n\t\t\tval = elem.style[ name ];\n\t\t}\n\n\t\t// Computed unit is not pixels. Stop here and return.\n\t\tif ( rnumnonpx.test(val) ) {\n\t\t\treturn val;\n\t\t}\n\n\t\t// we need the check for style in case a browser which returns unreliable values\n\t\t// for getComputedStyle silently falls back to the reliable elem.style\n\t\tvalueIsBorderBox = isBorderBox && ( support.boxSizingReliable() || val === elem.style[ name ] );\n\n\t\t// Normalize \"\", auto, and prepare for extra\n\t\tval = parseFloat( val ) || 0;\n\t}\n\n\t// use the active box-sizing model to add/subtract irrelevant styles\n\treturn ( val +\n\t\taugmentWidthOrHeight(\n\t\t\telem,\n\t\t\tname,\n\t\t\textra || ( isBorderBox ? \"border\" : \"content\" ),\n\t\t\tvalueIsBorderBox,\n\t\t\tstyles\n\t\t)\n\t) + \"px\";\n}\n\njQuery.extend({\n\t// Add in style property hooks for overriding the default\n\t// behavior of getting and setting a style property\n\tcssHooks: {\n\t\topacity: {\n\t\t\tget: function( elem, computed ) {\n\t\t\t\tif ( computed ) {\n\t\t\t\t\t// We should always get a number back from opacity\n\t\t\t\t\tvar ret = curCSS( elem, \"opacity\" );\n\t\t\t\t\treturn ret === \"\" ? \"1\" : ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t// Don't automatically add \"px\" to these possibly-unitless properties\n\tcssNumber: {\n\t\t\"columnCount\": true,\n\t\t\"fillOpacity\": true,\n\t\t\"flexGrow\": true,\n\t\t\"flexShrink\": true,\n\t\t\"fontWeight\": true,\n\t\t\"lineHeight\": true,\n\t\t\"opacity\": true,\n\t\t\"order\": true,\n\t\t\"orphans\": true,\n\t\t\"widows\": true,\n\t\t\"zIndex\": true,\n\t\t\"zoom\": true\n\t},\n\n\t// Add in properties whose names you wish to fix before\n\t// setting or getting the value\n\tcssProps: {\n\t\t// normalize float css property\n\t\t\"float\": support.cssFloat ? \"cssFloat\" : \"styleFloat\"\n\t},\n\n\t// Get and set the style property on a DOM Node\n\tstyle: function( elem, name, value, extra ) {\n\t\t// Don't set styles on text and comment nodes\n\t\tif ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Make sure that we're working with the right name\n\t\tvar ret, type, hooks,\n\t\t\torigName = jQuery.camelCase( name ),\n\t\t\tstyle = elem.style;\n\n\t\tname = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );\n\n\t\t// gets hook for the prefixed version\n\t\t// followed by the unprefixed version\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// Check if we're setting a value\n\t\tif ( value !== undefined ) {\n\t\t\ttype = typeof value;\n\n\t\t\t// convert relative number strings (+= or -=) to relative numbers. #7345\n\t\t\tif ( type === \"string\" && (ret = rrelNum.exec( value )) ) {\n\t\t\t\tvalue = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );\n\t\t\t\t// Fixes bug #9237\n\t\t\t\ttype = \"number\";\n\t\t\t}\n\n\t\t\t// Make sure that null and NaN values aren't set. See: #7116\n\t\t\tif ( value == null || value !== value ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// If a number was passed in, add 'px' to the (except for certain CSS properties)\n\t\t\tif ( type === \"number\" && !jQuery.cssNumber[ origName ] ) {\n\t\t\t\tvalue += \"px\";\n\t\t\t}\n\n\t\t\t// Fixes #8908, it can be done more correctly by specifing setters in cssHooks,\n\t\t\t// but it would mean to define eight (for every problematic property) identical functions\n\t\t\tif ( !support.clearCloneStyle && value === \"\" && name.indexOf(\"background\") === 0 ) {\n\t\t\t\tstyle[ name ] = \"inherit\";\n\t\t\t}\n\n\t\t\t// If a hook was provided, use that value, otherwise just set the specified value\n\t\t\tif ( !hooks || !(\"set\" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {\n\n\t\t\t\t// Support: IE\n\t\t\t\t// Swallow errors from 'invalid' CSS values (#5509)\n\t\t\t\ttry {\n\t\t\t\t\tstyle[ name ] = value;\n\t\t\t\t} catch(e) {}\n\t\t\t}\n\n\t\t} else {\n\t\t\t// If a hook was provided get the non-computed value from there\n\t\t\tif ( hooks && \"get\" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t// Otherwise just get the value from the style object\n\t\t\treturn style[ name ];\n\t\t}\n\t},\n\n\tcss: function( elem, name, extra, styles ) {\n\t\tvar num, val, hooks,\n\t\t\torigName = jQuery.camelCase( name );\n\n\t\t// Make sure that we're working with the right name\n\t\tname = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );\n\n\t\t// gets hook for the prefixed version\n\t\t// followed by the unprefixed version\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// If a hook was provided get the computed value from there\n\t\tif ( hooks && \"get\" in hooks ) {\n\t\t\tval = hooks.get( elem, true, extra );\n\t\t}\n\n\t\t// Otherwise, if a way to get the computed value exists, use that\n\t\tif ( val === undefined ) {\n\t\t\tval = curCSS( elem, name, styles );\n\t\t}\n\n\t\t//convert \"normal\" to computed value\n\t\tif ( val === \"normal\" && name in cssNormalTransform ) {\n\t\t\tval = cssNormalTransform[ name ];\n\t\t}\n\n\t\t// Return, converting to number if forced or a qualifier was provided and val looks numeric\n\t\tif ( extra === \"\" || extra ) {\n\t\t\tnum = parseFloat( val );\n\t\t\treturn extra === true || jQuery.isNumeric( num ) ? num || 0 : val;\n\t\t}\n\t\treturn val;\n\t}\n});\n\njQuery.each([ \"height\", \"width\" ], function( i, name ) {\n\tjQuery.cssHooks[ name ] = {\n\t\tget: function( elem, computed, extra ) {\n\t\t\tif ( computed ) {\n\t\t\t\t// certain elements can have dimension info if we invisibly show them\n\t\t\t\t// however, it must have a current display style that would benefit from this\n\t\t\t\treturn rdisplayswap.test( jQuery.css( elem, \"display\" ) ) && elem.offsetWidth === 0 ?\n\t\t\t\t\tjQuery.swap( elem, cssShow, function() {\n\t\t\t\t\t\treturn getWidthOrHeight( elem, name, extra );\n\t\t\t\t\t}) :\n\t\t\t\t\tgetWidthOrHeight( elem, name, extra );\n\t\t\t}\n\t\t},\n\n\t\tset: function( elem, value, extra ) {\n\t\t\tvar styles = extra && getStyles( elem );\n\t\t\treturn setPositiveNumber( elem, value, extra ?\n\t\t\t\taugmentWidthOrHeight(\n\t\t\t\t\telem,\n\t\t\t\t\tname,\n\t\t\t\t\textra,\n\t\t\t\t\tsupport.boxSizing && jQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\",\n\t\t\t\t\tstyles\n\t\t\t\t) : 0\n\t\t\t);\n\t\t}\n\t};\n});\n\nif ( !support.opacity ) {\n\tjQuery.cssHooks.opacity = {\n\t\tget: function( elem, computed ) {\n\t\t\t// IE uses filters for opacity\n\t\t\treturn ropacity.test( (computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || \"\" ) ?\n\t\t\t\t( 0.01 * parseFloat( RegExp.$1 ) ) + \"\" :\n\t\t\t\tcomputed ? \"1\" : \"\";\n\t\t},\n\n\t\tset: function( elem, value ) {\n\t\t\tvar style = elem.style,\n\t\t\t\tcurrentStyle = elem.currentStyle,\n\t\t\t\topacity = jQuery.isNumeric( value ) ? \"alpha(opacity=\" + value * 100 + \")\" : \"\",\n\t\t\t\tfilter = currentStyle && currentStyle.filter || style.filter || \"\";\n\n\t\t\t// IE has trouble with opacity if it does not have layout\n\t\t\t// Force it by setting the zoom level\n\t\t\tstyle.zoom = 1;\n\n\t\t\t// if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652\n\t\t\t// if value === \"\", then remove inline opacity #12685\n\t\t\tif ( ( value >= 1 || value === \"\" ) &&\n\t\t\t\t\tjQuery.trim( filter.replace( ralpha, \"\" ) ) === \"\" &&\n\t\t\t\t\tstyle.removeAttribute ) {\n\n\t\t\t\t// Setting style.filter to null, \"\" & \" \" still leave \"filter:\" in the cssText\n\t\t\t\t// if \"filter:\" is present at all, clearType is disabled, we want to avoid this\n\t\t\t\t// style.removeAttribute is IE Only, but so apparently is this code path...\n\t\t\t\tstyle.removeAttribute( \"filter\" );\n\n\t\t\t\t// if there is no filter style applied in a css rule or unset inline opacity, we are done\n\t\t\t\tif ( value === \"\" || currentStyle && !currentStyle.filter ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// otherwise, set new filter values\n\t\t\tstyle.filter = ralpha.test( filter ) ?\n\t\t\t\tfilter.replace( ralpha, opacity ) :\n\t\t\t\tfilter + \" \" + opacity;\n\t\t}\n\t};\n}\n\njQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,\n\tfunction( elem, computed ) {\n\t\tif ( computed ) {\n\t\t\t// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right\n\t\t\t// Work around by temporarily setting element display to inline-block\n\t\t\treturn jQuery.swap( elem, { \"display\": \"inline-block\" },\n\t\t\t\tcurCSS, [ elem, \"marginRight\" ] );\n\t\t}\n\t}\n);\n\n// These hooks are used by animate to expand properties\njQuery.each({\n\tmargin: \"\",\n\tpadding: \"\",\n\tborder: \"Width\"\n}, function( prefix, suffix ) {\n\tjQuery.cssHooks[ prefix + suffix ] = {\n\t\texpand: function( value ) {\n\t\t\tvar i = 0,\n\t\t\t\texpanded = {},\n\n\t\t\t\t// assumes a single number if not a string\n\t\t\t\tparts = typeof value === \"string\" ? value.split(\" \") : [ value ];\n\n\t\t\tfor ( ; i < 4; i++ ) {\n\t\t\t\texpanded[ prefix + cssExpand[ i ] + suffix ] =\n\t\t\t\t\tparts[ i ] || parts[ i - 2 ] || parts[ 0 ];\n\t\t\t}\n\n\t\t\treturn expanded;\n\t\t}\n\t};\n\n\tif ( !rmargin.test( prefix ) ) {\n\t\tjQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;\n\t}\n});\n\njQuery.fn.extend({\n\tcss: function( name, value ) {\n\t\treturn access( this, function( elem, name, value ) {\n\t\t\tvar styles, len,\n\t\t\t\tmap = {},\n\t\t\t\ti = 0;\n\n\t\t\tif ( jQuery.isArray( name ) ) {\n\t\t\t\tstyles = getStyles( elem );\n\t\t\t\tlen = name.length;\n\n\t\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\t\tmap[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );\n\t\t\t\t}\n\n\t\t\t\treturn map;\n\t\t\t}\n\n\t\t\treturn value !== undefined ?\n\t\t\t\tjQuery.style( elem, name, value ) :\n\t\t\t\tjQuery.css( elem, name );\n\t\t}, name, value, arguments.length > 1 );\n\t},\n\tshow: function() {\n\t\treturn showHide( this, true );\n\t},\n\thide: function() {\n\t\treturn showHide( this );\n\t},\n\ttoggle: function( state ) {\n\t\tif ( typeof state === \"boolean\" ) {\n\t\t\treturn state ? this.show() : this.hide();\n\t\t}\n\n\t\treturn this.each(function() {\n\t\t\tif ( isHidden( this ) ) {\n\t\t\t\tjQuery( this ).show();\n\t\t\t} else {\n\t\t\t\tjQuery( this ).hide();\n\t\t\t}\n\t\t});\n\t}\n});\n\n\nfunction Tween( elem, options, prop, end, easing ) {\n\treturn new Tween.prototype.init( elem, options, prop, end, easing );\n}\njQuery.Tween = Tween;\n\nTween.prototype = {\n\tconstructor: Tween,\n\tinit: function( elem, options, prop, end, easing, unit ) {\n\t\tthis.elem = elem;\n\t\tthis.prop = prop;\n\t\tthis.easing = easing || \"swing\";\n\t\tthis.options = options;\n\t\tthis.start = this.now = this.cur();\n\t\tthis.end = end;\n\t\tthis.unit = unit || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" );\n\t},\n\tcur: function() {\n\t\tvar hooks = Tween.propHooks[ this.prop ];\n\n\t\treturn hooks && hooks.get ?\n\t\t\thooks.get( this ) :\n\t\t\tTween.propHooks._default.get( this );\n\t},\n\trun: function( percent ) {\n\t\tvar eased,\n\t\t\thooks = Tween.propHooks[ this.prop ];\n\n\t\tif ( this.options.duration ) {\n\t\t\tthis.pos = eased = jQuery.easing[ this.easing ](\n\t\t\t\tpercent, this.options.duration * percent, 0, 1, this.options.duration\n\t\t\t);\n\t\t} else {\n\t\t\tthis.pos = eased = percent;\n\t\t}\n\t\tthis.now = ( this.end - this.start ) * eased + this.start;\n\n\t\tif ( this.options.step ) {\n\t\t\tthis.options.step.call( this.elem, this.now, this );\n\t\t}\n\n\t\tif ( hooks && hooks.set ) {\n\t\t\thooks.set( this );\n\t\t} else {\n\t\t\tTween.propHooks._default.set( this );\n\t\t}\n\t\treturn this;\n\t}\n};\n\nTween.prototype.init.prototype = Tween.prototype;\n\nTween.propHooks = {\n\t_default: {\n\t\tget: function( tween ) {\n\t\t\tvar result;\n\n\t\t\tif ( tween.elem[ tween.prop ] != null &&\n\t\t\t\t(!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {\n\t\t\t\treturn tween.elem[ tween.prop ];\n\t\t\t}\n\n\t\t\t// passing an empty string as a 3rd parameter to .css will automatically\n\t\t\t// attempt a parseFloat and fallback to a string if the parse fails\n\t\t\t// so, simple values such as \"10px\" are parsed to Float.\n\t\t\t// complex values such as \"rotate(1rad)\" are returned as is.\n\t\t\tresult = jQuery.css( tween.elem, tween.prop, \"\" );\n\t\t\t// Empty strings, null, undefined and \"auto\" are converted to 0.\n\t\t\treturn !result || result === \"auto\" ? 0 : result;\n\t\t},\n\t\tset: function( tween ) {\n\t\t\t// use step hook for back compat - use cssHook if its there - use .style if its\n\t\t\t// available and use plain properties where available\n\t\t\tif ( jQuery.fx.step[ tween.prop ] ) {\n\t\t\t\tjQuery.fx.step[ tween.prop ]( tween );\n\t\t\t} else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {\n\t\t\t\tjQuery.style( tween.elem, tween.prop, tween.now + tween.unit );\n\t\t\t} else {\n\t\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t\t}\n\t\t}\n\t}\n};\n\n// Support: IE <=9\n// Panic based approach to setting things on disconnected nodes\n\nTween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\n\tset: function( tween ) {\n\t\tif ( tween.elem.nodeType && tween.elem.parentNode ) {\n\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t}\n\t}\n};\n\njQuery.easing = {\n\tlinear: function( p ) {\n\t\treturn p;\n\t},\n\tswing: function( p ) {\n\t\treturn 0.5 - Math.cos( p * Math.PI ) / 2;\n\t}\n};\n\njQuery.fx = Tween.prototype.init;\n\n// Back Compat <1.8 extension point\njQuery.fx.step = {};\n\n\n\n\nvar\n\tfxNow, timerId,\n\trfxtypes = /^(?:toggle|show|hide)$/,\n\trfxnum = new RegExp( \"^(?:([+-])=|)(\" + pnum + \")([a-z%]*)$\", \"i\" ),\n\trrun = /queueHooks$/,\n\tanimationPrefilters = [ defaultPrefilter ],\n\ttweeners = {\n\t\t\"*\": [ function( prop, value ) {\n\t\t\tvar tween = this.createTween( prop, value ),\n\t\t\t\ttarget = tween.cur(),\n\t\t\t\tparts = rfxnum.exec( value ),\n\t\t\t\tunit = parts && parts[ 3 ] || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" ),\n\n\t\t\t\t// Starting value computation is required for potential unit mismatches\n\t\t\t\tstart = ( jQuery.cssNumber[ prop ] || unit !== \"px\" && +target ) &&\n\t\t\t\t\trfxnum.exec( jQuery.css( tween.elem, prop ) ),\n\t\t\t\tscale = 1,\n\t\t\t\tmaxIterations = 20;\n\n\t\t\tif ( start && start[ 3 ] !== unit ) {\n\t\t\t\t// Trust units reported by jQuery.css\n\t\t\t\tunit = unit || start[ 3 ];\n\n\t\t\t\t// Make sure we update the tween properties later on\n\t\t\t\tparts = parts || [];\n\n\t\t\t\t// Iteratively approximate from a nonzero starting point\n\t\t\t\tstart = +target || 1;\n\n\t\t\t\tdo {\n\t\t\t\t\t// If previous iteration zeroed out, double until we get *something*\n\t\t\t\t\t// Use a string for doubling factor so we don't accidentally see scale as unchanged below\n\t\t\t\t\tscale = scale || \".5\";\n\n\t\t\t\t\t// Adjust and apply\n\t\t\t\t\tstart = start / scale;\n\t\t\t\t\tjQuery.style( tween.elem, prop, start + unit );\n\n\t\t\t\t// Update scale, tolerating zero or NaN from tween.cur()\n\t\t\t\t// And breaking the loop if scale is unchanged or perfect, or if we've just had enough\n\t\t\t\t} while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );\n\t\t\t}\n\n\t\t\t// Update tween properties\n\t\t\tif ( parts ) {\n\t\t\t\tstart = tween.start = +start || +target || 0;\n\t\t\t\ttween.unit = unit;\n\t\t\t\t// If a +=/-= token was provided, we're doing a relative animation\n\t\t\t\ttween.end = parts[ 1 ] ?\n\t\t\t\t\tstart + ( parts[ 1 ] + 1 ) * parts[ 2 ] :\n\t\t\t\t\t+parts[ 2 ];\n\t\t\t}\n\n\t\t\treturn tween;\n\t\t} ]\n\t};\n\n// Animations created synchronously will run synchronously\nfunction createFxNow() {\n\tsetTimeout(function() {\n\t\tfxNow = undefined;\n\t});\n\treturn ( fxNow = jQuery.now() );\n}\n\n// Generate parameters to create a standard animation\nfunction genFx( type, includeWidth ) {\n\tvar which,\n\t\tattrs = { height: type },\n\t\ti = 0;\n\n\t// if we include width, step value is 1 to do all cssExpand values,\n\t// if we don't include width, step value is 2 to skip over Left and Right\n\tincludeWidth = includeWidth ? 1 : 0;\n\tfor ( ; i < 4 ; i += 2 - includeWidth ) {\n\t\twhich = cssExpand[ i ];\n\t\tattrs[ \"margin\" + which ] = attrs[ \"padding\" + which ] = type;\n\t}\n\n\tif ( includeWidth ) {\n\t\tattrs.opacity = attrs.width = type;\n\t}\n\n\treturn attrs;\n}\n\nfunction createTween( value, prop, animation ) {\n\tvar tween,\n\t\tcollection = ( tweeners[ prop ] || [] ).concat( tweeners[ \"*\" ] ),\n\t\tindex = 0,\n\t\tlength = collection.length;\n\tfor ( ; index < length; index++ ) {\n\t\tif ( (tween = collection[ index ].call( animation, prop, value )) ) {\n\n\t\t\t// we're done with this property\n\t\t\treturn tween;\n\t\t}\n\t}\n}\n\nfunction defaultPrefilter( elem, props, opts ) {\n\t/* jshint validthis: true */\n\tvar prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,\n\t\tanim = this,\n\t\torig = {},\n\t\tstyle = elem.style,\n\t\thidden = elem.nodeType && isHidden( elem ),\n\t\tdataShow = jQuery._data( elem, \"fxshow\" );\n\n\t// handle queue: false promises\n\tif ( !opts.queue ) {\n\t\thooks = jQuery._queueHooks( elem, \"fx\" );\n\t\tif ( hooks.unqueued == null ) {\n\t\t\thooks.unqueued = 0;\n\t\t\toldfire = hooks.empty.fire;\n\t\t\thooks.empty.fire = function() {\n\t\t\t\tif ( !hooks.unqueued ) {\n\t\t\t\t\toldfire();\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\thooks.unqueued++;\n\n\t\tanim.always(function() {\n\t\t\t// doing this makes sure that the complete handler will be called\n\t\t\t// before this completes\n\t\t\tanim.always(function() {\n\t\t\t\thooks.unqueued--;\n\t\t\t\tif ( !jQuery.queue( elem, \"fx\" ).length ) {\n\t\t\t\t\thooks.empty.fire();\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t// height/width overflow pass\n\tif ( elem.nodeType === 1 && ( \"height\" in props || \"width\" in props ) ) {\n\t\t// Make sure that nothing sneaks out\n\t\t// Record all 3 overflow attributes because IE does not\n\t\t// change the overflow attribute when overflowX and\n\t\t// overflowY are set to the same value\n\t\topts.overflow = [ style.overflow, style.overflowX, style.overflowY ];\n\n\t\t// Set display property to inline-block for height/width\n\t\t// animations on inline elements that are having width/height animated\n\t\tdisplay = jQuery.css( elem, \"display\" );\n\n\t\t// Test default display if display is currently \"none\"\n\t\tcheckDisplay = display === \"none\" ?\n\t\t\tjQuery._data( elem, \"olddisplay\" ) || defaultDisplay( elem.nodeName ) : display;\n\n\t\tif ( checkDisplay === \"inline\" && jQuery.css( elem, \"float\" ) === \"none\" ) {\n\n\t\t\t// inline-level elements accept inline-block;\n\t\t\t// block-level elements need to be inline with layout\n\t\t\tif ( !support.inlineBlockNeedsLayout || defaultDisplay( elem.nodeName ) === \"inline\" ) {\n\t\t\t\tstyle.display = \"inline-block\";\n\t\t\t} else {\n\t\t\t\tstyle.zoom = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( opts.overflow ) {\n\t\tstyle.overflow = \"hidden\";\n\t\tif ( !support.shrinkWrapBlocks() ) {\n\t\t\tanim.always(function() {\n\t\t\t\tstyle.overflow = opts.overflow[ 0 ];\n\t\t\t\tstyle.overflowX = opts.overflow[ 1 ];\n\t\t\t\tstyle.overflowY = opts.overflow[ 2 ];\n\t\t\t});\n\t\t}\n\t}\n\n\t// show/hide pass\n\tfor ( prop in props ) {\n\t\tvalue = props[ prop ];\n\t\tif ( rfxtypes.exec( value ) ) {\n\t\t\tdelete props[ prop ];\n\t\t\ttoggle = toggle || value === \"toggle\";\n\t\t\tif ( value === ( hidden ? \"hide\" : \"show\" ) ) {\n\n\t\t\t\t// If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden\n\t\t\t\tif ( value === \"show\" && dataShow && dataShow[ prop ] !== undefined ) {\n\t\t\t\t\thidden = true;\n\t\t\t\t} else {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\torig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );\n\n\t\t// Any non-fx value stops us from restoring the original display value\n\t\t} else {\n\t\t\tdisplay = undefined;\n\t\t}\n\t}\n\n\tif ( !jQuery.isEmptyObject( orig ) ) {\n\t\tif ( dataShow ) {\n\t\t\tif ( \"hidden\" in dataShow ) {\n\t\t\t\thidden = dataShow.hidden;\n\t\t\t}\n\t\t} else {\n\t\t\tdataShow = jQuery._data( elem, \"fxshow\", {} );\n\t\t}\n\n\t\t// store state if its toggle - enables .stop().toggle() to \"reverse\"\n\t\tif ( toggle ) {\n\t\t\tdataShow.hidden = !hidden;\n\t\t}\n\t\tif ( hidden ) {\n\t\t\tjQuery( elem ).show();\n\t\t} else {\n\t\t\tanim.done(function() {\n\t\t\t\tjQuery( elem ).hide();\n\t\t\t});\n\t\t}\n\t\tanim.done(function() {\n\t\t\tvar prop;\n\t\t\tjQuery._removeData( elem, \"fxshow\" );\n\t\t\tfor ( prop in orig ) {\n\t\t\t\tjQuery.style( elem, prop, orig[ prop ] );\n\t\t\t}\n\t\t});\n\t\tfor ( prop in orig ) {\n\t\t\ttween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );\n\n\t\t\tif ( !( prop in dataShow ) ) {\n\t\t\t\tdataShow[ prop ] = tween.start;\n\t\t\t\tif ( hidden ) {\n\t\t\t\t\ttween.end = tween.start;\n\t\t\t\t\ttween.start = prop === \"width\" || prop === \"height\" ? 1 : 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t// If this is a noop like .hide().hide(), restore an overwritten display value\n\t} else if ( (display === \"none\" ? defaultDisplay( elem.nodeName ) : display) === \"inline\" ) {\n\t\tstyle.display = display;\n\t}\n}\n\nfunction propFilter( props, specialEasing ) {\n\tvar index, name, easing, value, hooks;\n\n\t// camelCase, specialEasing and expand cssHook pass\n\tfor ( index in props ) {\n\t\tname = jQuery.camelCase( index );\n\t\teasing = specialEasing[ name ];\n\t\tvalue = props[ index ];\n\t\tif ( jQuery.isArray( value ) ) {\n\t\t\teasing = value[ 1 ];\n\t\t\tvalue = props[ index ] = value[ 0 ];\n\t\t}\n\n\t\tif ( index !== name ) {\n\t\t\tprops[ name ] = value;\n\t\t\tdelete props[ index ];\n\t\t}\n\n\t\thooks = jQuery.cssHooks[ name ];\n\t\tif ( hooks && \"expand\" in hooks ) {\n\t\t\tvalue = hooks.expand( value );\n\t\t\tdelete props[ name ];\n\n\t\t\t// not quite $.extend, this wont overwrite keys already present.\n\t\t\t// also - reusing 'index' from above because we have the correct \"name\"\n\t\t\tfor ( index in value ) {\n\t\t\t\tif ( !( index in props ) ) {\n\t\t\t\t\tprops[ index ] = value[ index ];\n\t\t\t\t\tspecialEasing[ index ] = easing;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tspecialEasing[ name ] = easing;\n\t\t}\n\t}\n}\n\nfunction Animation( elem, properties, options ) {\n\tvar result,\n\t\tstopped,\n\t\tindex = 0,\n\t\tlength = animationPrefilters.length,\n\t\tdeferred = jQuery.Deferred().always( function() {\n\t\t\t// don't match elem in the :animated selector\n\t\t\tdelete tick.elem;\n\t\t}),\n\t\ttick = function() {\n\t\t\tif ( stopped ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar currentTime = fxNow || createFxNow(),\n\t\t\t\tremaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),\n\t\t\t\t// archaic crash bug won't allow us to use 1 - ( 0.5 || 0 ) (#12497)\n\t\t\t\ttemp = remaining / animation.duration || 0,\n\t\t\t\tpercent = 1 - temp,\n\t\t\t\tindex = 0,\n\t\t\t\tlength = animation.tweens.length;\n\n\t\t\tfor ( ; index < length ; index++ ) {\n\t\t\t\tanimation.tweens[ index ].run( percent );\n\t\t\t}\n\n\t\t\tdeferred.notifyWith( elem, [ animation, percent, remaining ]);\n\n\t\t\tif ( percent < 1 && length ) {\n\t\t\t\treturn remaining;\n\t\t\t} else {\n\t\t\t\tdeferred.resolveWith( elem, [ animation ] );\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\t\tanimation = deferred.promise({\n\t\t\telem: elem,\n\t\t\tprops: jQuery.extend( {}, properties ),\n\t\t\topts: jQuery.extend( true, { specialEasing: {} }, options ),\n\t\t\toriginalProperties: properties,\n\t\t\toriginalOptions: options,\n\t\t\tstartTime: fxNow || createFxNow(),\n\t\t\tduration: options.duration,\n\t\t\ttweens: [],\n\t\t\tcreateTween: function( prop, end ) {\n\t\t\t\tvar tween = jQuery.Tween( elem, animation.opts, prop, end,\n\t\t\t\t\t\tanimation.opts.specialEasing[ prop ] || animation.opts.easing );\n\t\t\t\tanimation.tweens.push( tween );\n\t\t\t\treturn tween;\n\t\t\t},\n\t\t\tstop: function( gotoEnd ) {\n\t\t\t\tvar index = 0,\n\t\t\t\t\t// if we are going to the end, we want to run all the tweens\n\t\t\t\t\t// otherwise we skip this part\n\t\t\t\t\tlength = gotoEnd ? animation.tweens.length : 0;\n\t\t\t\tif ( stopped ) {\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t\tstopped = true;\n\t\t\t\tfor ( ; index < length ; index++ ) {\n\t\t\t\t\tanimation.tweens[ index ].run( 1 );\n\t\t\t\t}\n\n\t\t\t\t// resolve when we played the last frame\n\t\t\t\t// otherwise, reject\n\t\t\t\tif ( gotoEnd ) {\n\t\t\t\t\tdeferred.resolveWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t} else {\n\t\t\t\t\tdeferred.rejectWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}),\n\t\tprops = animation.props;\n\n\tpropFilter( props, animation.opts.specialEasing );\n\n\tfor ( ; index < length ; index++ ) {\n\t\tresult = animationPrefilters[ index ].call( animation, elem, props, animation.opts );\n\t\tif ( result ) {\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tjQuery.map( props, createTween, animation );\n\n\tif ( jQuery.isFunction( animation.opts.start ) ) {\n\t\tanimation.opts.start.call( elem, animation );\n\t}\n\n\tjQuery.fx.timer(\n\t\tjQuery.extend( tick, {\n\t\t\telem: elem,\n\t\t\tanim: animation,\n\t\t\tqueue: animation.opts.queue\n\t\t})\n\t);\n\n\t// attach callbacks from options\n\treturn animation.progress( animation.opts.progress )\n\t\t.done( animation.opts.done, animation.opts.complete )\n\t\t.fail( animation.opts.fail )\n\t\t.always( animation.opts.always );\n}\n\njQuery.Animation = jQuery.extend( Animation, {\n\ttweener: function( props, callback ) {\n\t\tif ( jQuery.isFunction( props ) ) {\n\t\t\tcallback = props;\n\t\t\tprops = [ \"*\" ];\n\t\t} else {\n\t\t\tprops = props.split(\" \");\n\t\t}\n\n\t\tvar prop,\n\t\t\tindex = 0,\n\t\t\tlength = props.length;\n\n\t\tfor ( ; index < length ; index++ ) {\n\t\t\tprop = props[ index ];\n\t\t\ttweeners[ prop ] = tweeners[ prop ] || [];\n\t\t\ttweeners[ prop ].unshift( callback );\n\t\t}\n\t},\n\n\tprefilter: function( callback, prepend ) {\n\t\tif ( prepend ) {\n\t\t\tanimationPrefilters.unshift( callback );\n\t\t} else {\n\t\t\tanimationPrefilters.push( callback );\n\t\t}\n\t}\n});\n\njQuery.speed = function( speed, easing, fn ) {\n\tvar opt = speed && typeof speed === \"object\" ? jQuery.extend( {}, speed ) : {\n\t\tcomplete: fn || !fn && easing ||\n\t\t\tjQuery.isFunction( speed ) && speed,\n\t\tduration: speed,\n\t\teasing: fn && easing || easing && !jQuery.isFunction( easing ) && easing\n\t};\n\n\topt.duration = jQuery.fx.off ? 0 : typeof opt.duration === \"number\" ? opt.duration :\n\t\topt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;\n\n\t// normalize opt.queue - true/undefined/null -> \"fx\"\n\tif ( opt.queue == null || opt.queue === true ) {\n\t\topt.queue = \"fx\";\n\t}\n\n\t// Queueing\n\topt.old = opt.complete;\n\n\topt.complete = function() {\n\t\tif ( jQuery.isFunction( opt.old ) ) {\n\t\t\topt.old.call( this );\n\t\t}\n\n\t\tif ( opt.queue ) {\n\t\t\tjQuery.dequeue( this, opt.queue );\n\t\t}\n\t};\n\n\treturn opt;\n};\n\njQuery.fn.extend({\n\tfadeTo: function( speed, to, easing, callback ) {\n\n\t\t// show any hidden elements after setting opacity to 0\n\t\treturn this.filter( isHidden ).css( \"opacity\", 0 ).show()\n\n\t\t\t// animate to the value specified\n\t\t\t.end().animate({ opacity: to }, speed, easing, callback );\n\t},\n\tanimate: function( prop, speed, easing, callback ) {\n\t\tvar empty = jQuery.isEmptyObject( prop ),\n\t\t\toptall = jQuery.speed( speed, easing, callback ),\n\t\t\tdoAnimation = function() {\n\t\t\t\t// Operate on a copy of prop so per-property easing won't be lost\n\t\t\t\tvar anim = Animation( this, jQuery.extend( {}, prop ), optall );\n\n\t\t\t\t// Empty animations, or finishing resolves immediately\n\t\t\t\tif ( empty || jQuery._data( this, \"finish\" ) ) {\n\t\t\t\t\tanim.stop( true );\n\t\t\t\t}\n\t\t\t};\n\t\t\tdoAnimation.finish = doAnimation;\n\n\t\treturn empty || optall.queue === false ?\n\t\t\tthis.each( doAnimation ) :\n\t\t\tthis.queue( optall.queue, doAnimation );\n\t},\n\tstop: function( type, clearQueue, gotoEnd ) {\n\t\tvar stopQueue = function( hooks ) {\n\t\t\tvar stop = hooks.stop;\n\t\t\tdelete hooks.stop;\n\t\t\tstop( gotoEnd );\n\t\t};\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tgotoEnd = clearQueue;\n\t\t\tclearQueue = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\tif ( clearQueue && type !== false ) {\n\t\t\tthis.queue( type || \"fx\", [] );\n\t\t}\n\n\t\treturn this.each(function() {\n\t\t\tvar dequeue = true,\n\t\t\t\tindex = type != null && type + \"queueHooks\",\n\t\t\t\ttimers = jQuery.timers,\n\t\t\t\tdata = jQuery._data( this );\n\n\t\t\tif ( index ) {\n\t\t\t\tif ( data[ index ] && data[ index ].stop ) {\n\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( index in data ) {\n\t\t\t\t\tif ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {\n\t\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\tif ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {\n\t\t\t\t\ttimers[ index ].anim.stop( gotoEnd );\n\t\t\t\t\tdequeue = false;\n\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// start the next in the queue if the last step wasn't forced\n\t\t\t// timers currently will call their complete callbacks, which will dequeue\n\t\t\t// but only if they were gotoEnd\n\t\t\tif ( dequeue || !gotoEnd ) {\n\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t}\n\t\t});\n\t},\n\tfinish: function( type ) {\n\t\tif ( type !== false ) {\n\t\t\ttype = type || \"fx\";\n\t\t}\n\t\treturn this.each(function() {\n\t\t\tvar index,\n\t\t\t\tdata = jQuery._data( this ),\n\t\t\t\tqueue = data[ type + \"queue\" ],\n\t\t\t\thooks = data[ type + \"queueHooks\" ],\n\t\t\t\ttimers = jQuery.timers,\n\t\t\t\tlength = queue ? queue.length : 0;\n\n\t\t\t// enable finishing flag on private data\n\t\t\tdata.finish = true;\n\n\t\t\t// empty the queue first\n\t\t\tjQuery.queue( this, type, [] );\n\n\t\t\tif ( hooks && hooks.stop ) {\n\t\t\t\thooks.stop.call( this, true );\n\t\t\t}\n\n\t\t\t// look for any active animations, and finish them\n\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\tif ( timers[ index ].elem === this && timers[ index ].queue === type ) {\n\t\t\t\t\ttimers[ index ].anim.stop( true );\n\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// look for any animations in the old queue and finish them\n\t\t\tfor ( index = 0; index < length; index++ ) {\n\t\t\t\tif ( queue[ index ] && queue[ index ].finish ) {\n\t\t\t\t\tqueue[ index ].finish.call( this );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// turn off finishing flag\n\t\t\tdelete data.finish;\n\t\t});\n\t}\n});\n\njQuery.each([ \"toggle\", \"show\", \"hide\" ], function( i, name ) {\n\tvar cssFn = jQuery.fn[ name ];\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn speed == null || typeof speed === \"boolean\" ?\n\t\t\tcssFn.apply( this, arguments ) :\n\t\t\tthis.animate( genFx( name, true ), speed, easing, callback );\n\t};\n});\n\n// Generate shortcuts for custom animations\njQuery.each({\n\tslideDown: genFx(\"show\"),\n\tslideUp: genFx(\"hide\"),\n\tslideToggle: genFx(\"toggle\"),\n\tfadeIn: { opacity: \"show\" },\n\tfadeOut: { opacity: \"hide\" },\n\tfadeToggle: { opacity: \"toggle\" }\n}, function( name, props ) {\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn this.animate( props, speed, easing, callback );\n\t};\n});\n\njQuery.timers = [];\njQuery.fx.tick = function() {\n\tvar timer,\n\t\ttimers = jQuery.timers,\n\t\ti = 0;\n\n\tfxNow = jQuery.now();\n\n\tfor ( ; i < timers.length; i++ ) {\n\t\ttimer = timers[ i ];\n\t\t// Checks the timer has not already been removed\n\t\tif ( !timer() && timers[ i ] === timer ) {\n\t\t\ttimers.splice( i--, 1 );\n\t\t}\n\t}\n\n\tif ( !timers.length ) {\n\t\tjQuery.fx.stop();\n\t}\n\tfxNow = undefined;\n};\n\njQuery.fx.timer = function( timer ) {\n\tjQuery.timers.push( timer );\n\tif ( timer() ) {\n\t\tjQuery.fx.start();\n\t} else {\n\t\tjQuery.timers.pop();\n\t}\n};\n\njQuery.fx.interval = 13;\n\njQuery.fx.start = function() {\n\tif ( !timerId ) {\n\t\ttimerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );\n\t}\n};\n\njQuery.fx.stop = function() {\n\tclearInterval( timerId );\n\ttimerId = null;\n};\n\njQuery.fx.speeds = {\n\tslow: 600,\n\tfast: 200,\n\t// Default speed\n\t_default: 400\n};\n\n\n// Based off of the plugin by Clint Helfers, with permission.\n// http://blindsignals.com/index.php/2009/07/jquery-delay/\njQuery.fn.delay = function( time, type ) {\n\ttime = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;\n\ttype = type || \"fx\";\n\n\treturn this.queue( type, function( next, hooks ) {\n\t\tvar timeout = setTimeout( next, time );\n\t\thooks.stop = function() {\n\t\t\tclearTimeout( timeout );\n\t\t};\n\t});\n};\n\n\n(function() {\n\t// Minified: var a,b,c,d,e\n\tvar input, div, select, a, opt;\n\n\t// Setup\n\tdiv = document.createElement( \"div\" );\n\tdiv.setAttribute( \"className\", \"t\" );\n\tdiv.innerHTML = \"  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>\";\n\ta = div.getElementsByTagName(\"a\")[ 0 ];\n\n\t// First batch of tests.\n\tselect = document.createElement(\"select\");\n\topt = select.appendChild( document.createElement(\"option\") );\n\tinput = div.getElementsByTagName(\"input\")[ 0 ];\n\n\ta.style.cssText = \"top:1px\";\n\n\t// Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)\n\tsupport.getSetAttribute = div.className !== \"t\";\n\n\t// Get the style information from getAttribute\n\t// (IE uses .cssText instead)\n\tsupport.style = /top/.test( a.getAttribute(\"style\") );\n\n\t// Make sure that URLs aren't manipulated\n\t// (IE normalizes it by default)\n\tsupport.hrefNormalized = a.getAttribute(\"href\") === \"/a\";\n\n\t// Check the default checkbox/radio value (\"\" on WebKit; \"on\" elsewhere)\n\tsupport.checkOn = !!input.value;\n\n\t// Make sure that a selected-by-default option has a working selected property.\n\t// (WebKit defaults to false instead of true, IE too, if it's in an optgroup)\n\tsupport.optSelected = opt.selected;\n\n\t// Tests for enctype support on a form (#6743)\n\tsupport.enctype = !!document.createElement(\"form\").enctype;\n\n\t// Make sure that the options inside disabled selects aren't marked as disabled\n\t// (WebKit marks them as disabled)\n\tselect.disabled = true;\n\tsupport.optDisabled = !opt.disabled;\n\n\t// Support: IE8 only\n\t// Check if we can trust getAttribute(\"value\")\n\tinput = document.createElement( \"input\" );\n\tinput.setAttribute( \"value\", \"\" );\n\tsupport.input = input.getAttribute( \"value\" ) === \"\";\n\n\t// Check if an input maintains its value after becoming a radio\n\tinput.value = \"t\";\n\tinput.setAttribute( \"type\", \"radio\" );\n\tsupport.radioValue = input.value === \"t\";\n})();\n\n\nvar rreturn = /\\r/g;\n\njQuery.fn.extend({\n\tval: function( value ) {\n\t\tvar hooks, ret, isFunction,\n\t\t\telem = this[0];\n\n\t\tif ( !arguments.length ) {\n\t\t\tif ( elem ) {\n\t\t\t\thooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];\n\n\t\t\t\tif ( hooks && \"get\" in hooks && (ret = hooks.get( elem, \"value\" )) !== undefined ) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tret = elem.value;\n\n\t\t\t\treturn typeof ret === \"string\" ?\n\t\t\t\t\t// handle most common string cases\n\t\t\t\t\tret.replace(rreturn, \"\") :\n\t\t\t\t\t// handle cases where value is null/undef or number\n\t\t\t\t\tret == null ? \"\" : ret;\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tisFunction = jQuery.isFunction( value );\n\n\t\treturn this.each(function( i ) {\n\t\t\tvar val;\n\n\t\t\tif ( this.nodeType !== 1 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( isFunction ) {\n\t\t\t\tval = value.call( this, i, jQuery( this ).val() );\n\t\t\t} else {\n\t\t\t\tval = value;\n\t\t\t}\n\n\t\t\t// Treat null/undefined as \"\"; convert numbers to string\n\t\t\tif ( val == null ) {\n\t\t\t\tval = \"\";\n\t\t\t} else if ( typeof val === \"number\" ) {\n\t\t\t\tval += \"\";\n\t\t\t} else if ( jQuery.isArray( val ) ) {\n\t\t\t\tval = jQuery.map( val, function( value ) {\n\t\t\t\t\treturn value == null ? \"\" : value + \"\";\n\t\t\t\t});\n\t\t\t}\n\n\t\t\thooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];\n\n\t\t\t// If set returns undefined, fall back to normal setting\n\t\t\tif ( !hooks || !(\"set\" in hooks) || hooks.set( this, val, \"value\" ) === undefined ) {\n\t\t\t\tthis.value = val;\n\t\t\t}\n\t\t});\n\t}\n});\n\njQuery.extend({\n\tvalHooks: {\n\t\toption: {\n\t\t\tget: function( elem ) {\n\t\t\t\tvar val = jQuery.find.attr( elem, \"value\" );\n\t\t\t\treturn val != null ?\n\t\t\t\t\tval :\n\t\t\t\t\t// Support: IE10-11+\n\t\t\t\t\t// option.text throws exceptions (#14686, #14858)\n\t\t\t\t\tjQuery.trim( jQuery.text( elem ) );\n\t\t\t}\n\t\t},\n\t\tselect: {\n\t\t\tget: function( elem ) {\n\t\t\t\tvar value, option,\n\t\t\t\t\toptions = elem.options,\n\t\t\t\t\tindex = elem.selectedIndex,\n\t\t\t\t\tone = elem.type === \"select-one\" || index < 0,\n\t\t\t\t\tvalues = one ? null : [],\n\t\t\t\t\tmax = one ? index + 1 : options.length,\n\t\t\t\t\ti = index < 0 ?\n\t\t\t\t\t\tmax :\n\t\t\t\t\t\tone ? index : 0;\n\n\t\t\t\t// Loop through all the selected options\n\t\t\t\tfor ( ; i < max; i++ ) {\n\t\t\t\t\toption = options[ i ];\n\n\t\t\t\t\t// oldIE doesn't update selected after form reset (#2551)\n\t\t\t\t\tif ( ( option.selected || i === index ) &&\n\t\t\t\t\t\t\t// Don't return options that are disabled or in a disabled optgroup\n\t\t\t\t\t\t\t( support.optDisabled ? !option.disabled : option.getAttribute(\"disabled\") === null ) &&\n\t\t\t\t\t\t\t( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, \"optgroup\" ) ) ) {\n\n\t\t\t\t\t\t// Get the specific value for the option\n\t\t\t\t\t\tvalue = jQuery( option ).val();\n\n\t\t\t\t\t\t// We don't need an array for one selects\n\t\t\t\t\t\tif ( one ) {\n\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Multi-Selects return an array\n\t\t\t\t\t\tvalues.push( value );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn values;\n\t\t\t},\n\n\t\t\tset: function( elem, value ) {\n\t\t\t\tvar optionSet, option,\n\t\t\t\t\toptions = elem.options,\n\t\t\t\t\tvalues = jQuery.makeArray( value ),\n\t\t\t\t\ti = options.length;\n\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\toption = options[ i ];\n\n\t\t\t\t\tif ( jQuery.inArray( jQuery.valHooks.option.get( option ), values ) >= 0 ) {\n\n\t\t\t\t\t\t// Support: IE6\n\t\t\t\t\t\t// When new option element is added to select box we need to\n\t\t\t\t\t\t// force reflow of newly added node in order to workaround delay\n\t\t\t\t\t\t// of initialization properties\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\toption.selected = optionSet = true;\n\n\t\t\t\t\t\t} catch ( _ ) {\n\n\t\t\t\t\t\t\t// Will be executed only in IE6\n\t\t\t\t\t\t\toption.scrollHeight;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\toption.selected = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Force browsers to behave consistently when non-matching value is set\n\t\t\t\tif ( !optionSet ) {\n\t\t\t\t\telem.selectedIndex = -1;\n\t\t\t\t}\n\n\t\t\t\treturn options;\n\t\t\t}\n\t\t}\n\t}\n});\n\n// Radios and checkboxes getter/setter\njQuery.each([ \"radio\", \"checkbox\" ], function() {\n\tjQuery.valHooks[ this ] = {\n\t\tset: function( elem, value ) {\n\t\t\tif ( jQuery.isArray( value ) ) {\n\t\t\t\treturn ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );\n\t\t\t}\n\t\t}\n\t};\n\tif ( !support.checkOn ) {\n\t\tjQuery.valHooks[ this ].get = function( elem ) {\n\t\t\t// Support: Webkit\n\t\t\t// \"\" is returned instead of \"on\" if a value isn't specified\n\t\t\treturn elem.getAttribute(\"value\") === null ? \"on\" : elem.value;\n\t\t};\n\t}\n});\n\n\n\n\nvar nodeHook, boolHook,\n\tattrHandle = jQuery.expr.attrHandle,\n\truseDefault = /^(?:checked|selected)$/i,\n\tgetSetAttribute = support.getSetAttribute,\n\tgetSetInput = support.input;\n\njQuery.fn.extend({\n\tattr: function( name, value ) {\n\t\treturn access( this, jQuery.attr, name, value, arguments.length > 1 );\n\t},\n\n\tremoveAttr: function( name ) {\n\t\treturn this.each(function() {\n\t\t\tjQuery.removeAttr( this, name );\n\t\t});\n\t}\n});\n\njQuery.extend({\n\tattr: function( elem, name, value ) {\n\t\tvar hooks, ret,\n\t\t\tnType = elem.nodeType;\n\n\t\t// don't get/set attributes on text, comment and attribute nodes\n\t\tif ( !elem || nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Fallback to prop when attributes are not supported\n\t\tif ( typeof elem.getAttribute === strundefined ) {\n\t\t\treturn jQuery.prop( elem, name, value );\n\t\t}\n\n\t\t// All attributes are lowercase\n\t\t// Grab necessary hook if one is defined\n\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n\t\t\tname = name.toLowerCase();\n\t\t\thooks = jQuery.attrHooks[ name ] ||\n\t\t\t\t( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\n\t\t\tif ( value === null ) {\n\t\t\t\tjQuery.removeAttr( elem, name );\n\n\t\t\t} else if ( hooks && \"set\" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {\n\t\t\t\treturn ret;\n\n\t\t\t} else {\n\t\t\t\telem.setAttribute( name, value + \"\" );\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t} else if ( hooks && \"get\" in hooks && (ret = hooks.get( elem, name )) !== null ) {\n\t\t\treturn ret;\n\n\t\t} else {\n\t\t\tret = jQuery.find.attr( elem, name );\n\n\t\t\t// Non-existent attributes return null, we normalize to undefined\n\t\t\treturn ret == null ?\n\t\t\t\tundefined :\n\t\t\t\tret;\n\t\t}\n\t},\n\n\tremoveAttr: function( elem, value ) {\n\t\tvar name, propName,\n\t\t\ti = 0,\n\t\t\tattrNames = value && value.match( rnotwhite );\n\n\t\tif ( attrNames && elem.nodeType === 1 ) {\n\t\t\twhile ( (name = attrNames[i++]) ) {\n\t\t\t\tpropName = jQuery.propFix[ name ] || name;\n\n\t\t\t\t// Boolean attributes get special treatment (#10870)\n\t\t\t\tif ( jQuery.expr.match.bool.test( name ) ) {\n\t\t\t\t\t// Set corresponding property to false\n\t\t\t\t\tif ( getSetInput && getSetAttribute || !ruseDefault.test( name ) ) {\n\t\t\t\t\t\telem[ propName ] = false;\n\t\t\t\t\t// Support: IE<9\n\t\t\t\t\t// Also clear defaultChecked/defaultSelected (if appropriate)\n\t\t\t\t\t} else {\n\t\t\t\t\t\telem[ jQuery.camelCase( \"default-\" + name ) ] =\n\t\t\t\t\t\t\telem[ propName ] = false;\n\t\t\t\t\t}\n\n\t\t\t\t// See #9699 for explanation of this approach (setting first, then removal)\n\t\t\t\t} else {\n\t\t\t\t\tjQuery.attr( elem, name, \"\" );\n\t\t\t\t}\n\n\t\t\t\telem.removeAttribute( getSetAttribute ? name : propName );\n\t\t\t}\n\t\t}\n\t},\n\n\tattrHooks: {\n\t\ttype: {\n\t\t\tset: function( elem, value ) {\n\t\t\t\tif ( !support.radioValue && value === \"radio\" && jQuery.nodeName(elem, \"input\") ) {\n\t\t\t\t\t// Setting the type on a radio button after the value resets the value in IE6-9\n\t\t\t\t\t// Reset value to default in case type is set after value during creation\n\t\t\t\t\tvar val = elem.value;\n\t\t\t\t\telem.setAttribute( \"type\", value );\n\t\t\t\t\tif ( val ) {\n\t\t\t\t\t\telem.value = val;\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n});\n\n// Hook for boolean attributes\nboolHook = {\n\tset: function( elem, value, name ) {\n\t\tif ( value === false ) {\n\t\t\t// Remove boolean attributes when set to false\n\t\t\tjQuery.removeAttr( elem, name );\n\t\t} else if ( getSetInput && getSetAttribute || !ruseDefault.test( name ) ) {\n\t\t\t// IE<8 needs the *property* name\n\t\t\telem.setAttribute( !getSetAttribute && jQuery.propFix[ name ] || name, name );\n\n\t\t// Use defaultChecked and defaultSelected for oldIE\n\t\t} else {\n\t\t\telem[ jQuery.camelCase( \"default-\" + name ) ] = elem[ name ] = true;\n\t\t}\n\n\t\treturn name;\n\t}\n};\n\n// Retrieve booleans specially\njQuery.each( jQuery.expr.match.bool.source.match( /\\w+/g ), function( i, name ) {\n\n\tvar getter = attrHandle[ name ] || jQuery.find.attr;\n\n\tattrHandle[ name ] = getSetInput && getSetAttribute || !ruseDefault.test( name ) ?\n\t\tfunction( elem, name, isXML ) {\n\t\t\tvar ret, handle;\n\t\t\tif ( !isXML ) {\n\t\t\t\t// Avoid an infinite loop by temporarily removing this function from the getter\n\t\t\t\thandle = attrHandle[ name ];\n\t\t\t\tattrHandle[ name ] = ret;\n\t\t\t\tret = getter( elem, name, isXML ) != null ?\n\t\t\t\t\tname.toLowerCase() :\n\t\t\t\t\tnull;\n\t\t\t\tattrHandle[ name ] = handle;\n\t\t\t}\n\t\t\treturn ret;\n\t\t} :\n\t\tfunction( elem, name, isXML ) {\n\t\t\tif ( !isXML ) {\n\t\t\t\treturn elem[ jQuery.camelCase( \"default-\" + name ) ] ?\n\t\t\t\t\tname.toLowerCase() :\n\t\t\t\t\tnull;\n\t\t\t}\n\t\t};\n});\n\n// fix oldIE attroperties\nif ( !getSetInput || !getSetAttribute ) {\n\tjQuery.attrHooks.value = {\n\t\tset: function( elem, value, name ) {\n\t\t\tif ( jQuery.nodeName( elem, \"input\" ) ) {\n\t\t\t\t// Does not return so that setAttribute is also used\n\t\t\t\telem.defaultValue = value;\n\t\t\t} else {\n\t\t\t\t// Use nodeHook if defined (#1954); otherwise setAttribute is fine\n\t\t\t\treturn nodeHook && nodeHook.set( elem, value, name );\n\t\t\t}\n\t\t}\n\t};\n}\n\n// IE6/7 do not support getting/setting some attributes with get/setAttribute\nif ( !getSetAttribute ) {\n\n\t// Use this for any attribute in IE6/7\n\t// This fixes almost every IE6/7 issue\n\tnodeHook = {\n\t\tset: function( elem, value, name ) {\n\t\t\t// Set the existing or create a new attribute node\n\t\t\tvar ret = elem.getAttributeNode( name );\n\t\t\tif ( !ret ) {\n\t\t\t\telem.setAttributeNode(\n\t\t\t\t\t(ret = elem.ownerDocument.createAttribute( name ))\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tret.value = value += \"\";\n\n\t\t\t// Break association with cloned elements by also using setAttribute (#9646)\n\t\t\tif ( name === \"value\" || value === elem.getAttribute( name ) ) {\n\t\t\t\treturn value;\n\t\t\t}\n\t\t}\n\t};\n\n\t// Some attributes are constructed with empty-string values when not defined\n\tattrHandle.id = attrHandle.name = attrHandle.coords =\n\t\tfunction( elem, name, isXML ) {\n\t\t\tvar ret;\n\t\t\tif ( !isXML ) {\n\t\t\t\treturn (ret = elem.getAttributeNode( name )) && ret.value !== \"\" ?\n\t\t\t\t\tret.value :\n\t\t\t\t\tnull;\n\t\t\t}\n\t\t};\n\n\t// Fixing value retrieval on a button requires this module\n\tjQuery.valHooks.button = {\n\t\tget: function( elem, name ) {\n\t\t\tvar ret = elem.getAttributeNode( name );\n\t\t\tif ( ret && ret.specified ) {\n\t\t\t\treturn ret.value;\n\t\t\t}\n\t\t},\n\t\tset: nodeHook.set\n\t};\n\n\t// Set contenteditable to false on removals(#10429)\n\t// Setting to empty string throws an error as an invalid value\n\tjQuery.attrHooks.contenteditable = {\n\t\tset: function( elem, value, name ) {\n\t\t\tnodeHook.set( elem, value === \"\" ? false : value, name );\n\t\t}\n\t};\n\n\t// Set width and height to auto instead of 0 on empty string( Bug #8150 )\n\t// This is for removals\n\tjQuery.each([ \"width\", \"height\" ], function( i, name ) {\n\t\tjQuery.attrHooks[ name ] = {\n\t\t\tset: function( elem, value ) {\n\t\t\t\tif ( value === \"\" ) {\n\t\t\t\t\telem.setAttribute( name, \"auto\" );\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t});\n}\n\nif ( !support.style ) {\n\tjQuery.attrHooks.style = {\n\t\tget: function( elem ) {\n\t\t\t// Return undefined in the case of empty string\n\t\t\t// Note: IE uppercases css property names, but if we were to .toLowerCase()\n\t\t\t// .cssText, that would destroy case senstitivity in URL's, like in \"background\"\n\t\t\treturn elem.style.cssText || undefined;\n\t\t},\n\t\tset: function( elem, value ) {\n\t\t\treturn ( elem.style.cssText = value + \"\" );\n\t\t}\n\t};\n}\n\n\n\n\nvar rfocusable = /^(?:input|select|textarea|button|object)$/i,\n\trclickable = /^(?:a|area)$/i;\n\njQuery.fn.extend({\n\tprop: function( name, value ) {\n\t\treturn access( this, jQuery.prop, name, value, arguments.length > 1 );\n\t},\n\n\tremoveProp: function( name ) {\n\t\tname = jQuery.propFix[ name ] || name;\n\t\treturn this.each(function() {\n\t\t\t// try/catch handles cases where IE balks (such as removing a property on window)\n\t\t\ttry {\n\t\t\t\tthis[ name ] = undefined;\n\t\t\t\tdelete this[ name ];\n\t\t\t} catch( e ) {}\n\t\t});\n\t}\n});\n\njQuery.extend({\n\tpropFix: {\n\t\t\"for\": \"htmlFor\",\n\t\t\"class\": \"className\"\n\t},\n\n\tprop: function( elem, name, value ) {\n\t\tvar ret, hooks, notxml,\n\t\t\tnType = elem.nodeType;\n\n\t\t// don't get/set properties on text, comment and attribute nodes\n\t\tif ( !elem || nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\tnotxml = nType !== 1 || !jQuery.isXMLDoc( elem );\n\n\t\tif ( notxml ) {\n\t\t\t// Fix name and attach hooks\n\t\t\tname = jQuery.propFix[ name ] || name;\n\t\t\thooks = jQuery.propHooks[ name ];\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\t\t\treturn hooks && \"set\" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ?\n\t\t\t\tret :\n\t\t\t\t( elem[ name ] = value );\n\n\t\t} else {\n\t\t\treturn hooks && \"get\" in hooks && (ret = hooks.get( elem, name )) !== null ?\n\t\t\t\tret :\n\t\t\t\telem[ name ];\n\t\t}\n\t},\n\n\tpropHooks: {\n\t\ttabIndex: {\n\t\t\tget: function( elem ) {\n\t\t\t\t// elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set\n\t\t\t\t// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/\n\t\t\t\t// Use proper attribute retrieval(#12072)\n\t\t\t\tvar tabindex = jQuery.find.attr( elem, \"tabindex\" );\n\n\t\t\t\treturn tabindex ?\n\t\t\t\t\tparseInt( tabindex, 10 ) :\n\t\t\t\t\trfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName ) && elem.href ?\n\t\t\t\t\t\t0 :\n\t\t\t\t\t\t-1;\n\t\t\t}\n\t\t}\n\t}\n});\n\n// Some attributes require a special call on IE\n// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\nif ( !support.hrefNormalized ) {\n\t// href/src property should get the full normalized URL (#10299/#12915)\n\tjQuery.each([ \"href\", \"src\" ], function( i, name ) {\n\t\tjQuery.propHooks[ name ] = {\n\t\t\tget: function( elem ) {\n\t\t\t\treturn elem.getAttribute( name, 4 );\n\t\t\t}\n\t\t};\n\t});\n}\n\n// Support: Safari, IE9+\n// mis-reports the default selected property of an option\n// Accessing the parent's selectedIndex property fixes it\nif ( !support.optSelected ) {\n\tjQuery.propHooks.selected = {\n\t\tget: function( elem ) {\n\t\t\tvar parent = elem.parentNode;\n\n\t\t\tif ( parent ) {\n\t\t\t\tparent.selectedIndex;\n\n\t\t\t\t// Make sure that it also works with optgroups, see #5701\n\t\t\t\tif ( parent.parentNode ) {\n\t\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t};\n}\n\njQuery.each([\n\t\"tabIndex\",\n\t\"readOnly\",\n\t\"maxLength\",\n\t\"cellSpacing\",\n\t\"cellPadding\",\n\t\"rowSpan\",\n\t\"colSpan\",\n\t\"useMap\",\n\t\"frameBorder\",\n\t\"contentEditable\"\n], function() {\n\tjQuery.propFix[ this.toLowerCase() ] = this;\n});\n\n// IE6/7 call enctype encoding\nif ( !support.enctype ) {\n\tjQuery.propFix.enctype = \"encoding\";\n}\n\n\n\n\nvar rclass = /[\\t\\r\\n\\f]/g;\n\njQuery.fn.extend({\n\taddClass: function( value ) {\n\t\tvar classes, elem, cur, clazz, j, finalValue,\n\t\t\ti = 0,\n\t\t\tlen = this.length,\n\t\t\tproceed = typeof value === \"string\" && value;\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each(function( j ) {\n\t\t\t\tjQuery( this ).addClass( value.call( this, j, this.className ) );\n\t\t\t});\n\t\t}\n\n\t\tif ( proceed ) {\n\t\t\t// The disjunction here is for better compressibility (see removeClass)\n\t\t\tclasses = ( value || \"\" ).match( rnotwhite ) || [];\n\n\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\telem = this[ i ];\n\t\t\t\tcur = elem.nodeType === 1 && ( elem.className ?\n\t\t\t\t\t( \" \" + elem.className + \" \" ).replace( rclass, \" \" ) :\n\t\t\t\t\t\" \"\n\t\t\t\t);\n\n\t\t\t\tif ( cur ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( (clazz = classes[j++]) ) {\n\t\t\t\t\t\tif ( cur.indexOf( \" \" + clazz + \" \" ) < 0 ) {\n\t\t\t\t\t\t\tcur += clazz + \" \";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// only assign if different to avoid unneeded rendering.\n\t\t\t\t\tfinalValue = jQuery.trim( cur );\n\t\t\t\t\tif ( elem.className !== finalValue ) {\n\t\t\t\t\t\telem.className = finalValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tremoveClass: function( value ) {\n\t\tvar classes, elem, cur, clazz, j, finalValue,\n\t\t\ti = 0,\n\t\t\tlen = this.length,\n\t\t\tproceed = arguments.length === 0 || typeof value === \"string\" && value;\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each(function( j ) {\n\t\t\t\tjQuery( this ).removeClass( value.call( this, j, this.className ) );\n\t\t\t});\n\t\t}\n\t\tif ( proceed ) {\n\t\t\tclasses = ( value || \"\" ).match( rnotwhite ) || [];\n\n\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\telem = this[ i ];\n\t\t\t\t// This expression is here for better compressibility (see addClass)\n\t\t\t\tcur = elem.nodeType === 1 && ( elem.className ?\n\t\t\t\t\t( \" \" + elem.className + \" \" ).replace( rclass, \" \" ) :\n\t\t\t\t\t\"\"\n\t\t\t\t);\n\n\t\t\t\tif ( cur ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( (clazz = classes[j++]) ) {\n\t\t\t\t\t\t// Remove *all* instances\n\t\t\t\t\t\twhile ( cur.indexOf( \" \" + clazz + \" \" ) >= 0 ) {\n\t\t\t\t\t\t\tcur = cur.replace( \" \" + clazz + \" \", \" \" );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// only assign if different to avoid unneeded rendering.\n\t\t\t\t\tfinalValue = value ? jQuery.trim( cur ) : \"\";\n\t\t\t\t\tif ( elem.className !== finalValue ) {\n\t\t\t\t\t\telem.className = finalValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\ttoggleClass: function( value, stateVal ) {\n\t\tvar type = typeof value;\n\n\t\tif ( typeof stateVal === \"boolean\" && type === \"string\" ) {\n\t\t\treturn stateVal ? this.addClass( value ) : this.removeClass( value );\n\t\t}\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each(function( i ) {\n\t\t\t\tjQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );\n\t\t\t});\n\t\t}\n\n\t\treturn this.each(function() {\n\t\t\tif ( type === \"string\" ) {\n\t\t\t\t// toggle individual class names\n\t\t\t\tvar className,\n\t\t\t\t\ti = 0,\n\t\t\t\t\tself = jQuery( this ),\n\t\t\t\t\tclassNames = value.match( rnotwhite ) || [];\n\n\t\t\t\twhile ( (className = classNames[ i++ ]) ) {\n\t\t\t\t\t// check each className given, space separated list\n\t\t\t\t\tif ( self.hasClass( className ) ) {\n\t\t\t\t\t\tself.removeClass( className );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.addClass( className );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// Toggle whole class name\n\t\t\t} else if ( type === strundefined || type === \"boolean\" ) {\n\t\t\t\tif ( this.className ) {\n\t\t\t\t\t// store className if set\n\t\t\t\t\tjQuery._data( this, \"__className__\", this.className );\n\t\t\t\t}\n\n\t\t\t\t// If the element has a class name or if we're passed \"false\",\n\t\t\t\t// then remove the whole classname (if there was one, the above saved it).\n\t\t\t\t// Otherwise bring back whatever was previously saved (if anything),\n\t\t\t\t// falling back to the empty string if nothing was stored.\n\t\t\t\tthis.className = this.className || value === false ? \"\" : jQuery._data( this, \"__className__\" ) || \"\";\n\t\t\t}\n\t\t});\n\t},\n\n\thasClass: function( selector ) {\n\t\tvar className = \" \" + selector + \" \",\n\t\t\ti = 0,\n\t\t\tl = this.length;\n\t\tfor ( ; i < l; i++ ) {\n\t\t\tif ( this[i].nodeType === 1 && (\" \" + this[i].className + \" \").replace(rclass, \" \").indexOf( className ) >= 0 ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n});\n\n\n\n\n// Return jQuery for attributes-only inclusion\n\n\njQuery.each( (\"blur focus focusin focusout load resize scroll unload click dblclick \" +\n\t\"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" +\n\t\"change select submit keydown keypress keyup error contextmenu\").split(\" \"), function( i, name ) {\n\n\t// Handle event binding\n\tjQuery.fn[ name ] = function( data, fn ) {\n\t\treturn arguments.length > 0 ?\n\t\t\tthis.on( name, null, data, fn ) :\n\t\t\tthis.trigger( name );\n\t};\n});\n\njQuery.fn.extend({\n\thover: function( fnOver, fnOut ) {\n\t\treturn this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );\n\t},\n\n\tbind: function( types, data, fn ) {\n\t\treturn this.on( types, null, data, fn );\n\t},\n\tunbind: function( types, fn ) {\n\t\treturn this.off( types, null, fn );\n\t},\n\n\tdelegate: function( selector, types, data, fn ) {\n\t\treturn this.on( types, selector, data, fn );\n\t},\n\tundelegate: function( selector, types, fn ) {\n\t\t// ( namespace ) or ( selector, types [, fn] )\n\t\treturn arguments.length === 1 ? this.off( selector, \"**\" ) : this.off( types, selector || \"**\", fn );\n\t}\n});\n\n\nvar nonce = jQuery.now();\n\nvar rquery = (/\\?/);\n\n\n\nvar rvalidtokens = /(,)|(\\[|{)|(}|])|\"(?:[^\"\\\\\\r\\n]|\\\\[\"\\\\\\/bfnrt]|\\\\u[\\da-fA-F]{4})*\"\\s*:?|true|false|null|-?(?!0\\d)\\d+(?:\\.\\d+|)(?:[eE][+-]?\\d+|)/g;\n\njQuery.parseJSON = function( data ) {\n\t// Attempt to parse using the native JSON parser first\n\tif ( window.JSON && window.JSON.parse ) {\n\t\t// Support: Android 2.3\n\t\t// Workaround failure to string-cast null input\n\t\treturn window.JSON.parse( data + \"\" );\n\t}\n\n\tvar requireNonComma,\n\t\tdepth = null,\n\t\tstr = jQuery.trim( data + \"\" );\n\n\t// Guard against invalid (and possibly dangerous) input by ensuring that nothing remains\n\t// after removing valid tokens\n\treturn str && !jQuery.trim( str.replace( rvalidtokens, function( token, comma, open, close ) {\n\n\t\t// Force termination if we see a misplaced comma\n\t\tif ( requireNonComma && comma ) {\n\t\t\tdepth = 0;\n\t\t}\n\n\t\t// Perform no more replacements after returning to outermost depth\n\t\tif ( depth === 0 ) {\n\t\t\treturn token;\n\t\t}\n\n\t\t// Commas must not follow \"[\", \"{\", or \",\"\n\t\trequireNonComma = open || comma;\n\n\t\t// Determine new depth\n\t\t// array/object open (\"[\" or \"{\"): depth += true - false (increment)\n\t\t// array/object close (\"]\" or \"}\"): depth += false - true (decrement)\n\t\t// other cases (\",\" or primitive): depth += true - true (numeric cast)\n\t\tdepth += !close - !open;\n\n\t\t// Remove this token\n\t\treturn \"\";\n\t}) ) ?\n\t\t( Function( \"return \" + str ) )() :\n\t\tjQuery.error( \"Invalid JSON: \" + data );\n};\n\n\n// Cross-browser xml parsing\njQuery.parseXML = function( data ) {\n\tvar xml, tmp;\n\tif ( !data || typeof data !== \"string\" ) {\n\t\treturn null;\n\t}\n\ttry {\n\t\tif ( window.DOMParser ) { // Standard\n\t\t\ttmp = new DOMParser();\n\t\t\txml = tmp.parseFromString( data, \"text/xml\" );\n\t\t} else { // IE\n\t\t\txml = new ActiveXObject( \"Microsoft.XMLDOM\" );\n\t\t\txml.async = \"false\";\n\t\t\txml.loadXML( data );\n\t\t}\n\t} catch( e ) {\n\t\txml = undefined;\n\t}\n\tif ( !xml || !xml.documentElement || xml.getElementsByTagName( \"parsererror\" ).length ) {\n\t\tjQuery.error( \"Invalid XML: \" + data );\n\t}\n\treturn xml;\n};\n\n\nvar\n\t// Document location\n\tajaxLocParts,\n\tajaxLocation,\n\n\trhash = /#.*$/,\n\trts = /([?&])_=[^&]*/,\n\trheaders = /^(.*?):[ \\t]*([^\\r\\n]*)\\r?$/mg, // IE leaves an \\r character at EOL\n\t// #7653, #8125, #8152: local protocol detection\n\trlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n\trnoContent = /^(?:GET|HEAD)$/,\n\trprotocol = /^\\/\\//,\n\trurl = /^([\\w.+-]+:)(?:\\/\\/(?:[^\\/?#]*@|)([^\\/?#:]*)(?::(\\d+)|)|)/,\n\n\t/* Prefilters\n\t * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n\t * 2) These are called:\n\t *    - BEFORE asking for a transport\n\t *    - AFTER param serialization (s.data is a string if s.processData is true)\n\t * 3) key is the dataType\n\t * 4) the catchall symbol \"*\" can be used\n\t * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\n\t */\n\tprefilters = {},\n\n\t/* Transports bindings\n\t * 1) key is the dataType\n\t * 2) the catchall symbol \"*\" can be used\n\t * 3) selection will start with transport dataType and THEN go to \"*\" if needed\n\t */\n\ttransports = {},\n\n\t// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\n\tallTypes = \"*/\".concat(\"*\");\n\n// #8138, IE may throw an exception when accessing\n// a field from window.location if document.domain has been set\ntry {\n\tajaxLocation = location.href;\n} catch( e ) {\n\t// Use the href attribute of an A element\n\t// since IE will modify it given document.location\n\tajaxLocation = document.createElement( \"a\" );\n\tajaxLocation.href = \"\";\n\tajaxLocation = ajaxLocation.href;\n}\n\n// Segment location into parts\najaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];\n\n// Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\nfunction addToPrefiltersOrTransports( structure ) {\n\n\t// dataTypeExpression is optional and defaults to \"*\"\n\treturn function( dataTypeExpression, func ) {\n\n\t\tif ( typeof dataTypeExpression !== \"string\" ) {\n\t\t\tfunc = dataTypeExpression;\n\t\t\tdataTypeExpression = \"*\";\n\t\t}\n\n\t\tvar dataType,\n\t\t\ti = 0,\n\t\t\tdataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];\n\n\t\tif ( jQuery.isFunction( func ) ) {\n\t\t\t// For each dataType in the dataTypeExpression\n\t\t\twhile ( (dataType = dataTypes[i++]) ) {\n\t\t\t\t// Prepend if requested\n\t\t\t\tif ( dataType.charAt( 0 ) === \"+\" ) {\n\t\t\t\t\tdataType = dataType.slice( 1 ) || \"*\";\n\t\t\t\t\t(structure[ dataType ] = structure[ dataType ] || []).unshift( func );\n\n\t\t\t\t// Otherwise append\n\t\t\t\t} else {\n\t\t\t\t\t(structure[ dataType ] = structure[ dataType ] || []).push( func );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\n// Base inspection function for prefilters and transports\nfunction inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {\n\n\tvar inspected = {},\n\t\tseekingTransport = ( structure === transports );\n\n\tfunction inspect( dataType ) {\n\t\tvar selected;\n\t\tinspected[ dataType ] = true;\n\t\tjQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {\n\t\t\tvar dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );\n\t\t\tif ( typeof dataTypeOrTransport === \"string\" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {\n\t\t\t\toptions.dataTypes.unshift( dataTypeOrTransport );\n\t\t\t\tinspect( dataTypeOrTransport );\n\t\t\t\treturn false;\n\t\t\t} else if ( seekingTransport ) {\n\t\t\t\treturn !( selected = dataTypeOrTransport );\n\t\t\t}\n\t\t});\n\t\treturn selected;\n\t}\n\n\treturn inspect( options.dataTypes[ 0 ] ) || !inspected[ \"*\" ] && inspect( \"*\" );\n}\n\n// A special extend for ajax options\n// that takes \"flat\" options (not to be deep extended)\n// Fixes #9887\nfunction ajaxExtend( target, src ) {\n\tvar deep, key,\n\t\tflatOptions = jQuery.ajaxSettings.flatOptions || {};\n\n\tfor ( key in src ) {\n\t\tif ( src[ key ] !== undefined ) {\n\t\t\t( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];\n\t\t}\n\t}\n\tif ( deep ) {\n\t\tjQuery.extend( true, target, deep );\n\t}\n\n\treturn target;\n}\n\n/* Handles responses to an ajax request:\n * - finds the right dataType (mediates between content-type and expected dataType)\n * - returns the corresponding response\n */\nfunction ajaxHandleResponses( s, jqXHR, responses ) {\n\tvar firstDataType, ct, finalDataType, type,\n\t\tcontents = s.contents,\n\t\tdataTypes = s.dataTypes;\n\n\t// Remove auto dataType and get content-type in the process\n\twhile ( dataTypes[ 0 ] === \"*\" ) {\n\t\tdataTypes.shift();\n\t\tif ( ct === undefined ) {\n\t\t\tct = s.mimeType || jqXHR.getResponseHeader(\"Content-Type\");\n\t\t}\n\t}\n\n\t// Check if we're dealing with a known content-type\n\tif ( ct ) {\n\t\tfor ( type in contents ) {\n\t\t\tif ( contents[ type ] && contents[ type ].test( ct ) ) {\n\t\t\t\tdataTypes.unshift( type );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Check to see if we have a response for the expected dataType\n\tif ( dataTypes[ 0 ] in responses ) {\n\t\tfinalDataType = dataTypes[ 0 ];\n\t} else {\n\t\t// Try convertible dataTypes\n\t\tfor ( type in responses ) {\n\t\t\tif ( !dataTypes[ 0 ] || s.converters[ type + \" \" + dataTypes[0] ] ) {\n\t\t\t\tfinalDataType = type;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( !firstDataType ) {\n\t\t\t\tfirstDataType = type;\n\t\t\t}\n\t\t}\n\t\t// Or just use first one\n\t\tfinalDataType = finalDataType || firstDataType;\n\t}\n\n\t// If we found a dataType\n\t// We add the dataType to the list if needed\n\t// and return the corresponding response\n\tif ( finalDataType ) {\n\t\tif ( finalDataType !== dataTypes[ 0 ] ) {\n\t\t\tdataTypes.unshift( finalDataType );\n\t\t}\n\t\treturn responses[ finalDataType ];\n\t}\n}\n\n/* Chain conversions given the request and the original response\n * Also sets the responseXXX fields on the jqXHR instance\n */\nfunction ajaxConvert( s, response, jqXHR, isSuccess ) {\n\tvar conv2, current, conv, tmp, prev,\n\t\tconverters = {},\n\t\t// Work with a copy of dataTypes in case we need to modify it for conversion\n\t\tdataTypes = s.dataTypes.slice();\n\n\t// Create converters map with lowercased keys\n\tif ( dataTypes[ 1 ] ) {\n\t\tfor ( conv in s.converters ) {\n\t\t\tconverters[ conv.toLowerCase() ] = s.converters[ conv ];\n\t\t}\n\t}\n\n\tcurrent = dataTypes.shift();\n\n\t// Convert to each sequential dataType\n\twhile ( current ) {\n\n\t\tif ( s.responseFields[ current ] ) {\n\t\t\tjqXHR[ s.responseFields[ current ] ] = response;\n\t\t}\n\n\t\t// Apply the dataFilter if provided\n\t\tif ( !prev && isSuccess && s.dataFilter ) {\n\t\t\tresponse = s.dataFilter( response, s.dataType );\n\t\t}\n\n\t\tprev = current;\n\t\tcurrent = dataTypes.shift();\n\n\t\tif ( current ) {\n\n\t\t\t// There's only work to do if current dataType is non-auto\n\t\t\tif ( current === \"*\" ) {\n\n\t\t\t\tcurrent = prev;\n\n\t\t\t// Convert response if prev dataType is non-auto and differs from current\n\t\t\t} else if ( prev !== \"*\" && prev !== current ) {\n\n\t\t\t\t// Seek a direct converter\n\t\t\t\tconv = converters[ prev + \" \" + current ] || converters[ \"* \" + current ];\n\n\t\t\t\t// If none found, seek a pair\n\t\t\t\tif ( !conv ) {\n\t\t\t\t\tfor ( conv2 in converters ) {\n\n\t\t\t\t\t\t// If conv2 outputs current\n\t\t\t\t\t\ttmp = conv2.split( \" \" );\n\t\t\t\t\t\tif ( tmp[ 1 ] === current ) {\n\n\t\t\t\t\t\t\t// If prev can be converted to accepted input\n\t\t\t\t\t\t\tconv = converters[ prev + \" \" + tmp[ 0 ] ] ||\n\t\t\t\t\t\t\t\tconverters[ \"* \" + tmp[ 0 ] ];\n\t\t\t\t\t\t\tif ( conv ) {\n\t\t\t\t\t\t\t\t// Condense equivalence converters\n\t\t\t\t\t\t\t\tif ( conv === true ) {\n\t\t\t\t\t\t\t\t\tconv = converters[ conv2 ];\n\n\t\t\t\t\t\t\t\t// Otherwise, insert the intermediate dataType\n\t\t\t\t\t\t\t\t} else if ( converters[ conv2 ] !== true ) {\n\t\t\t\t\t\t\t\t\tcurrent = tmp[ 0 ];\n\t\t\t\t\t\t\t\t\tdataTypes.unshift( tmp[ 1 ] );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Apply converter (if not an equivalence)\n\t\t\t\tif ( conv !== true ) {\n\n\t\t\t\t\t// Unless errors are allowed to bubble, catch and return them\n\t\t\t\t\tif ( conv && s[ \"throws\" ] ) {\n\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t\t} catch ( e ) {\n\t\t\t\t\t\t\treturn { state: \"parsererror\", error: conv ? e : \"No conversion from \" + prev + \" to \" + current };\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn { state: \"success\", data: response };\n}\n\njQuery.extend({\n\n\t// Counter for holding the number of active queries\n\tactive: 0,\n\n\t// Last-Modified header cache for next request\n\tlastModified: {},\n\tetag: {},\n\n\tajaxSettings: {\n\t\turl: ajaxLocation,\n\t\ttype: \"GET\",\n\t\tisLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),\n\t\tglobal: true,\n\t\tprocessData: true,\n\t\tasync: true,\n\t\tcontentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\n\t\t/*\n\t\ttimeout: 0,\n\t\tdata: null,\n\t\tdataType: null,\n\t\tusername: null,\n\t\tpassword: null,\n\t\tcache: null,\n\t\tthrows: false,\n\t\ttraditional: false,\n\t\theaders: {},\n\t\t*/\n\n\t\taccepts: {\n\t\t\t\"*\": allTypes,\n\t\t\ttext: \"text/plain\",\n\t\t\thtml: \"text/html\",\n\t\t\txml: \"application/xml, text/xml\",\n\t\t\tjson: \"application/json, text/javascript\"\n\t\t},\n\n\t\tcontents: {\n\t\t\txml: /xml/,\n\t\t\thtml: /html/,\n\t\t\tjson: /json/\n\t\t},\n\n\t\tresponseFields: {\n\t\t\txml: \"responseXML\",\n\t\t\ttext: \"responseText\",\n\t\t\tjson: \"responseJSON\"\n\t\t},\n\n\t\t// Data converters\n\t\t// Keys separate source (or catchall \"*\") and destination types with a single space\n\t\tconverters: {\n\n\t\t\t// Convert anything to text\n\t\t\t\"* text\": String,\n\n\t\t\t// Text to html (true = no transformation)\n\t\t\t\"text html\": true,\n\n\t\t\t// Evaluate text as a json expression\n\t\t\t\"text json\": jQuery.parseJSON,\n\n\t\t\t// Parse text as xml\n\t\t\t\"text xml\": jQuery.parseXML\n\t\t},\n\n\t\t// For options that shouldn't be deep extended:\n\t\t// you can add your own custom options here if\n\t\t// and when you create one that shouldn't be\n\t\t// deep extended (see ajaxExtend)\n\t\tflatOptions: {\n\t\t\turl: true,\n\t\t\tcontext: true\n\t\t}\n\t},\n\n\t// Creates a full fledged settings object into target\n\t// with both ajaxSettings and settings fields.\n\t// If target is omitted, writes into ajaxSettings.\n\tajaxSetup: function( target, settings ) {\n\t\treturn settings ?\n\n\t\t\t// Building a settings object\n\t\t\tajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :\n\n\t\t\t// Extending ajaxSettings\n\t\t\tajaxExtend( jQuery.ajaxSettings, target );\n\t},\n\n\tajaxPrefilter: addToPrefiltersOrTransports( prefilters ),\n\tajaxTransport: addToPrefiltersOrTransports( transports ),\n\n\t// Main method\n\tajax: function( url, options ) {\n\n\t\t// If url is an object, simulate pre-1.5 signature\n\t\tif ( typeof url === \"object\" ) {\n\t\t\toptions = url;\n\t\t\turl = undefined;\n\t\t}\n\n\t\t// Force options to be an object\n\t\toptions = options || {};\n\n\t\tvar // Cross-domain detection vars\n\t\t\tparts,\n\t\t\t// Loop variable\n\t\t\ti,\n\t\t\t// URL without anti-cache param\n\t\t\tcacheURL,\n\t\t\t// Response headers as string\n\t\t\tresponseHeadersString,\n\t\t\t// timeout handle\n\t\t\ttimeoutTimer,\n\n\t\t\t// To know if global events are to be dispatched\n\t\t\tfireGlobals,\n\n\t\t\ttransport,\n\t\t\t// Response headers\n\t\t\tresponseHeaders,\n\t\t\t// Create the final options object\n\t\t\ts = jQuery.ajaxSetup( {}, options ),\n\t\t\t// Callbacks context\n\t\t\tcallbackContext = s.context || s,\n\t\t\t// Context for global events is callbackContext if it is a DOM node or jQuery collection\n\t\t\tglobalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?\n\t\t\t\tjQuery( callbackContext ) :\n\t\t\t\tjQuery.event,\n\t\t\t// Deferreds\n\t\t\tdeferred = jQuery.Deferred(),\n\t\t\tcompleteDeferred = jQuery.Callbacks(\"once memory\"),\n\t\t\t// Status-dependent callbacks\n\t\t\tstatusCode = s.statusCode || {},\n\t\t\t// Headers (they are sent all at once)\n\t\t\trequestHeaders = {},\n\t\t\trequestHeadersNames = {},\n\t\t\t// The jqXHR state\n\t\t\tstate = 0,\n\t\t\t// Default abort message\n\t\t\tstrAbort = \"canceled\",\n\t\t\t// Fake xhr\n\t\t\tjqXHR = {\n\t\t\t\treadyState: 0,\n\n\t\t\t\t// Builds headers hashtable if needed\n\t\t\t\tgetResponseHeader: function( key ) {\n\t\t\t\t\tvar match;\n\t\t\t\t\tif ( state === 2 ) {\n\t\t\t\t\t\tif ( !responseHeaders ) {\n\t\t\t\t\t\t\tresponseHeaders = {};\n\t\t\t\t\t\t\twhile ( (match = rheaders.exec( responseHeadersString )) ) {\n\t\t\t\t\t\t\t\tresponseHeaders[ match[1].toLowerCase() ] = match[ 2 ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmatch = responseHeaders[ key.toLowerCase() ];\n\t\t\t\t\t}\n\t\t\t\t\treturn match == null ? null : match;\n\t\t\t\t},\n\n\t\t\t\t// Raw string\n\t\t\t\tgetAllResponseHeaders: function() {\n\t\t\t\t\treturn state === 2 ? responseHeadersString : null;\n\t\t\t\t},\n\n\t\t\t\t// Caches the header\n\t\t\t\tsetRequestHeader: function( name, value ) {\n\t\t\t\t\tvar lname = name.toLowerCase();\n\t\t\t\t\tif ( !state ) {\n\t\t\t\t\t\tname = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;\n\t\t\t\t\t\trequestHeaders[ name ] = value;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Overrides response content-type header\n\t\t\t\toverrideMimeType: function( type ) {\n\t\t\t\t\tif ( !state ) {\n\t\t\t\t\t\ts.mimeType = type;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Status-dependent callbacks\n\t\t\t\tstatusCode: function( map ) {\n\t\t\t\t\tvar code;\n\t\t\t\t\tif ( map ) {\n\t\t\t\t\t\tif ( state < 2 ) {\n\t\t\t\t\t\t\tfor ( code in map ) {\n\t\t\t\t\t\t\t\t// Lazy-add the new callback in a way that preserves old ones\n\t\t\t\t\t\t\t\tstatusCode[ code ] = [ statusCode[ code ], map[ code ] ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Execute the appropriate callbacks\n\t\t\t\t\t\t\tjqXHR.always( map[ jqXHR.status ] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Cancel the request\n\t\t\t\tabort: function( statusText ) {\n\t\t\t\t\tvar finalText = statusText || strAbort;\n\t\t\t\t\tif ( transport ) {\n\t\t\t\t\t\ttransport.abort( finalText );\n\t\t\t\t\t}\n\t\t\t\t\tdone( 0, finalText );\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t};\n\n\t\t// Attach deferreds\n\t\tdeferred.promise( jqXHR ).complete = completeDeferred.add;\n\t\tjqXHR.success = jqXHR.done;\n\t\tjqXHR.error = jqXHR.fail;\n\n\t\t// Remove hash character (#7531: and string promotion)\n\t\t// Add protocol if not provided (#5866: IE7 issue with protocol-less urls)\n\t\t// Handle falsy url in the settings object (#10093: consistency with old signature)\n\t\t// We also use the url parameter if available\n\t\ts.url = ( ( url || s.url || ajaxLocation ) + \"\" ).replace( rhash, \"\" ).replace( rprotocol, ajaxLocParts[ 1 ] + \"//\" );\n\n\t\t// Alias method option to type as per ticket #12004\n\t\ts.type = options.method || options.type || s.method || s.type;\n\n\t\t// Extract dataTypes list\n\t\ts.dataTypes = jQuery.trim( s.dataType || \"*\" ).toLowerCase().match( rnotwhite ) || [ \"\" ];\n\n\t\t// A cross-domain request is in order when we have a protocol:host:port mismatch\n\t\tif ( s.crossDomain == null ) {\n\t\t\tparts = rurl.exec( s.url.toLowerCase() );\n\t\t\ts.crossDomain = !!( parts &&\n\t\t\t\t( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||\n\t\t\t\t\t( parts[ 3 ] || ( parts[ 1 ] === \"http:\" ? \"80\" : \"443\" ) ) !==\n\t\t\t\t\t\t( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === \"http:\" ? \"80\" : \"443\" ) ) )\n\t\t\t);\n\t\t}\n\n\t\t// Convert data if not already a string\n\t\tif ( s.data && s.processData && typeof s.data !== \"string\" ) {\n\t\t\ts.data = jQuery.param( s.data, s.traditional );\n\t\t}\n\n\t\t// Apply prefilters\n\t\tinspectPrefiltersOrTransports( prefilters, s, options, jqXHR );\n\n\t\t// If request was aborted inside a prefilter, stop there\n\t\tif ( state === 2 ) {\n\t\t\treturn jqXHR;\n\t\t}\n\n\t\t// We can fire global events as of now if asked to\n\t\t// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)\n\t\tfireGlobals = jQuery.event && s.global;\n\n\t\t// Watch for a new set of requests\n\t\tif ( fireGlobals && jQuery.active++ === 0 ) {\n\t\t\tjQuery.event.trigger(\"ajaxStart\");\n\t\t}\n\n\t\t// Uppercase the type\n\t\ts.type = s.type.toUpperCase();\n\n\t\t// Determine if request has content\n\t\ts.hasContent = !rnoContent.test( s.type );\n\n\t\t// Save the URL in case we're toying with the If-Modified-Since\n\t\t// and/or If-None-Match header later on\n\t\tcacheURL = s.url;\n\n\t\t// More options handling for requests with no content\n\t\tif ( !s.hasContent ) {\n\n\t\t\t// If data is available, append data to url\n\t\t\tif ( s.data ) {\n\t\t\t\tcacheURL = ( s.url += ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + s.data );\n\t\t\t\t// #9682: remove data so that it's not used in an eventual retry\n\t\t\t\tdelete s.data;\n\t\t\t}\n\n\t\t\t// Add anti-cache in url if needed\n\t\t\tif ( s.cache === false ) {\n\t\t\t\ts.url = rts.test( cacheURL ) ?\n\n\t\t\t\t\t// If there is already a '_' parameter, set its value\n\t\t\t\t\tcacheURL.replace( rts, \"$1_=\" + nonce++ ) :\n\n\t\t\t\t\t// Otherwise add one to the end\n\t\t\t\t\tcacheURL + ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + \"_=\" + nonce++;\n\t\t\t}\n\t\t}\n\n\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\tif ( s.ifModified ) {\n\t\t\tif ( jQuery.lastModified[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( \"If-Modified-Since\", jQuery.lastModified[ cacheURL ] );\n\t\t\t}\n\t\t\tif ( jQuery.etag[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( \"If-None-Match\", jQuery.etag[ cacheURL ] );\n\t\t\t}\n\t\t}\n\n\t\t// Set the correct header, if data is being sent\n\t\tif ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {\n\t\t\tjqXHR.setRequestHeader( \"Content-Type\", s.contentType );\n\t\t}\n\n\t\t// Set the Accepts header for the server, depending on the dataType\n\t\tjqXHR.setRequestHeader(\n\t\t\t\"Accept\",\n\t\t\ts.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?\n\t\t\t\ts.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== \"*\" ? \", \" + allTypes + \"; q=0.01\" : \"\" ) :\n\t\t\t\ts.accepts[ \"*\" ]\n\t\t);\n\n\t\t// Check for headers option\n\t\tfor ( i in s.headers ) {\n\t\t\tjqXHR.setRequestHeader( i, s.headers[ i ] );\n\t\t}\n\n\t\t// Allow custom headers/mimetypes and early abort\n\t\tif ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {\n\t\t\t// Abort if not done already and return\n\t\t\treturn jqXHR.abort();\n\t\t}\n\n\t\t// aborting is no longer a cancellation\n\t\tstrAbort = \"abort\";\n\n\t\t// Install callbacks on deferreds\n\t\tfor ( i in { success: 1, error: 1, complete: 1 } ) {\n\t\t\tjqXHR[ i ]( s[ i ] );\n\t\t}\n\n\t\t// Get transport\n\t\ttransport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );\n\n\t\t// If no transport, we auto-abort\n\t\tif ( !transport ) {\n\t\t\tdone( -1, \"No Transport\" );\n\t\t} else {\n\t\t\tjqXHR.readyState = 1;\n\n\t\t\t// Send global event\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( \"ajaxSend\", [ jqXHR, s ] );\n\t\t\t}\n\t\t\t// Timeout\n\t\t\tif ( s.async && s.timeout > 0 ) {\n\t\t\t\ttimeoutTimer = setTimeout(function() {\n\t\t\t\t\tjqXHR.abort(\"timeout\");\n\t\t\t\t}, s.timeout );\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tstate = 1;\n\t\t\t\ttransport.send( requestHeaders, done );\n\t\t\t} catch ( e ) {\n\t\t\t\t// Propagate exception as error if not done\n\t\t\t\tif ( state < 2 ) {\n\t\t\t\t\tdone( -1, e );\n\t\t\t\t// Simply rethrow otherwise\n\t\t\t\t} else {\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Callback for when everything is done\n\t\tfunction done( status, nativeStatusText, responses, headers ) {\n\t\t\tvar isSuccess, success, error, response, modified,\n\t\t\t\tstatusText = nativeStatusText;\n\n\t\t\t// Called once\n\t\t\tif ( state === 2 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// State is \"done\" now\n\t\t\tstate = 2;\n\n\t\t\t// Clear timeout if it exists\n\t\t\tif ( timeoutTimer ) {\n\t\t\t\tclearTimeout( timeoutTimer );\n\t\t\t}\n\n\t\t\t// Dereference transport for early garbage collection\n\t\t\t// (no matter how long the jqXHR object will be used)\n\t\t\ttransport = undefined;\n\n\t\t\t// Cache response headers\n\t\t\tresponseHeadersString = headers || \"\";\n\n\t\t\t// Set readyState\n\t\t\tjqXHR.readyState = status > 0 ? 4 : 0;\n\n\t\t\t// Determine if successful\n\t\t\tisSuccess = status >= 200 && status < 300 || status === 304;\n\n\t\t\t// Get response data\n\t\t\tif ( responses ) {\n\t\t\t\tresponse = ajaxHandleResponses( s, jqXHR, responses );\n\t\t\t}\n\n\t\t\t// Convert no matter what (that way responseXXX fields are always set)\n\t\t\tresponse = ajaxConvert( s, response, jqXHR, isSuccess );\n\n\t\t\t// If successful, handle type chaining\n\t\t\tif ( isSuccess ) {\n\n\t\t\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\t\t\tif ( s.ifModified ) {\n\t\t\t\t\tmodified = jqXHR.getResponseHeader(\"Last-Modified\");\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.lastModified[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t\tmodified = jqXHR.getResponseHeader(\"etag\");\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.etag[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// if no content\n\t\t\t\tif ( status === 204 || s.type === \"HEAD\" ) {\n\t\t\t\t\tstatusText = \"nocontent\";\n\n\t\t\t\t// if not modified\n\t\t\t\t} else if ( status === 304 ) {\n\t\t\t\t\tstatusText = \"notmodified\";\n\n\t\t\t\t// If we have data, let's convert it\n\t\t\t\t} else {\n\t\t\t\t\tstatusText = response.state;\n\t\t\t\t\tsuccess = response.data;\n\t\t\t\t\terror = response.error;\n\t\t\t\t\tisSuccess = !error;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// We extract error from statusText\n\t\t\t\t// then normalize statusText and status for non-aborts\n\t\t\t\terror = statusText;\n\t\t\t\tif ( status || !statusText ) {\n\t\t\t\t\tstatusText = \"error\";\n\t\t\t\t\tif ( status < 0 ) {\n\t\t\t\t\t\tstatus = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set data for the fake xhr object\n\t\t\tjqXHR.status = status;\n\t\t\tjqXHR.statusText = ( nativeStatusText || statusText ) + \"\";\n\n\t\t\t// Success/Error\n\t\t\tif ( isSuccess ) {\n\t\t\t\tdeferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );\n\t\t\t} else {\n\t\t\t\tdeferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );\n\t\t\t}\n\n\t\t\t// Status-dependent callbacks\n\t\t\tjqXHR.statusCode( statusCode );\n\t\t\tstatusCode = undefined;\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( isSuccess ? \"ajaxSuccess\" : \"ajaxError\",\n\t\t\t\t\t[ jqXHR, s, isSuccess ? success : error ] );\n\t\t\t}\n\n\t\t\t// Complete\n\t\t\tcompleteDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( \"ajaxComplete\", [ jqXHR, s ] );\n\t\t\t\t// Handle the global AJAX counter\n\t\t\t\tif ( !( --jQuery.active ) ) {\n\t\t\t\t\tjQuery.event.trigger(\"ajaxStop\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn jqXHR;\n\t},\n\n\tgetJSON: function( url, data, callback ) {\n\t\treturn jQuery.get( url, data, callback, \"json\" );\n\t},\n\n\tgetScript: function( url, callback ) {\n\t\treturn jQuery.get( url, undefined, callback, \"script\" );\n\t}\n});\n\njQuery.each( [ \"get\", \"post\" ], function( i, method ) {\n\tjQuery[ method ] = function( url, data, callback, type ) {\n\t\t// shift arguments if data argument was omitted\n\t\tif ( jQuery.isFunction( data ) ) {\n\t\t\ttype = type || callback;\n\t\t\tcallback = data;\n\t\t\tdata = undefined;\n\t\t}\n\n\t\treturn jQuery.ajax({\n\t\t\turl: url,\n\t\t\ttype: method,\n\t\t\tdataType: type,\n\t\t\tdata: data,\n\t\t\tsuccess: callback\n\t\t});\n\t};\n});\n\n\njQuery._evalUrl = function( url ) {\n\treturn jQuery.ajax({\n\t\turl: url,\n\t\ttype: \"GET\",\n\t\tdataType: \"script\",\n\t\tasync: false,\n\t\tglobal: false,\n\t\t\"throws\": true\n\t});\n};\n\n\njQuery.fn.extend({\n\twrapAll: function( html ) {\n\t\tif ( jQuery.isFunction( html ) ) {\n\t\t\treturn this.each(function(i) {\n\t\t\t\tjQuery(this).wrapAll( html.call(this, i) );\n\t\t\t});\n\t\t}\n\n\t\tif ( this[0] ) {\n\t\t\t// The elements to wrap the target around\n\t\t\tvar wrap = jQuery( html, this[0].ownerDocument ).eq(0).clone(true);\n\n\t\t\tif ( this[0].parentNode ) {\n\t\t\t\twrap.insertBefore( this[0] );\n\t\t\t}\n\n\t\t\twrap.map(function() {\n\t\t\t\tvar elem = this;\n\n\t\t\t\twhile ( elem.firstChild && elem.firstChild.nodeType === 1 ) {\n\t\t\t\t\telem = elem.firstChild;\n\t\t\t\t}\n\n\t\t\t\treturn elem;\n\t\t\t}).append( this );\n\t\t}\n\n\t\treturn this;\n\t},\n\n\twrapInner: function( html ) {\n\t\tif ( jQuery.isFunction( html ) ) {\n\t\t\treturn this.each(function(i) {\n\t\t\t\tjQuery(this).wrapInner( html.call(this, i) );\n\t\t\t});\n\t\t}\n\n\t\treturn this.each(function() {\n\t\t\tvar self = jQuery( this ),\n\t\t\t\tcontents = self.contents();\n\n\t\t\tif ( contents.length ) {\n\t\t\t\tcontents.wrapAll( html );\n\n\t\t\t} else {\n\t\t\t\tself.append( html );\n\t\t\t}\n\t\t});\n\t},\n\n\twrap: function( html ) {\n\t\tvar isFunction = jQuery.isFunction( html );\n\n\t\treturn this.each(function(i) {\n\t\t\tjQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );\n\t\t});\n\t},\n\n\tunwrap: function() {\n\t\treturn this.parent().each(function() {\n\t\t\tif ( !jQuery.nodeName( this, \"body\" ) ) {\n\t\t\t\tjQuery( this ).replaceWith( this.childNodes );\n\t\t\t}\n\t\t}).end();\n\t}\n});\n\n\njQuery.expr.filters.hidden = function( elem ) {\n\t// Support: Opera <= 12.12\n\t// Opera reports offsetWidths and offsetHeights less than zero on some elements\n\treturn elem.offsetWidth <= 0 && elem.offsetHeight <= 0 ||\n\t\t(!support.reliableHiddenOffsets() &&\n\t\t\t((elem.style && elem.style.display) || jQuery.css( elem, \"display\" )) === \"none\");\n};\n\njQuery.expr.filters.visible = function( elem ) {\n\treturn !jQuery.expr.filters.hidden( elem );\n};\n\n\n\n\nvar r20 = /%20/g,\n\trbracket = /\\[\\]$/,\n\trCRLF = /\\r?\\n/g,\n\trsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\n\trsubmittable = /^(?:input|select|textarea|keygen)/i;\n\nfunction buildParams( prefix, obj, traditional, add ) {\n\tvar name;\n\n\tif ( jQuery.isArray( obj ) ) {\n\t\t// Serialize array item.\n\t\tjQuery.each( obj, function( i, v ) {\n\t\t\tif ( traditional || rbracket.test( prefix ) ) {\n\t\t\t\t// Treat each array item as a scalar.\n\t\t\t\tadd( prefix, v );\n\n\t\t\t} else {\n\t\t\t\t// Item is non-scalar (array or object), encode its numeric index.\n\t\t\t\tbuildParams( prefix + \"[\" + ( typeof v === \"object\" ? i : \"\" ) + \"]\", v, traditional, add );\n\t\t\t}\n\t\t});\n\n\t} else if ( !traditional && jQuery.type( obj ) === \"object\" ) {\n\t\t// Serialize object item.\n\t\tfor ( name in obj ) {\n\t\t\tbuildParams( prefix + \"[\" + name + \"]\", obj[ name ], traditional, add );\n\t\t}\n\n\t} else {\n\t\t// Serialize scalar item.\n\t\tadd( prefix, obj );\n\t}\n}\n\n// Serialize an array of form elements or a set of\n// key/values into a query string\njQuery.param = function( a, traditional ) {\n\tvar prefix,\n\t\ts = [],\n\t\tadd = function( key, value ) {\n\t\t\t// If value is a function, invoke it and return its value\n\t\t\tvalue = jQuery.isFunction( value ) ? value() : ( value == null ? \"\" : value );\n\t\t\ts[ s.length ] = encodeURIComponent( key ) + \"=\" + encodeURIComponent( value );\n\t\t};\n\n\t// Set traditional to true for jQuery <= 1.3.2 behavior.\n\tif ( traditional === undefined ) {\n\t\ttraditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;\n\t}\n\n\t// If an array was passed in, assume that it is an array of form elements.\n\tif ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {\n\t\t// Serialize the form elements\n\t\tjQuery.each( a, function() {\n\t\t\tadd( this.name, this.value );\n\t\t});\n\n\t} else {\n\t\t// If traditional, encode the \"old\" way (the way 1.3.2 or older\n\t\t// did it), otherwise encode params recursively.\n\t\tfor ( prefix in a ) {\n\t\t\tbuildParams( prefix, a[ prefix ], traditional, add );\n\t\t}\n\t}\n\n\t// Return the resulting serialization\n\treturn s.join( \"&\" ).replace( r20, \"+\" );\n};\n\njQuery.fn.extend({\n\tserialize: function() {\n\t\treturn jQuery.param( this.serializeArray() );\n\t},\n\tserializeArray: function() {\n\t\treturn this.map(function() {\n\t\t\t// Can add propHook for \"elements\" to filter or add form elements\n\t\t\tvar elements = jQuery.prop( this, \"elements\" );\n\t\t\treturn elements ? jQuery.makeArray( elements ) : this;\n\t\t})\n\t\t.filter(function() {\n\t\t\tvar type = this.type;\n\t\t\t// Use .is(\":disabled\") so that fieldset[disabled] works\n\t\t\treturn this.name && !jQuery( this ).is( \":disabled\" ) &&\n\t\t\t\trsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&\n\t\t\t\t( this.checked || !rcheckableType.test( type ) );\n\t\t})\n\t\t.map(function( i, elem ) {\n\t\t\tvar val = jQuery( this ).val();\n\n\t\t\treturn val == null ?\n\t\t\t\tnull :\n\t\t\t\tjQuery.isArray( val ) ?\n\t\t\t\t\tjQuery.map( val, function( val ) {\n\t\t\t\t\t\treturn { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t\t\t\t}) :\n\t\t\t\t\t{ name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t}).get();\n\t}\n});\n\n\n// Create the request object\n// (This is still attached to ajaxSettings for backward compatibility)\njQuery.ajaxSettings.xhr = window.ActiveXObject !== undefined ?\n\t// Support: IE6+\n\tfunction() {\n\n\t\t// XHR cannot access local files, always use ActiveX for that case\n\t\treturn !this.isLocal &&\n\n\t\t\t// Support: IE7-8\n\t\t\t// oldIE XHR does not support non-RFC2616 methods (#13240)\n\t\t\t// See http://msdn.microsoft.com/en-us/library/ie/ms536648(v=vs.85).aspx\n\t\t\t// and http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9\n\t\t\t// Although this check for six methods instead of eight\n\t\t\t// since IE also does not support \"trace\" and \"connect\"\n\t\t\t/^(get|post|head|put|delete|options)$/i.test( this.type ) &&\n\n\t\t\tcreateStandardXHR() || createActiveXHR();\n\t} :\n\t// For all other browsers, use the standard XMLHttpRequest object\n\tcreateStandardXHR;\n\nvar xhrId = 0,\n\txhrCallbacks = {},\n\txhrSupported = jQuery.ajaxSettings.xhr();\n\n// Support: IE<10\n// Open requests must be manually aborted on unload (#5280)\n// See https://support.microsoft.com/kb/2856746 for more info\nif ( window.attachEvent ) {\n\twindow.attachEvent( \"onunload\", function() {\n\t\tfor ( var key in xhrCallbacks ) {\n\t\t\txhrCallbacks[ key ]( undefined, true );\n\t\t}\n\t});\n}\n\n// Determine support properties\nsupport.cors = !!xhrSupported && ( \"withCredentials\" in xhrSupported );\nxhrSupported = support.ajax = !!xhrSupported;\n\n// Create transport if the browser can provide an xhr\nif ( xhrSupported ) {\n\n\tjQuery.ajaxTransport(function( options ) {\n\t\t// Cross domain only allowed if supported through XMLHttpRequest\n\t\tif ( !options.crossDomain || support.cors ) {\n\n\t\t\tvar callback;\n\n\t\t\treturn {\n\t\t\t\tsend: function( headers, complete ) {\n\t\t\t\t\tvar i,\n\t\t\t\t\t\txhr = options.xhr(),\n\t\t\t\t\t\tid = ++xhrId;\n\n\t\t\t\t\t// Open the socket\n\t\t\t\t\txhr.open( options.type, options.url, options.async, options.username, options.password );\n\n\t\t\t\t\t// Apply custom fields if provided\n\t\t\t\t\tif ( options.xhrFields ) {\n\t\t\t\t\t\tfor ( i in options.xhrFields ) {\n\t\t\t\t\t\t\txhr[ i ] = options.xhrFields[ i ];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Override mime type if needed\n\t\t\t\t\tif ( options.mimeType && xhr.overrideMimeType ) {\n\t\t\t\t\t\txhr.overrideMimeType( options.mimeType );\n\t\t\t\t\t}\n\n\t\t\t\t\t// X-Requested-With header\n\t\t\t\t\t// For cross-domain requests, seeing as conditions for a preflight are\n\t\t\t\t\t// akin to a jigsaw puzzle, we simply never set it to be sure.\n\t\t\t\t\t// (it can always be set on a per-request basis or even using ajaxSetup)\n\t\t\t\t\t// For same-domain requests, won't change header if already provided.\n\t\t\t\t\tif ( !options.crossDomain && !headers[\"X-Requested-With\"] ) {\n\t\t\t\t\t\theaders[\"X-Requested-With\"] = \"XMLHttpRequest\";\n\t\t\t\t\t}\n\n\t\t\t\t\t// Set headers\n\t\t\t\t\tfor ( i in headers ) {\n\t\t\t\t\t\t// Support: IE<9\n\t\t\t\t\t\t// IE's ActiveXObject throws a 'Type Mismatch' exception when setting\n\t\t\t\t\t\t// request header to a null-value.\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// To keep consistent with other XHR implementations, cast the value\n\t\t\t\t\t\t// to string and ignore `undefined`.\n\t\t\t\t\t\tif ( headers[ i ] !== undefined ) {\n\t\t\t\t\t\t\txhr.setRequestHeader( i, headers[ i ] + \"\" );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Do send the request\n\t\t\t\t\t// This may raise an exception which is actually\n\t\t\t\t\t// handled in jQuery.ajax (so no try/catch here)\n\t\t\t\t\txhr.send( ( options.hasContent && options.data ) || null );\n\n\t\t\t\t\t// Listener\n\t\t\t\t\tcallback = function( _, isAbort ) {\n\t\t\t\t\t\tvar status, statusText, responses;\n\n\t\t\t\t\t\t// Was never called and is aborted or complete\n\t\t\t\t\t\tif ( callback && ( isAbort || xhr.readyState === 4 ) ) {\n\t\t\t\t\t\t\t// Clean up\n\t\t\t\t\t\t\tdelete xhrCallbacks[ id ];\n\t\t\t\t\t\t\tcallback = undefined;\n\t\t\t\t\t\t\txhr.onreadystatechange = jQuery.noop;\n\n\t\t\t\t\t\t\t// Abort manually if needed\n\t\t\t\t\t\t\tif ( isAbort ) {\n\t\t\t\t\t\t\t\tif ( xhr.readyState !== 4 ) {\n\t\t\t\t\t\t\t\t\txhr.abort();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tresponses = {};\n\t\t\t\t\t\t\t\tstatus = xhr.status;\n\n\t\t\t\t\t\t\t\t// Support: IE<10\n\t\t\t\t\t\t\t\t// Accessing binary-data responseText throws an exception\n\t\t\t\t\t\t\t\t// (#11426)\n\t\t\t\t\t\t\t\tif ( typeof xhr.responseText === \"string\" ) {\n\t\t\t\t\t\t\t\t\tresponses.text = xhr.responseText;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// Firefox throws an exception when accessing\n\t\t\t\t\t\t\t\t// statusText for faulty cross-domain requests\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tstatusText = xhr.statusText;\n\t\t\t\t\t\t\t\t} catch( e ) {\n\t\t\t\t\t\t\t\t\t// We normalize with Webkit giving an empty statusText\n\t\t\t\t\t\t\t\t\tstatusText = \"\";\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// Filter status for non standard behaviors\n\n\t\t\t\t\t\t\t\t// If the request is local and we have data: assume a success\n\t\t\t\t\t\t\t\t// (success with no data won't get notified, that's the best we\n\t\t\t\t\t\t\t\t// can do given current implementations)\n\t\t\t\t\t\t\t\tif ( !status && options.isLocal && !options.crossDomain ) {\n\t\t\t\t\t\t\t\t\tstatus = responses.text ? 200 : 404;\n\t\t\t\t\t\t\t\t// IE - #1450: sometimes returns 1223 when it should be 204\n\t\t\t\t\t\t\t\t} else if ( status === 1223 ) {\n\t\t\t\t\t\t\t\t\tstatus = 204;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Call complete if needed\n\t\t\t\t\t\tif ( responses ) {\n\t\t\t\t\t\t\tcomplete( status, statusText, responses, xhr.getAllResponseHeaders() );\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\tif ( !options.async ) {\n\t\t\t\t\t\t// if we're in sync mode we fire the callback\n\t\t\t\t\t\tcallback();\n\t\t\t\t\t} else if ( xhr.readyState === 4 ) {\n\t\t\t\t\t\t// (IE6 & IE7) if it's in cache and has been\n\t\t\t\t\t\t// retrieved directly we need to fire the callback\n\t\t\t\t\t\tsetTimeout( callback );\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Add to the list of active xhr callbacks\n\t\t\t\t\t\txhr.onreadystatechange = xhrCallbacks[ id ] = callback;\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tabort: function() {\n\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\tcallback( undefined, true );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t});\n}\n\n// Functions to create xhrs\nfunction createStandardXHR() {\n\ttry {\n\t\treturn new window.XMLHttpRequest();\n\t} catch( e ) {}\n}\n\nfunction createActiveXHR() {\n\ttry {\n\t\treturn new window.ActiveXObject( \"Microsoft.XMLHTTP\" );\n\t} catch( e ) {}\n}\n\n\n\n\n// Install script dataType\njQuery.ajaxSetup({\n\taccepts: {\n\t\tscript: \"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript\"\n\t},\n\tcontents: {\n\t\tscript: /(?:java|ecma)script/\n\t},\n\tconverters: {\n\t\t\"text script\": function( text ) {\n\t\t\tjQuery.globalEval( text );\n\t\t\treturn text;\n\t\t}\n\t}\n});\n\n// Handle cache's special case and global\njQuery.ajaxPrefilter( \"script\", function( s ) {\n\tif ( s.cache === undefined ) {\n\t\ts.cache = false;\n\t}\n\tif ( s.crossDomain ) {\n\t\ts.type = \"GET\";\n\t\ts.global = false;\n\t}\n});\n\n// Bind script tag hack transport\njQuery.ajaxTransport( \"script\", function(s) {\n\n\t// This transport only deals with cross domain requests\n\tif ( s.crossDomain ) {\n\n\t\tvar script,\n\t\t\thead = document.head || jQuery(\"head\")[0] || document.documentElement;\n\n\t\treturn {\n\n\t\t\tsend: function( _, callback ) {\n\n\t\t\t\tscript = document.createElement(\"script\");\n\n\t\t\t\tscript.async = true;\n\n\t\t\t\tif ( s.scriptCharset ) {\n\t\t\t\t\tscript.charset = s.scriptCharset;\n\t\t\t\t}\n\n\t\t\t\tscript.src = s.url;\n\n\t\t\t\t// Attach handlers for all browsers\n\t\t\t\tscript.onload = script.onreadystatechange = function( _, isAbort ) {\n\n\t\t\t\t\tif ( isAbort || !script.readyState || /loaded|complete/.test( script.readyState ) ) {\n\n\t\t\t\t\t\t// Handle memory leak in IE\n\t\t\t\t\t\tscript.onload = script.onreadystatechange = null;\n\n\t\t\t\t\t\t// Remove the script\n\t\t\t\t\t\tif ( script.parentNode ) {\n\t\t\t\t\t\t\tscript.parentNode.removeChild( script );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Dereference the script\n\t\t\t\t\t\tscript = null;\n\n\t\t\t\t\t\t// Callback if not abort\n\t\t\t\t\t\tif ( !isAbort ) {\n\t\t\t\t\t\t\tcallback( 200, \"success\" );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\t// Circumvent IE6 bugs with base elements (#2709 and #4378) by prepending\n\t\t\t\t// Use native DOM manipulation to avoid our domManip AJAX trickery\n\t\t\t\thead.insertBefore( script, head.firstChild );\n\t\t\t},\n\n\t\t\tabort: function() {\n\t\t\t\tif ( script ) {\n\t\t\t\t\tscript.onload( undefined, true );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n});\n\n\n\n\nvar oldCallbacks = [],\n\trjsonp = /(=)\\?(?=&|$)|\\?\\?/;\n\n// Default jsonp settings\njQuery.ajaxSetup({\n\tjsonp: \"callback\",\n\tjsonpCallback: function() {\n\t\tvar callback = oldCallbacks.pop() || ( jQuery.expando + \"_\" + ( nonce++ ) );\n\t\tthis[ callback ] = true;\n\t\treturn callback;\n\t}\n});\n\n// Detect, normalize options and install callbacks for jsonp requests\njQuery.ajaxPrefilter( \"json jsonp\", function( s, originalSettings, jqXHR ) {\n\n\tvar callbackName, overwritten, responseContainer,\n\t\tjsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?\n\t\t\t\"url\" :\n\t\t\ttypeof s.data === \"string\" && !( s.contentType || \"\" ).indexOf(\"application/x-www-form-urlencoded\") && rjsonp.test( s.data ) && \"data\"\n\t\t);\n\n\t// Handle iff the expected data type is \"jsonp\" or we have a parameter to set\n\tif ( jsonProp || s.dataTypes[ 0 ] === \"jsonp\" ) {\n\n\t\t// Get callback name, remembering preexisting value associated with it\n\t\tcallbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?\n\t\t\ts.jsonpCallback() :\n\t\t\ts.jsonpCallback;\n\n\t\t// Insert callback into url or form data\n\t\tif ( jsonProp ) {\n\t\t\ts[ jsonProp ] = s[ jsonProp ].replace( rjsonp, \"$1\" + callbackName );\n\t\t} else if ( s.jsonp !== false ) {\n\t\t\ts.url += ( rquery.test( s.url ) ? \"&\" : \"?\" ) + s.jsonp + \"=\" + callbackName;\n\t\t}\n\n\t\t// Use data converter to retrieve json after script execution\n\t\ts.converters[\"script json\"] = function() {\n\t\t\tif ( !responseContainer ) {\n\t\t\t\tjQuery.error( callbackName + \" was not called\" );\n\t\t\t}\n\t\t\treturn responseContainer[ 0 ];\n\t\t};\n\n\t\t// force json dataType\n\t\ts.dataTypes[ 0 ] = \"json\";\n\n\t\t// Install callback\n\t\toverwritten = window[ callbackName ];\n\t\twindow[ callbackName ] = function() {\n\t\t\tresponseContainer = arguments;\n\t\t};\n\n\t\t// Clean-up function (fires after converters)\n\t\tjqXHR.always(function() {\n\t\t\t// Restore preexisting value\n\t\t\twindow[ callbackName ] = overwritten;\n\n\t\t\t// Save back as free\n\t\t\tif ( s[ callbackName ] ) {\n\t\t\t\t// make sure that re-using the options doesn't screw things around\n\t\t\t\ts.jsonpCallback = originalSettings.jsonpCallback;\n\n\t\t\t\t// save the callback name for future use\n\t\t\t\toldCallbacks.push( callbackName );\n\t\t\t}\n\n\t\t\t// Call if it was a function and we have a response\n\t\t\tif ( responseContainer && jQuery.isFunction( overwritten ) ) {\n\t\t\t\toverwritten( responseContainer[ 0 ] );\n\t\t\t}\n\n\t\t\tresponseContainer = overwritten = undefined;\n\t\t});\n\n\t\t// Delegate to script\n\t\treturn \"script\";\n\t}\n});\n\n\n\n\n// data: string of html\n// context (optional): If specified, the fragment will be created in this context, defaults to document\n// keepScripts (optional): If true, will include scripts passed in the html string\njQuery.parseHTML = function( data, context, keepScripts ) {\n\tif ( !data || typeof data !== \"string\" ) {\n\t\treturn null;\n\t}\n\tif ( typeof context === \"boolean\" ) {\n\t\tkeepScripts = context;\n\t\tcontext = false;\n\t}\n\tcontext = context || document;\n\n\tvar parsed = rsingleTag.exec( data ),\n\t\tscripts = !keepScripts && [];\n\n\t// Single tag\n\tif ( parsed ) {\n\t\treturn [ context.createElement( parsed[1] ) ];\n\t}\n\n\tparsed = jQuery.buildFragment( [ data ], context, scripts );\n\n\tif ( scripts && scripts.length ) {\n\t\tjQuery( scripts ).remove();\n\t}\n\n\treturn jQuery.merge( [], parsed.childNodes );\n};\n\n\n// Keep a copy of the old load method\nvar _load = jQuery.fn.load;\n\n/**\n * Load a url into a page\n */\njQuery.fn.load = function( url, params, callback ) {\n\tif ( typeof url !== \"string\" && _load ) {\n\t\treturn _load.apply( this, arguments );\n\t}\n\n\tvar selector, response, type,\n\t\tself = this,\n\t\toff = url.indexOf(\" \");\n\n\tif ( off >= 0 ) {\n\t\tselector = jQuery.trim( url.slice( off, url.length ) );\n\t\turl = url.slice( 0, off );\n\t}\n\n\t// If it's a function\n\tif ( jQuery.isFunction( params ) ) {\n\n\t\t// We assume that it's the callback\n\t\tcallback = params;\n\t\tparams = undefined;\n\n\t// Otherwise, build a param string\n\t} else if ( params && typeof params === \"object\" ) {\n\t\ttype = \"POST\";\n\t}\n\n\t// If we have elements to modify, make the request\n\tif ( self.length > 0 ) {\n\t\tjQuery.ajax({\n\t\t\turl: url,\n\n\t\t\t// if \"type\" variable is undefined, then \"GET\" method will be used\n\t\t\ttype: type,\n\t\t\tdataType: \"html\",\n\t\t\tdata: params\n\t\t}).done(function( responseText ) {\n\n\t\t\t// Save response for use in complete callback\n\t\t\tresponse = arguments;\n\n\t\t\tself.html( selector ?\n\n\t\t\t\t// If a selector was specified, locate the right elements in a dummy div\n\t\t\t\t// Exclude scripts to avoid IE 'Permission Denied' errors\n\t\t\t\tjQuery(\"<div>\").append( jQuery.parseHTML( responseText ) ).find( selector ) :\n\n\t\t\t\t// Otherwise use the full result\n\t\t\t\tresponseText );\n\n\t\t}).complete( callback && function( jqXHR, status ) {\n\t\t\tself.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );\n\t\t});\n\t}\n\n\treturn this;\n};\n\n\n\n\n// Attach a bunch of functions for handling common AJAX events\njQuery.each( [ \"ajaxStart\", \"ajaxStop\", \"ajaxComplete\", \"ajaxError\", \"ajaxSuccess\", \"ajaxSend\" ], function( i, type ) {\n\tjQuery.fn[ type ] = function( fn ) {\n\t\treturn this.on( type, fn );\n\t};\n});\n\n\n\n\njQuery.expr.filters.animated = function( elem ) {\n\treturn jQuery.grep(jQuery.timers, function( fn ) {\n\t\treturn elem === fn.elem;\n\t}).length;\n};\n\n\n\n\n\nvar docElem = window.document.documentElement;\n\n/**\n * Gets a window from an element\n */\nfunction getWindow( elem ) {\n\treturn jQuery.isWindow( elem ) ?\n\t\telem :\n\t\telem.nodeType === 9 ?\n\t\t\telem.defaultView || elem.parentWindow :\n\t\t\tfalse;\n}\n\njQuery.offset = {\n\tsetOffset: function( elem, options, i ) {\n\t\tvar curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,\n\t\t\tposition = jQuery.css( elem, \"position\" ),\n\t\t\tcurElem = jQuery( elem ),\n\t\t\tprops = {};\n\n\t\t// set position first, in-case top/left are set even on static elem\n\t\tif ( position === \"static\" ) {\n\t\t\telem.style.position = \"relative\";\n\t\t}\n\n\t\tcurOffset = curElem.offset();\n\t\tcurCSSTop = jQuery.css( elem, \"top\" );\n\t\tcurCSSLeft = jQuery.css( elem, \"left\" );\n\t\tcalculatePosition = ( position === \"absolute\" || position === \"fixed\" ) &&\n\t\t\tjQuery.inArray(\"auto\", [ curCSSTop, curCSSLeft ] ) > -1;\n\n\t\t// need to be able to calculate position if either top or left is auto and position is either absolute or fixed\n\t\tif ( calculatePosition ) {\n\t\t\tcurPosition = curElem.position();\n\t\t\tcurTop = curPosition.top;\n\t\t\tcurLeft = curPosition.left;\n\t\t} else {\n\t\t\tcurTop = parseFloat( curCSSTop ) || 0;\n\t\t\tcurLeft = parseFloat( curCSSLeft ) || 0;\n\t\t}\n\n\t\tif ( jQuery.isFunction( options ) ) {\n\t\t\toptions = options.call( elem, i, curOffset );\n\t\t}\n\n\t\tif ( options.top != null ) {\n\t\t\tprops.top = ( options.top - curOffset.top ) + curTop;\n\t\t}\n\t\tif ( options.left != null ) {\n\t\t\tprops.left = ( options.left - curOffset.left ) + curLeft;\n\t\t}\n\n\t\tif ( \"using\" in options ) {\n\t\t\toptions.using.call( elem, props );\n\t\t} else {\n\t\t\tcurElem.css( props );\n\t\t}\n\t}\n};\n\njQuery.fn.extend({\n\toffset: function( options ) {\n\t\tif ( arguments.length ) {\n\t\t\treturn options === undefined ?\n\t\t\t\tthis :\n\t\t\t\tthis.each(function( i ) {\n\t\t\t\t\tjQuery.offset.setOffset( this, options, i );\n\t\t\t\t});\n\t\t}\n\n\t\tvar docElem, win,\n\t\t\tbox = { top: 0, left: 0 },\n\t\t\telem = this[ 0 ],\n\t\t\tdoc = elem && elem.ownerDocument;\n\n\t\tif ( !doc ) {\n\t\t\treturn;\n\t\t}\n\n\t\tdocElem = doc.documentElement;\n\n\t\t// Make sure it's not a disconnected DOM node\n\t\tif ( !jQuery.contains( docElem, elem ) ) {\n\t\t\treturn box;\n\t\t}\n\n\t\t// If we don't have gBCR, just use 0,0 rather than error\n\t\t// BlackBerry 5, iOS 3 (original iPhone)\n\t\tif ( typeof elem.getBoundingClientRect !== strundefined ) {\n\t\t\tbox = elem.getBoundingClientRect();\n\t\t}\n\t\twin = getWindow( doc );\n\t\treturn {\n\t\t\ttop: box.top  + ( win.pageYOffset || docElem.scrollTop )  - ( docElem.clientTop  || 0 ),\n\t\t\tleft: box.left + ( win.pageXOffset || docElem.scrollLeft ) - ( docElem.clientLeft || 0 )\n\t\t};\n\t},\n\n\tposition: function() {\n\t\tif ( !this[ 0 ] ) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar offsetParent, offset,\n\t\t\tparentOffset = { top: 0, left: 0 },\n\t\t\telem = this[ 0 ];\n\n\t\t// fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent\n\t\tif ( jQuery.css( elem, \"position\" ) === \"fixed\" ) {\n\t\t\t// we assume that getBoundingClientRect is available when computed position is fixed\n\t\t\toffset = elem.getBoundingClientRect();\n\t\t} else {\n\t\t\t// Get *real* offsetParent\n\t\t\toffsetParent = this.offsetParent();\n\n\t\t\t// Get correct offsets\n\t\t\toffset = this.offset();\n\t\t\tif ( !jQuery.nodeName( offsetParent[ 0 ], \"html\" ) ) {\n\t\t\t\tparentOffset = offsetParent.offset();\n\t\t\t}\n\n\t\t\t// Add offsetParent borders\n\t\t\tparentOffset.top  += jQuery.css( offsetParent[ 0 ], \"borderTopWidth\", true );\n\t\t\tparentOffset.left += jQuery.css( offsetParent[ 0 ], \"borderLeftWidth\", true );\n\t\t}\n\n\t\t// Subtract parent offsets and element margins\n\t\t// note: when an element has margin: auto the offsetLeft and marginLeft\n\t\t// are the same in Safari causing offset.left to incorrectly be 0\n\t\treturn {\n\t\t\ttop:  offset.top  - parentOffset.top - jQuery.css( elem, \"marginTop\", true ),\n\t\t\tleft: offset.left - parentOffset.left - jQuery.css( elem, \"marginLeft\", true)\n\t\t};\n\t},\n\n\toffsetParent: function() {\n\t\treturn this.map(function() {\n\t\t\tvar offsetParent = this.offsetParent || docElem;\n\n\t\t\twhile ( offsetParent && ( !jQuery.nodeName( offsetParent, \"html\" ) && jQuery.css( offsetParent, \"position\" ) === \"static\" ) ) {\n\t\t\t\toffsetParent = offsetParent.offsetParent;\n\t\t\t}\n\t\t\treturn offsetParent || docElem;\n\t\t});\n\t}\n});\n\n// Create scrollLeft and scrollTop methods\njQuery.each( { scrollLeft: \"pageXOffset\", scrollTop: \"pageYOffset\" }, function( method, prop ) {\n\tvar top = /Y/.test( prop );\n\n\tjQuery.fn[ method ] = function( val ) {\n\t\treturn access( this, function( elem, method, val ) {\n\t\t\tvar win = getWindow( elem );\n\n\t\t\tif ( val === undefined ) {\n\t\t\t\treturn win ? (prop in win) ? win[ prop ] :\n\t\t\t\t\twin.document.documentElement[ method ] :\n\t\t\t\t\telem[ method ];\n\t\t\t}\n\n\t\t\tif ( win ) {\n\t\t\t\twin.scrollTo(\n\t\t\t\t\t!top ? val : jQuery( win ).scrollLeft(),\n\t\t\t\t\ttop ? val : jQuery( win ).scrollTop()\n\t\t\t\t);\n\n\t\t\t} else {\n\t\t\t\telem[ method ] = val;\n\t\t\t}\n\t\t}, method, val, arguments.length, null );\n\t};\n});\n\n// Add the top/left cssHooks using jQuery.fn.position\n// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\n// getComputedStyle returns percent when specified for top/left/bottom/right\n// rather than make the css module depend on the offset module, we just check for it here\njQuery.each( [ \"top\", \"left\" ], function( i, prop ) {\n\tjQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,\n\t\tfunction( elem, computed ) {\n\t\t\tif ( computed ) {\n\t\t\t\tcomputed = curCSS( elem, prop );\n\t\t\t\t// if curCSS returns percentage, fallback to offset\n\t\t\t\treturn rnumnonpx.test( computed ) ?\n\t\t\t\t\tjQuery( elem ).position()[ prop ] + \"px\" :\n\t\t\t\t\tcomputed;\n\t\t\t}\n\t\t}\n\t);\n});\n\n\n// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\njQuery.each( { Height: \"height\", Width: \"width\" }, function( name, type ) {\n\tjQuery.each( { padding: \"inner\" + name, content: type, \"\": \"outer\" + name }, function( defaultExtra, funcName ) {\n\t\t// margin is only for outerHeight, outerWidth\n\t\tjQuery.fn[ funcName ] = function( margin, value ) {\n\t\t\tvar chainable = arguments.length && ( defaultExtra || typeof margin !== \"boolean\" ),\n\t\t\t\textra = defaultExtra || ( margin === true || value === true ? \"margin\" : \"border\" );\n\n\t\t\treturn access( this, function( elem, type, value ) {\n\t\t\t\tvar doc;\n\n\t\t\t\tif ( jQuery.isWindow( elem ) ) {\n\t\t\t\t\t// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there\n\t\t\t\t\t// isn't a whole lot we can do. See pull request at this URL for discussion:\n\t\t\t\t\t// https://github.com/jquery/jquery/pull/764\n\t\t\t\t\treturn elem.document.documentElement[ \"client\" + name ];\n\t\t\t\t}\n\n\t\t\t\t// Get document width or height\n\t\t\t\tif ( elem.nodeType === 9 ) {\n\t\t\t\t\tdoc = elem.documentElement;\n\n\t\t\t\t\t// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height], whichever is greatest\n\t\t\t\t\t// unfortunately, this causes bug #3838 in IE6/8 only, but there is currently no good, small way to fix it.\n\t\t\t\t\treturn Math.max(\n\t\t\t\t\t\telem.body[ \"scroll\" + name ], doc[ \"scroll\" + name ],\n\t\t\t\t\t\telem.body[ \"offset\" + name ], doc[ \"offset\" + name ],\n\t\t\t\t\t\tdoc[ \"client\" + name ]\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\treturn value === undefined ?\n\t\t\t\t\t// Get width or height on the element, requesting but not forcing parseFloat\n\t\t\t\t\tjQuery.css( elem, type, extra ) :\n\n\t\t\t\t\t// Set width or height on the element\n\t\t\t\t\tjQuery.style( elem, type, value, extra );\n\t\t\t}, type, chainable ? margin : undefined, chainable, null );\n\t\t};\n\t});\n});\n\n\n// The number of elements contained in the matched element set\njQuery.fn.size = function() {\n\treturn this.length;\n};\n\njQuery.fn.andSelf = jQuery.fn.addBack;\n\n\n\n\n// Register as a named AMD module, since jQuery can be concatenated with other\n// files that may use define, but not via a proper concatenation script that\n// understands anonymous AMD modules. A named AMD is safest and most robust\n// way to register. Lowercase jquery is used because AMD module names are\n// derived from file names, and jQuery is normally delivered in a lowercase\n// file name. Do this after creating the global so that if an AMD module wants\n// to call noConflict to hide this version of jQuery, it will work.\n\n// Note that for maximum portability, libraries that are not jQuery should\n// declare themselves as anonymous modules, and avoid setting a global if an\n// AMD loader is present. jQuery is a special case. For more information, see\n// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon\n\nif ( typeof define === \"function\" && define.amd ) {\n\tdefine( \"jquery\", [], function() {\n\t\treturn jQuery;\n\t});\n}\n\n\n\n\nvar\n\t// Map over jQuery in case of overwrite\n\t_jQuery = window.jQuery,\n\n\t// Map over the $ in case of overwrite\n\t_$ = window.$;\n\njQuery.noConflict = function( deep ) {\n\tif ( window.$ === jQuery ) {\n\t\twindow.$ = _$;\n\t}\n\n\tif ( deep && window.jQuery === jQuery ) {\n\t\twindow.jQuery = _jQuery;\n\t}\n\n\treturn jQuery;\n};\n\n// Expose jQuery and $ identifiers, even in\n// AMD (#7102#comment:10, https://github.com/jquery/jquery/pull/557)\n// and CommonJS for browser emulators (#13566)\nif ( typeof noGlobal === strundefined ) {\n\twindow.jQuery = window.$ = jQuery;\n}\n\n\n\n\nreturn jQuery;\n\n}));\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/jquery/dist/jquery.js\n ** module id = 3\n ** module chunks = 0\n **/","/** @jsx React.DOM */;(function () {\n\t'use strict';\n\n\t/**\n\t * @preserve FastClick: polyfill to remove click delays on browsers with touch UIs.\n\t *\n\t * @codingstandard ftlabs-jsv2\n\t * @copyright The Financial Times Limited [All Rights Reserved]\n\t * @license MIT License (see LICENSE.txt)\n\t */\n\n\t/*jslint browser:true, node:true*/\n\t/*global define, Event, Node*/\n\n\n\t/**\n\t * Instantiate fast-clicking listeners on the specified layer.\n\t *\n\t * @constructor\n\t * @param {Element} layer The layer to listen on\n\t * @param {Object} [options={}] The options to override the defaults\n\t */\n\tfunction FastClick(layer, options) {\n\t\tvar oldOnClick;\n\n\t\toptions = options || {};\n\n\t\t/**\n\t\t * Whether a click is currently being tracked.\n\t\t *\n\t\t * @type boolean\n\t\t */\n\t\tthis.trackingClick = false;\n\n\n\t\t/**\n\t\t * Timestamp for when click tracking started.\n\t\t *\n\t\t * @type number\n\t\t */\n\t\tthis.trackingClickStart = 0;\n\n\n\t\t/**\n\t\t * The element being tracked for a click.\n\t\t *\n\t\t * @type EventTarget\n\t\t */\n\t\tthis.targetElement = null;\n\n\n\t\t/**\n\t\t * X-coordinate of touch start event.\n\t\t *\n\t\t * @type number\n\t\t */\n\t\tthis.touchStartX = 0;\n\n\n\t\t/**\n\t\t * Y-coordinate of touch start event.\n\t\t *\n\t\t * @type number\n\t\t */\n\t\tthis.touchStartY = 0;\n\n\n\t\t/**\n\t\t * ID of the last touch, retrieved from Touch.identifier.\n\t\t *\n\t\t * @type number\n\t\t */\n\t\tthis.lastTouchIdentifier = 0;\n\n\n\t\t/**\n\t\t * Touchmove boundary, beyond which a click will be cancelled.\n\t\t *\n\t\t * @type number\n\t\t */\n\t\tthis.touchBoundary = options.touchBoundary || 10;\n\n\n\t\t/**\n\t\t * The FastClick layer.\n\t\t *\n\t\t * @type Element\n\t\t */\n\t\tthis.layer = layer;\n\n\t\t/**\n\t\t * The minimum time between tap(touchstart and touchend) events\n\t\t *\n\t\t * @type number\n\t\t */\n\t\tthis.tapDelay = options.tapDelay || 200;\n\n\t\t/**\n\t\t * The maximum time for a tap\n\t\t *\n\t\t * @type number\n\t\t */\n\t\tthis.tapTimeout = options.tapTimeout || 700;\n\n\t\tif (FastClick.notNeeded(layer)) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Some old versions of Android don't have Function.prototype.bind\n\t\tfunction bind(method, context) {\n\t\t\treturn function() { return method.apply(context, arguments); };\n\t\t}\n\n\n\t\tvar methods = ['onMouse', 'onClick', 'onTouchStart', 'onTouchMove', 'onTouchEnd', 'onTouchCancel'];\n\t\tvar context = this;\n\t\tfor (var i = 0, l = methods.length; i < l; i++) {\n\t\t\tcontext[methods[i]] = bind(context[methods[i]], context);\n\t\t}\n\n\t\t// Set up event handlers as required\n\t\tif (deviceIsAndroid) {\n\t\t\tlayer.addEventListener('mouseover', this.onMouse, true);\n\t\t\tlayer.addEventListener('mousedown', this.onMouse, true);\n\t\t\tlayer.addEventListener('mouseup', this.onMouse, true);\n\t\t}\n\n\t\tlayer.addEventListener('click', this.onClick, true);\n\t\tlayer.addEventListener('touchstart', this.onTouchStart, false);\n\t\tlayer.addEventListener('touchmove', this.onTouchMove, false);\n\t\tlayer.addEventListener('touchend', this.onTouchEnd, false);\n\t\tlayer.addEventListener('touchcancel', this.onTouchCancel, false);\n\n\t\t// Hack is required for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)\n\t\t// which is how FastClick normally stops click events bubbling to callbacks registered on the FastClick\n\t\t// layer when they are cancelled.\n\t\tif (!Event.prototype.stopImmediatePropagation) {\n\t\t\tlayer.removeEventListener = function(type, callback, capture) {\n\t\t\t\tvar rmv = Node.prototype.removeEventListener;\n\t\t\t\tif (type === 'click') {\n\t\t\t\t\trmv.call(layer, type, callback.hijacked || callback, capture);\n\t\t\t\t} else {\n\t\t\t\t\trmv.call(layer, type, callback, capture);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tlayer.addEventListener = function(type, callback, capture) {\n\t\t\t\tvar adv = Node.prototype.addEventListener;\n\t\t\t\tif (type === 'click') {\n\t\t\t\t\tadv.call(layer, type, callback.hijacked || (callback.hijacked = function(event) {\n\t\t\t\t\t\tif (!event.propagationStopped) {\n\t\t\t\t\t\t\tcallback(event);\n\t\t\t\t\t\t}\n\t\t\t\t\t}), capture);\n\t\t\t\t} else {\n\t\t\t\t\tadv.call(layer, type, callback, capture);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\t// If a handler is already declared in the element's onclick attribute, it will be fired before\n\t\t// FastClick's onClick handler. Fix this by pulling out the user-defined handler function and\n\t\t// adding it as listener.\n\t\tif (typeof layer.onclick === 'function') {\n\n\t\t\t// Android browser on at least 3.2 requires a new reference to the function in layer.onclick\n\t\t\t// - the old one won't work if passed to addEventListener directly.\n\t\t\toldOnClick = layer.onclick;\n\t\t\tlayer.addEventListener('click', function(event) {\n\t\t\t\toldOnClick(event);\n\t\t\t}, false);\n\t\t\tlayer.onclick = null;\n\t\t}\n\t}\n\n\t/**\n\t* Windows Phone 8.1 fakes user agent string to look like Android and iPhone.\n\t*\n\t* @type boolean\n\t*/\n\tvar deviceIsWindowsPhone = navigator.userAgent.indexOf(\"Windows Phone\") >= 0;\n\n\t/**\n\t * Android requires exceptions.\n\t *\n\t * @type boolean\n\t */\n\tvar deviceIsAndroid = navigator.userAgent.indexOf('Android') > 0 && !deviceIsWindowsPhone;\n\n\n\t/**\n\t * iOS requires exceptions.\n\t *\n\t * @type boolean\n\t */\n\tvar deviceIsIOS = /iP(ad|hone|od)/.test(navigator.userAgent) && !deviceIsWindowsPhone;\n\n\n\t/**\n\t * iOS 4 requires an exception for select elements.\n\t *\n\t * @type boolean\n\t */\n\tvar deviceIsIOS4 = deviceIsIOS && (/OS 4_\\d(_\\d)?/).test(navigator.userAgent);\n\n\n\t/**\n\t * iOS 6.0-7.* requires the target element to be manually derived\n\t *\n\t * @type boolean\n\t */\n\tvar deviceIsIOSWithBadTarget = deviceIsIOS && (/OS [6-7]_\\d/).test(navigator.userAgent);\n\n\t/**\n\t * BlackBerry requires exceptions.\n\t *\n\t * @type boolean\n\t */\n\tvar deviceIsBlackBerry10 = navigator.userAgent.indexOf('BB10') > 0;\n\n\t/**\n\t * Determine whether a given element requires a native click.\n\t *\n\t * @param {EventTarget|Element} target Target DOM element\n\t * @returns {boolean} Returns true if the element needs a native click\n\t */\n\tFastClick.prototype.needsClick = function(target) {\n\t\tswitch (target.nodeName.toLowerCase()) {\n\n\t\t// Don't send a synthetic click to disabled inputs (issue #62)\n\t\tcase 'button':\n\t\tcase 'select':\n\t\tcase 'textarea':\n\t\t\tif (target.disabled) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase 'input':\n\n\t\t\t// File inputs need real clicks on iOS 6 due to a browser bug (issue #68)\n\t\t\tif ((deviceIsIOS && target.type === 'file') || target.disabled) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase 'label':\n\t\tcase 'iframe': // iOS8 homescreen apps can prevent events bubbling into frames\n\t\tcase 'video':\n\t\t\treturn true;\n\t\t}\n\n\t\treturn (/\\bneedsclick\\b/).test(target.className);\n\t};\n\n\n\t/**\n\t * Determine whether a given element requires a call to focus to simulate click into element.\n\t *\n\t * @param {EventTarget|Element} target Target DOM element\n\t * @returns {boolean} Returns true if the element requires a call to focus to simulate native click.\n\t */\n\tFastClick.prototype.needsFocus = function(target) {\n\t\tswitch (target.nodeName.toLowerCase()) {\n\t\tcase 'textarea':\n\t\t\treturn true;\n\t\tcase 'select':\n\t\t\treturn !deviceIsAndroid;\n\t\tcase 'input':\n\t\t\tswitch (target.type) {\n\t\t\tcase 'button':\n\t\t\tcase 'checkbox':\n\t\t\tcase 'file':\n\t\t\tcase 'image':\n\t\t\tcase 'radio':\n\t\t\tcase 'submit':\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// No point in attempting to focus disabled inputs\n\t\t\treturn !target.disabled && !target.readOnly;\n\t\tdefault:\n\t\t\treturn (/\\bneedsfocus\\b/).test(target.className);\n\t\t}\n\t};\n\n\n\t/**\n\t * Send a click event to the specified element.\n\t *\n\t * @param {EventTarget|Element} targetElement\n\t * @param {Event} event\n\t */\n\tFastClick.prototype.sendClick = function(targetElement, event) {\n\t\tvar clickEvent, touch;\n\n\t\t// On some Android devices activeElement needs to be blurred otherwise the synthetic click will have no effect (#24)\n\t\tif (document.activeElement && document.activeElement !== targetElement) {\n\t\t\tdocument.activeElement.blur();\n\t\t}\n\n\t\ttouch = event.changedTouches[0];\n\n\t\t// Synthesise a click event, with an extra attribute so it can be tracked\n\t\tclickEvent = document.createEvent('MouseEvents');\n\t\tclickEvent.initMouseEvent(this.determineEventType(targetElement), true, true, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null);\n\t\tclickEvent.forwardedTouchEvent = true;\n\t\ttargetElement.dispatchEvent(clickEvent);\n\t};\n\n\tFastClick.prototype.determineEventType = function(targetElement) {\n\n\t\t//Issue #159: Android Chrome Select Box does not open with a synthetic click event\n\t\tif (deviceIsAndroid && targetElement.tagName.toLowerCase() === 'select') {\n\t\t\treturn 'mousedown';\n\t\t}\n\n\t\treturn 'click';\n\t};\n\n\n\t/**\n\t * @param {EventTarget|Element} targetElement\n\t */\n\tFastClick.prototype.focus = function(targetElement) {\n\t\tvar length;\n\n\t\t// Issue #160: on iOS 7, some input elements (e.g. date datetime month) throw a vague TypeError on setSelectionRange. These elements don't have an integer value for the selectionStart and selectionEnd properties, but unfortunately that can't be used for detection because accessing the properties also throws a TypeError. Just check the type instead. Filed as Apple bug #15122724.\n\t\tif (deviceIsIOS && targetElement.setSelectionRange && targetElement.type.indexOf('date') !== 0 && targetElement.type !== 'time' && targetElement.type !== 'month') {\n\t\t\tlength = targetElement.value.length;\n\t\t\ttargetElement.setSelectionRange(length, length);\n\t\t} else {\n\t\t\ttargetElement.focus();\n\t\t}\n\t};\n\n\n\t/**\n\t * Check whether the given target element is a child of a scrollable layer and if so, set a flag on it.\n\t *\n\t * @param {EventTarget|Element} targetElement\n\t */\n\tFastClick.prototype.updateScrollParent = function(targetElement) {\n\t\tvar scrollParent, parentElement;\n\n\t\tscrollParent = targetElement.fastClickScrollParent;\n\n\t\t// Attempt to discover whether the target element is contained within a scrollable layer. Re-check if the\n\t\t// target element was moved to another parent.\n\t\tif (!scrollParent || !scrollParent.contains(targetElement)) {\n\t\t\tparentElement = targetElement;\n\t\t\tdo {\n\t\t\t\tif (parentElement.scrollHeight > parentElement.offsetHeight) {\n\t\t\t\t\tscrollParent = parentElement;\n\t\t\t\t\ttargetElement.fastClickScrollParent = parentElement;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tparentElement = parentElement.parentElement;\n\t\t\t} while (parentElement);\n\t\t}\n\n\t\t// Always update the scroll top tracker if possible.\n\t\tif (scrollParent) {\n\t\t\tscrollParent.fastClickLastScrollTop = scrollParent.scrollTop;\n\t\t}\n\t};\n\n\n\t/**\n\t * @param {EventTarget} targetElement\n\t * @returns {Element|EventTarget}\n\t */\n\tFastClick.prototype.getTargetElementFromEventTarget = function(eventTarget) {\n\n\t\t// On some older browsers (notably Safari on iOS 4.1 - see issue #56) the event target may be a text node.\n\t\tif (eventTarget.nodeType === Node.TEXT_NODE) {\n\t\t\treturn eventTarget.parentNode;\n\t\t}\n\n\t\treturn eventTarget;\n\t};\n\n\n\t/**\n\t * On touch start, record the position and scroll offset.\n\t *\n\t * @param {Event} event\n\t * @returns {boolean}\n\t */\n\tFastClick.prototype.onTouchStart = function(event) {\n\t\tvar targetElement, touch, selection;\n\n\t\t// Ignore multiple touches, otherwise pinch-to-zoom is prevented if both fingers are on the FastClick element (issue #111).\n\t\tif (event.targetTouches.length > 1) {\n\t\t\treturn true;\n\t\t}\n\n\t\ttargetElement = this.getTargetElementFromEventTarget(event.target);\n\t\ttouch = event.targetTouches[0];\n\n\t\tif (deviceIsIOS) {\n\n\t\t\t// Only trusted events will deselect text on iOS (issue #49)\n\t\t\tselection = window.getSelection();\n\t\t\tif (selection.rangeCount && !selection.isCollapsed) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (!deviceIsIOS4) {\n\n\t\t\t\t// Weird things happen on iOS when an alert or confirm dialog is opened from a click event callback (issue #23):\n\t\t\t\t// when the user next taps anywhere else on the page, new touchstart and touchend events are dispatched\n\t\t\t\t// with the same identifier as the touch event that previously triggered the click that triggered the alert.\n\t\t\t\t// Sadly, there is an issue on iOS 4 that causes some normal touch events to have the same identifier as an\n\t\t\t\t// immediately preceeding touch event (issue #52), so this fix is unavailable on that platform.\n\t\t\t\t// Issue 120: touch.identifier is 0 when Chrome dev tools 'Emulate touch events' is set with an iOS device UA string,\n\t\t\t\t// which causes all touch events to be ignored. As this block only applies to iOS, and iOS identifiers are always long,\n\t\t\t\t// random integers, it's safe to to continue if the identifier is 0 here.\n\t\t\t\tif (touch.identifier && touch.identifier === this.lastTouchIdentifier) {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tthis.lastTouchIdentifier = touch.identifier;\n\n\t\t\t\t// If the target element is a child of a scrollable layer (using -webkit-overflow-scrolling: touch) and:\n\t\t\t\t// 1) the user does a fling scroll on the scrollable layer\n\t\t\t\t// 2) the user stops the fling scroll with another tap\n\t\t\t\t// then the event.target of the last 'touchend' event will be the element that was under the user's finger\n\t\t\t\t// when the fling scroll was started, causing FastClick to send a click event to that layer - unless a check\n\t\t\t\t// is made to ensure that a parent layer was not scrolled before sending a synthetic click (issue #42).\n\t\t\t\tthis.updateScrollParent(targetElement);\n\t\t\t}\n\t\t}\n\n\t\tthis.trackingClick = true;\n\t\tthis.trackingClickStart = event.timeStamp;\n\t\tthis.targetElement = targetElement;\n\n\t\tthis.touchStartX = touch.pageX;\n\t\tthis.touchStartY = touch.pageY;\n\n\t\t// Prevent phantom clicks on fast double-tap (issue #36)\n\t\tif ((event.timeStamp - this.lastClickTime) < this.tapDelay) {\n\t\t\tevent.preventDefault();\n\t\t}\n\n\t\treturn true;\n\t};\n\n\n\t/**\n\t * Based on a touchmove event object, check whether the touch has moved past a boundary since it started.\n\t *\n\t * @param {Event} event\n\t * @returns {boolean}\n\t */\n\tFastClick.prototype.touchHasMoved = function(event) {\n\t\tvar touch = event.changedTouches[0], boundary = this.touchBoundary;\n\n\t\tif (Math.abs(touch.pageX - this.touchStartX) > boundary || Math.abs(touch.pageY - this.touchStartY) > boundary) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t};\n\n\n\t/**\n\t * Update the last position.\n\t *\n\t * @param {Event} event\n\t * @returns {boolean}\n\t */\n\tFastClick.prototype.onTouchMove = function(event) {\n\t\tif (!this.trackingClick) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// If the touch has moved, cancel the click tracking\n\t\tif (this.targetElement !== this.getTargetElementFromEventTarget(event.target) || this.touchHasMoved(event)) {\n\t\t\tthis.trackingClick = false;\n\t\t\tthis.targetElement = null;\n\t\t}\n\n\t\treturn true;\n\t};\n\n\n\t/**\n\t * Attempt to find the labelled control for the given label element.\n\t *\n\t * @param {EventTarget|HTMLLabelElement} labelElement\n\t * @returns {Element|null}\n\t */\n\tFastClick.prototype.findControl = function(labelElement) {\n\n\t\t// Fast path for newer browsers supporting the HTML5 control attribute\n\t\tif (labelElement.control !== undefined) {\n\t\t\treturn labelElement.control;\n\t\t}\n\n\t\t// All browsers under test that support touch events also support the HTML5 htmlFor attribute\n\t\tif (labelElement.htmlFor) {\n\t\t\treturn document.getElementById(labelElement.htmlFor);\n\t\t}\n\n\t\t// If no for attribute exists, attempt to retrieve the first labellable descendant element\n\t\t// the list of which is defined here: http://www.w3.org/TR/html5/forms.html#category-label\n\t\treturn labelElement.querySelector('button, input:not([type=hidden]), keygen, meter, output, progress, select, textarea');\n\t};\n\n\n\t/**\n\t * On touch end, determine whether to send a click event at once.\n\t *\n\t * @param {Event} event\n\t * @returns {boolean}\n\t */\n\tFastClick.prototype.onTouchEnd = function(event) {\n\t\tvar forElement, trackingClickStart, targetTagName, scrollParent, touch, targetElement = this.targetElement;\n\n\t\tif (!this.trackingClick) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Prevent phantom clicks on fast double-tap (issue #36)\n\t\tif ((event.timeStamp - this.lastClickTime) < this.tapDelay) {\n\t\t\tthis.cancelNextClick = true;\n\t\t\treturn true;\n\t\t}\n\n\t\tif ((event.timeStamp - this.trackingClickStart) > this.tapTimeout) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Reset to prevent wrong click cancel on input (issue #156).\n\t\tthis.cancelNextClick = false;\n\n\t\tthis.lastClickTime = event.timeStamp;\n\n\t\ttrackingClickStart = this.trackingClickStart;\n\t\tthis.trackingClick = false;\n\t\tthis.trackingClickStart = 0;\n\n\t\t// On some iOS devices, the targetElement supplied with the event is invalid if the layer\n\t\t// is performing a transition or scroll, and has to be re-detected manually. Note that\n\t\t// for this to function correctly, it must be called *after* the event target is checked!\n\t\t// See issue #57; also filed as rdar://13048589 .\n\t\tif (deviceIsIOSWithBadTarget) {\n\t\t\ttouch = event.changedTouches[0];\n\n\t\t\t// In certain cases arguments of elementFromPoint can be negative, so prevent setting targetElement to null\n\t\t\ttargetElement = document.elementFromPoint(touch.pageX - window.pageXOffset, touch.pageY - window.pageYOffset) || targetElement;\n\t\t\ttargetElement.fastClickScrollParent = this.targetElement.fastClickScrollParent;\n\t\t}\n\n\t\ttargetTagName = targetElement.tagName.toLowerCase();\n\t\tif (targetTagName === 'label') {\n\t\t\tforElement = this.findControl(targetElement);\n\t\t\tif (forElement) {\n\t\t\t\tthis.focus(targetElement);\n\t\t\t\tif (deviceIsAndroid) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\ttargetElement = forElement;\n\t\t\t}\n\t\t} else if (this.needsFocus(targetElement)) {\n\n\t\t\t// Case 1: If the touch started a while ago (best guess is 100ms based on tests for issue #36) then focus will be triggered anyway. Return early and unset the target element reference so that the subsequent click will be allowed through.\n\t\t\t// Case 2: Without this exception for input elements tapped when the document is contained in an iframe, then any inputted text won't be visible even though the value attribute is updated as the user types (issue #37).\n\t\t\tif ((event.timeStamp - trackingClickStart) > 100 || (deviceIsIOS && window.top !== window && targetTagName === 'input')) {\n\t\t\t\tthis.targetElement = null;\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tthis.focus(targetElement);\n\t\t\tthis.sendClick(targetElement, event);\n\n\t\t\t// Select elements need the event to go through on iOS 4, otherwise the selector menu won't open.\n\t\t\t// Also this breaks opening selects when VoiceOver is active on iOS6, iOS7 (and possibly others)\n\t\t\tif (!deviceIsIOS || targetTagName !== 'select') {\n\t\t\t\tthis.targetElement = null;\n\t\t\t\tevent.preventDefault();\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\n\t\tif (deviceIsIOS && !deviceIsIOS4) {\n\n\t\t\t// Don't send a synthetic click event if the target element is contained within a parent layer that was scrolled\n\t\t\t// and this tap is being used to stop the scrolling (usually initiated by a fling - issue #42).\n\t\t\tscrollParent = targetElement.fastClickScrollParent;\n\t\t\tif (scrollParent && scrollParent.fastClickLastScrollTop !== scrollParent.scrollTop) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\t// Prevent the actual click from going though - unless the target node is marked as requiring\n\t\t// real clicks or if it is in the whitelist in which case only non-programmatic clicks are permitted.\n\t\tif (!this.needsClick(targetElement)) {\n\t\t\tevent.preventDefault();\n\t\t\tthis.sendClick(targetElement, event);\n\t\t}\n\n\t\treturn false;\n\t};\n\n\n\t/**\n\t * On touch cancel, stop tracking the click.\n\t *\n\t * @returns {void}\n\t */\n\tFastClick.prototype.onTouchCancel = function() {\n\t\tthis.trackingClick = false;\n\t\tthis.targetElement = null;\n\t};\n\n\n\t/**\n\t * Determine mouse events which should be permitted.\n\t *\n\t * @param {Event} event\n\t * @returns {boolean}\n\t */\n\tFastClick.prototype.onMouse = function(event) {\n\n\t\t// If a target element was never set (because a touch event was never fired) allow the event\n\t\tif (!this.targetElement) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (event.forwardedTouchEvent) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Programmatically generated events targeting a specific element should be permitted\n\t\tif (!event.cancelable) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Derive and check the target element to see whether the mouse event needs to be permitted;\n\t\t// unless explicitly enabled, prevent non-touch click events from triggering actions,\n\t\t// to prevent ghost/doubleclicks.\n\t\tif (!this.needsClick(this.targetElement) || this.cancelNextClick) {\n\n\t\t\t// Prevent any user-added listeners declared on FastClick element from being fired.\n\t\t\tif (event.stopImmediatePropagation) {\n\t\t\t\tevent.stopImmediatePropagation();\n\t\t\t} else {\n\n\t\t\t\t// Part of the hack for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)\n\t\t\t\tevent.propagationStopped = true;\n\t\t\t}\n\n\t\t\t// Cancel the event\n\t\t\tevent.stopPropagation();\n\t\t\tevent.preventDefault();\n\n\t\t\treturn false;\n\t\t}\n\n\t\t// If the mouse event is permitted, return true for the action to go through.\n\t\treturn true;\n\t};\n\n\n\t/**\n\t * On actual clicks, determine whether this is a touch-generated click, a click action occurring\n\t * naturally after a delay after a touch (which needs to be cancelled to avoid duplication), or\n\t * an actual click which should be permitted.\n\t *\n\t * @param {Event} event\n\t * @returns {boolean}\n\t */\n\tFastClick.prototype.onClick = function(event) {\n\t\tvar permitted;\n\n\t\t// It's possible for another FastClick-like library delivered with third-party code to fire a click event before FastClick does (issue #44). In that case, set the click-tracking flag back to false and return early. This will cause onTouchEnd to return early.\n\t\tif (this.trackingClick) {\n\t\t\tthis.targetElement = null;\n\t\t\tthis.trackingClick = false;\n\t\t\treturn true;\n\t\t}\n\n\t\t// Very odd behaviour on iOS (issue #18): if a submit element is present inside a form and the user hits enter in the iOS simulator or clicks the Go button on the pop-up OS keyboard the a kind of 'fake' click event will be triggered with the submit-type input element as the target.\n\t\tif (event.target.type === 'submit' && event.detail === 0) {\n\t\t\treturn true;\n\t\t}\n\n\t\tpermitted = this.onMouse(event);\n\n\t\t// Only unset targetElement if the click is not permitted. This will ensure that the check for !targetElement in onMouse fails and the browser's click doesn't go through.\n\t\tif (!permitted) {\n\t\t\tthis.targetElement = null;\n\t\t}\n\n\t\t// If clicks are permitted, return true for the action to go through.\n\t\treturn permitted;\n\t};\n\n\n\t/**\n\t * Remove all FastClick's event listeners.\n\t *\n\t * @returns {void}\n\t */\n\tFastClick.prototype.destroy = function() {\n\t\tvar layer = this.layer;\n\n\t\tif (deviceIsAndroid) {\n\t\t\tlayer.removeEventListener('mouseover', this.onMouse, true);\n\t\t\tlayer.removeEventListener('mousedown', this.onMouse, true);\n\t\t\tlayer.removeEventListener('mouseup', this.onMouse, true);\n\t\t}\n\n\t\tlayer.removeEventListener('click', this.onClick, true);\n\t\tlayer.removeEventListener('touchstart', this.onTouchStart, false);\n\t\tlayer.removeEventListener('touchmove', this.onTouchMove, false);\n\t\tlayer.removeEventListener('touchend', this.onTouchEnd, false);\n\t\tlayer.removeEventListener('touchcancel', this.onTouchCancel, false);\n\t};\n\n\n\t/**\n\t * Check whether FastClick is needed.\n\t *\n\t * @param {Element} layer The layer to listen on\n\t */\n\tFastClick.notNeeded = function(layer) {\n\t\tvar metaViewport;\n\t\tvar chromeVersion;\n\t\tvar blackberryVersion;\n\t\tvar firefoxVersion;\n\n\t\t// Devices that don't support touch don't need FastClick\n\t\tif (typeof window.ontouchstart === 'undefined') {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Chrome version - zero for other browsers\n\t\tchromeVersion = +(/Chrome\\/([0-9]+)/.exec(navigator.userAgent) || [,0])[1];\n\n\t\tif (chromeVersion) {\n\n\t\t\tif (deviceIsAndroid) {\n\t\t\t\tmetaViewport = document.querySelector('meta[name=viewport]');\n\n\t\t\t\tif (metaViewport) {\n\t\t\t\t\t// Chrome on Android with user-scalable=\"no\" doesn't need FastClick (issue #89)\n\t\t\t\t\tif (metaViewport.content.indexOf('user-scalable=no') !== -1) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\t// Chrome 32 and above with width=device-width or less don't need FastClick\n\t\t\t\t\tif (chromeVersion > 31 && document.documentElement.scrollWidth <= window.outerWidth) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// Chrome desktop doesn't need FastClick (issue #15)\n\t\t\t} else {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tif (deviceIsBlackBerry10) {\n\t\t\tblackberryVersion = navigator.userAgent.match(/Version\\/([0-9]*)\\.([0-9]*)/);\n\n\t\t\t// BlackBerry 10.3+ does not require Fastclick library.\n\t\t\t// https://github.com/ftlabs/fastclick/issues/251\n\t\t\tif (blackberryVersion[1] >= 10 && blackberryVersion[2] >= 3) {\n\t\t\t\tmetaViewport = document.querySelector('meta[name=viewport]');\n\n\t\t\t\tif (metaViewport) {\n\t\t\t\t\t// user-scalable=no eliminates click delay.\n\t\t\t\t\tif (metaViewport.content.indexOf('user-scalable=no') !== -1) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\t// width=device-width (or less than device-width) eliminates click delay.\n\t\t\t\t\tif (document.documentElement.scrollWidth <= window.outerWidth) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// IE10 with -ms-touch-action: none or manipulation, which disables double-tap-to-zoom (issue #97)\n\t\tif (layer.style.msTouchAction === 'none' || layer.style.touchAction === 'manipulation') {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Firefox version - zero for other browsers\n\t\tfirefoxVersion = +(/Firefox\\/([0-9]+)/.exec(navigator.userAgent) || [,0])[1];\n\n\t\tif (firefoxVersion >= 27) {\n\t\t\t// Firefox 27+ does not have tap delay if the content is not zoomable - https://bugzilla.mozilla.org/show_bug.cgi?id=922896\n\n\t\t\tmetaViewport = document.querySelector('meta[name=viewport]');\n\t\t\tif (metaViewport && (metaViewport.content.indexOf('user-scalable=no') !== -1 || document.documentElement.scrollWidth <= window.outerWidth)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\t// IE11: prefixed -ms-touch-action is no longer supported and it's recomended to use non-prefixed version\n\t\t// http://msdn.microsoft.com/en-us/library/windows/apps/Hh767313.aspx\n\t\tif (layer.style.touchAction === 'none' || layer.style.touchAction === 'manipulation') {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t};\n\n\n\t/**\n\t * Factory method for creating a FastClick object\n\t *\n\t * @param {Element} layer The layer to listen on\n\t * @param {Object} [options={}] The options to override the defaults\n\t */\n\tFastClick.attach = function(layer, options) {\n\t\treturn new FastClick(layer, options);\n\t};\n\n\n\tif (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {\n\n\t\t// AMD. Register as an anonymous module.\n\t\tdefine(function() {\n\t\t\treturn FastClick;\n\t\t});\n\t} else if (typeof module !== 'undefined' && module.exports) {\n\t\tmodule.exports = FastClick.attach;\n\t\tmodule.exports.FastClick = FastClick;\n\t} else {\n\t\twindow.FastClick = FastClick;\n\t}\n}());\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/fastclick/lib/fastclick.js\n ** module id = 4\n ** module chunks = 0\n **/","require(\"!!/home/ubuntu/workspace/node_modules/script-loader/addScript.js\")(require(\"!!/home/ubuntu/workspace/node_modules/script-loader/node_modules/raw-loader/index.js!/home/ubuntu/workspace/node_modules/jsx-loader/index.js?insertPragma=React.DOM!/home/ubuntu/workspace/node_modules/parse/build/parse-latest.js\"))\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/script-loader!./~/parse/build/parse-latest.js\n ** module id = 5\n ** module chunks = 0\n **/","/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\nmodule.exports = function(src) {\r\n\tif (typeof execScript === \"function\")\r\n\t\texecScript(src);\r\n\telse\r\n\t\teval.call(null, src);\r\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/script-loader/addScript.js\n ** module id = 6\n ** module chunks = 0\n **/","module.exports = \"/** @jsx React.DOM *//*!\\n * Parse JavaScript SDK\\n * Version: 1.5.0\\n * Built: Fri Jul 10 2015 17:05:46\\n * http://parse.com\\n *\\n * Copyright 2015 Parse, LLC\\n *\\n * Includes: Underscore.js\\n * Copyright 2009-2012 Jeremy Ashkenas, DocumentCloud Inc.\\n * Released under the MIT license.\\n */\\n(function(root) {\\n  root.Parse = root.Parse || {};\\n  root.Parse.VERSION = \\\"js1.5.0\\\";\\n}(this));\\n//     Underscore.js 1.4.4\\n//     http://underscorejs.org\\n//     (c) 2009-2013 Jeremy Ashkenas, DocumentCloud Inc.\\n//     Underscore may be freely distributed under the MIT license.\\n\\n(function() {\\n\\n  // Baseline setup\\n  // --------------\\n\\n  // Establish the root object, `window` in the browser, or `global` on the server.\\n  var root = this;\\n\\n  // Save the previous value of the `_` variable.\\n  var previousUnderscore = root._;\\n\\n  // Establish the object that gets returned to break out of a loop iteration.\\n  var breaker = {};\\n\\n  // Save bytes in the minified (but not gzipped) version:\\n  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;\\n\\n  // Create quick reference variables for speed access to core prototypes.\\n  var push             = ArrayProto.push,\\n      slice            = ArrayProto.slice,\\n      concat           = ArrayProto.concat,\\n      toString         = ObjProto.toString,\\n      hasOwnProperty   = ObjProto.hasOwnProperty;\\n\\n  // All **ECMAScript 5** native function implementations that we hope to use\\n  // are declared here.\\n  var\\n    nativeForEach      = ArrayProto.forEach,\\n    nativeMap          = ArrayProto.map,\\n    nativeReduce       = ArrayProto.reduce,\\n    nativeReduceRight  = ArrayProto.reduceRight,\\n    nativeFilter       = ArrayProto.filter,\\n    nativeEvery        = ArrayProto.every,\\n    nativeSome         = ArrayProto.some,\\n    nativeIndexOf      = ArrayProto.indexOf,\\n    nativeLastIndexOf  = ArrayProto.lastIndexOf,\\n    nativeIsArray      = Array.isArray,\\n    nativeKeys         = Object.keys,\\n    nativeBind         = FuncProto.bind;\\n\\n  // Create a safe reference to the Underscore object for use below.\\n  var _ = function(obj) {\\n    if (obj instanceof _) return obj;\\n    if (!(this instanceof _)) return new _(obj);\\n    this._wrapped = obj;\\n  };\\n\\n  // Export the Underscore object for **Node.js**, with\\n  // backwards-compatibility for the old `require()` API. If we're in\\n  // the browser, add `_` as a global object via a string identifier,\\n  // for Closure Compiler \\\"advanced\\\" mode.\\n  if (typeof exports !== 'undefined') {\\n    if (typeof module !== 'undefined' && module.exports) {\\n      exports = module.exports = _;\\n    }\\n    exports._ = _;\\n  } else {\\n    root._ = _;\\n  }\\n\\n  // Current version.\\n  _.VERSION = '1.4.4';\\n\\n  // Collection Functions\\n  // --------------------\\n\\n  // The cornerstone, an `each` implementation, aka `forEach`.\\n  // Handles objects with the built-in `forEach`, arrays, and raw objects.\\n  // Delegates to **ECMAScript 5**'s native `forEach` if available.\\n  var each = _.each = _.forEach = function(obj, iterator, context) {\\n    if (obj == null) return;\\n    if (nativeForEach && obj.forEach === nativeForEach) {\\n      obj.forEach(iterator, context);\\n    } else if (obj.length === +obj.length) {\\n      for (var i = 0, l = obj.length; i < l; i++) {\\n        if (iterator.call(context, obj[i], i, obj) === breaker) return;\\n      }\\n    } else {\\n      for (var key in obj) {\\n        if (_.has(obj, key)) {\\n          if (iterator.call(context, obj[key], key, obj) === breaker) return;\\n        }\\n      }\\n    }\\n  };\\n\\n  // Return the results of applying the iterator to each element.\\n  // Delegates to **ECMAScript 5**'s native `map` if available.\\n  _.map = _.collect = function(obj, iterator, context) {\\n    var results = [];\\n    if (obj == null) return results;\\n    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);\\n    each(obj, function(value, index, list) {\\n      results[results.length] = iterator.call(context, value, index, list);\\n    });\\n    return results;\\n  };\\n\\n  var reduceError = 'Reduce of empty array with no initial value';\\n\\n  // **Reduce** builds up a single result from a list of values, aka `inject`,\\n  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.\\n  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {\\n    var initial = arguments.length > 2;\\n    if (obj == null) obj = [];\\n    if (nativeReduce && obj.reduce === nativeReduce) {\\n      if (context) iterator = _.bind(iterator, context);\\n      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);\\n    }\\n    each(obj, function(value, index, list) {\\n      if (!initial) {\\n        memo = value;\\n        initial = true;\\n      } else {\\n        memo = iterator.call(context, memo, value, index, list);\\n      }\\n    });\\n    if (!initial) throw new TypeError(reduceError);\\n    return memo;\\n  };\\n\\n  // The right-associative version of reduce, also known as `foldr`.\\n  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.\\n  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {\\n    var initial = arguments.length > 2;\\n    if (obj == null) obj = [];\\n    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {\\n      if (context) iterator = _.bind(iterator, context);\\n      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);\\n    }\\n    var length = obj.length;\\n    if (length !== +length) {\\n      var keys = _.keys(obj);\\n      length = keys.length;\\n    }\\n    each(obj, function(value, index, list) {\\n      index = keys ? keys[--length] : --length;\\n      if (!initial) {\\n        memo = obj[index];\\n        initial = true;\\n      } else {\\n        memo = iterator.call(context, memo, obj[index], index, list);\\n      }\\n    });\\n    if (!initial) throw new TypeError(reduceError);\\n    return memo;\\n  };\\n\\n  // Return the first value which passes a truth test. Aliased as `detect`.\\n  _.find = _.detect = function(obj, iterator, context) {\\n    var result;\\n    any(obj, function(value, index, list) {\\n      if (iterator.call(context, value, index, list)) {\\n        result = value;\\n        return true;\\n      }\\n    });\\n    return result;\\n  };\\n\\n  // Return all the elements that pass a truth test.\\n  // Delegates to **ECMAScript 5**'s native `filter` if available.\\n  // Aliased as `select`.\\n  _.filter = _.select = function(obj, iterator, context) {\\n    var results = [];\\n    if (obj == null) return results;\\n    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);\\n    each(obj, function(value, index, list) {\\n      if (iterator.call(context, value, index, list)) results[results.length] = value;\\n    });\\n    return results;\\n  };\\n\\n  // Return all the elements for which a truth test fails.\\n  _.reject = function(obj, iterator, context) {\\n    return _.filter(obj, function(value, index, list) {\\n      return !iterator.call(context, value, index, list);\\n    }, context);\\n  };\\n\\n  // Determine whether all of the elements match a truth test.\\n  // Delegates to **ECMAScript 5**'s native `every` if available.\\n  // Aliased as `all`.\\n  _.every = _.all = function(obj, iterator, context) {\\n    iterator || (iterator = _.identity);\\n    var result = true;\\n    if (obj == null) return result;\\n    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);\\n    each(obj, function(value, index, list) {\\n      if (!(result = result && iterator.call(context, value, index, list))) return breaker;\\n    });\\n    return !!result;\\n  };\\n\\n  // Determine if at least one element in the object matches a truth test.\\n  // Delegates to **ECMAScript 5**'s native `some` if available.\\n  // Aliased as `any`.\\n  var any = _.some = _.any = function(obj, iterator, context) {\\n    iterator || (iterator = _.identity);\\n    var result = false;\\n    if (obj == null) return result;\\n    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);\\n    each(obj, function(value, index, list) {\\n      if (result || (result = iterator.call(context, value, index, list))) return breaker;\\n    });\\n    return !!result;\\n  };\\n\\n  // Determine if the array or object contains a given value (using `===`).\\n  // Aliased as `include`.\\n  _.contains = _.include = function(obj, target) {\\n    if (obj == null) return false;\\n    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;\\n    return any(obj, function(value) {\\n      return value === target;\\n    });\\n  };\\n\\n  // Invoke a method (with arguments) on every item in a collection.\\n  _.invoke = function(obj, method) {\\n    var args = slice.call(arguments, 2);\\n    var isFunc = _.isFunction(method);\\n    return _.map(obj, function(value) {\\n      return (isFunc ? method : value[method]).apply(value, args);\\n    });\\n  };\\n\\n  // Convenience version of a common use case of `map`: fetching a property.\\n  _.pluck = function(obj, key) {\\n    return _.map(obj, function(value){ return value[key]; });\\n  };\\n\\n  // Convenience version of a common use case of `filter`: selecting only objects\\n  // containing specific `key:value` pairs.\\n  _.where = function(obj, attrs, first) {\\n    if (_.isEmpty(attrs)) return first ? null : [];\\n    return _[first ? 'find' : 'filter'](obj, function(value) {\\n      for (var key in attrs) {\\n        if (attrs[key] !== value[key]) return false;\\n      }\\n      return true;\\n    });\\n  };\\n\\n  // Convenience version of a common use case of `find`: getting the first object\\n  // containing specific `key:value` pairs.\\n  _.findWhere = function(obj, attrs) {\\n    return _.where(obj, attrs, true);\\n  };\\n\\n  // Return the maximum element or (element-based computation).\\n  // Can't optimize arrays of integers longer than 65,535 elements.\\n  // See: https://bugs.webkit.org/show_bug.cgi?id=80797\\n  _.max = function(obj, iterator, context) {\\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {\\n      return Math.max.apply(Math, obj);\\n    }\\n    if (!iterator && _.isEmpty(obj)) return -Infinity;\\n    var result = {computed : -Infinity, value: -Infinity};\\n    each(obj, function(value, index, list) {\\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\\n      computed >= result.computed && (result = {value : value, computed : computed});\\n    });\\n    return result.value;\\n  };\\n\\n  // Return the minimum element (or element-based computation).\\n  _.min = function(obj, iterator, context) {\\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {\\n      return Math.min.apply(Math, obj);\\n    }\\n    if (!iterator && _.isEmpty(obj)) return Infinity;\\n    var result = {computed : Infinity, value: Infinity};\\n    each(obj, function(value, index, list) {\\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\\n      computed < result.computed && (result = {value : value, computed : computed});\\n    });\\n    return result.value;\\n  };\\n\\n  // Shuffle an array.\\n  _.shuffle = function(obj) {\\n    var rand;\\n    var index = 0;\\n    var shuffled = [];\\n    each(obj, function(value) {\\n      rand = _.random(index++);\\n      shuffled[index - 1] = shuffled[rand];\\n      shuffled[rand] = value;\\n    });\\n    return shuffled;\\n  };\\n\\n  // An internal function to generate lookup iterators.\\n  var lookupIterator = function(value) {\\n    return _.isFunction(value) ? value : function(obj){ return obj[value]; };\\n  };\\n\\n  // Sort the object's values by a criterion produced by an iterator.\\n  _.sortBy = function(obj, value, context) {\\n    var iterator = lookupIterator(value);\\n    return _.pluck(_.map(obj, function(value, index, list) {\\n      return {\\n        value : value,\\n        index : index,\\n        criteria : iterator.call(context, value, index, list)\\n      };\\n    }).sort(function(left, right) {\\n      var a = left.criteria;\\n      var b = right.criteria;\\n      if (a !== b) {\\n        if (a > b || a === void 0) return 1;\\n        if (a < b || b === void 0) return -1;\\n      }\\n      return left.index < right.index ? -1 : 1;\\n    }), 'value');\\n  };\\n\\n  // An internal function used for aggregate \\\"group by\\\" operations.\\n  var group = function(obj, value, context, behavior) {\\n    var result = {};\\n    var iterator = lookupIterator(value || _.identity);\\n    each(obj, function(value, index) {\\n      var key = iterator.call(context, value, index, obj);\\n      behavior(result, key, value);\\n    });\\n    return result;\\n  };\\n\\n  // Groups the object's values by a criterion. Pass either a string attribute\\n  // to group by, or a function that returns the criterion.\\n  _.groupBy = function(obj, value, context) {\\n    return group(obj, value, context, function(result, key, value) {\\n      (_.has(result, key) ? result[key] : (result[key] = [])).push(value);\\n    });\\n  };\\n\\n  // Counts instances of an object that group by a certain criterion. Pass\\n  // either a string attribute to count by, or a function that returns the\\n  // criterion.\\n  _.countBy = function(obj, value, context) {\\n    return group(obj, value, context, function(result, key) {\\n      if (!_.has(result, key)) result[key] = 0;\\n      result[key]++;\\n    });\\n  };\\n\\n  // Use a comparator function to figure out the smallest index at which\\n  // an object should be inserted so as to maintain order. Uses binary search.\\n  _.sortedIndex = function(array, obj, iterator, context) {\\n    iterator = iterator == null ? _.identity : lookupIterator(iterator);\\n    var value = iterator.call(context, obj);\\n    var low = 0, high = array.length;\\n    while (low < high) {\\n      var mid = (low + high) >>> 1;\\n      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;\\n    }\\n    return low;\\n  };\\n\\n  // Safely convert anything iterable into a real, live array.\\n  _.toArray = function(obj) {\\n    if (!obj) return [];\\n    if (_.isArray(obj)) return slice.call(obj);\\n    if (obj.length === +obj.length) return _.map(obj, _.identity);\\n    return _.values(obj);\\n  };\\n\\n  // Return the number of elements in an object.\\n  _.size = function(obj) {\\n    if (obj == null) return 0;\\n    return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;\\n  };\\n\\n  // Array Functions\\n  // ---------------\\n\\n  // Get the first element of an array. Passing **n** will return the first N\\n  // values in the array. Aliased as `head` and `take`. The **guard** check\\n  // allows it to work with `_.map`.\\n  _.first = _.head = _.take = function(array, n, guard) {\\n    if (array == null) return void 0;\\n    return (n != null) && !guard ? slice.call(array, 0, n) : array[0];\\n  };\\n\\n  // Returns everything but the last entry of the array. Especially useful on\\n  // the arguments object. Passing **n** will return all the values in\\n  // the array, excluding the last N. The **guard** check allows it to work with\\n  // `_.map`.\\n  _.initial = function(array, n, guard) {\\n    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));\\n  };\\n\\n  // Get the last element of an array. Passing **n** will return the last N\\n  // values in the array. The **guard** check allows it to work with `_.map`.\\n  _.last = function(array, n, guard) {\\n    if (array == null) return void 0;\\n    if ((n != null) && !guard) {\\n      return slice.call(array, Math.max(array.length - n, 0));\\n    } else {\\n      return array[array.length - 1];\\n    }\\n  };\\n\\n  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.\\n  // Especially useful on the arguments object. Passing an **n** will return\\n  // the rest N values in the array. The **guard**\\n  // check allows it to work with `_.map`.\\n  _.rest = _.tail = _.drop = function(array, n, guard) {\\n    return slice.call(array, (n == null) || guard ? 1 : n);\\n  };\\n\\n  // Trim out all falsy values from an array.\\n  _.compact = function(array) {\\n    return _.filter(array, _.identity);\\n  };\\n\\n  // Internal implementation of a recursive `flatten` function.\\n  var flatten = function(input, shallow, output) {\\n    each(input, function(value) {\\n      if (_.isArray(value)) {\\n        shallow ? push.apply(output, value) : flatten(value, shallow, output);\\n      } else {\\n        output.push(value);\\n      }\\n    });\\n    return output;\\n  };\\n\\n  // Return a completely flattened version of an array.\\n  _.flatten = function(array, shallow) {\\n    return flatten(array, shallow, []);\\n  };\\n\\n  // Return a version of the array that does not contain the specified value(s).\\n  _.without = function(array) {\\n    return _.difference(array, slice.call(arguments, 1));\\n  };\\n\\n  // Produce a duplicate-free version of the array. If the array has already\\n  // been sorted, you have the option of using a faster algorithm.\\n  // Aliased as `unique`.\\n  _.uniq = _.unique = function(array, isSorted, iterator, context) {\\n    if (_.isFunction(isSorted)) {\\n      context = iterator;\\n      iterator = isSorted;\\n      isSorted = false;\\n    }\\n    var initial = iterator ? _.map(array, iterator, context) : array;\\n    var results = [];\\n    var seen = [];\\n    each(initial, function(value, index) {\\n      if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {\\n        seen.push(value);\\n        results.push(array[index]);\\n      }\\n    });\\n    return results;\\n  };\\n\\n  // Produce an array that contains the union: each distinct element from all of\\n  // the passed-in arrays.\\n  _.union = function() {\\n    return _.uniq(concat.apply(ArrayProto, arguments));\\n  };\\n\\n  // Produce an array that contains every item shared between all the\\n  // passed-in arrays.\\n  _.intersection = function(array) {\\n    var rest = slice.call(arguments, 1);\\n    return _.filter(_.uniq(array), function(item) {\\n      return _.every(rest, function(other) {\\n        return _.indexOf(other, item) >= 0;\\n      });\\n    });\\n  };\\n\\n  // Take the difference between one array and a number of other arrays.\\n  // Only the elements present in just the first array will remain.\\n  _.difference = function(array) {\\n    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));\\n    return _.filter(array, function(value){ return !_.contains(rest, value); });\\n  };\\n\\n  // Zip together multiple lists into a single array -- elements that share\\n  // an index go together.\\n  _.zip = function() {\\n    var args = slice.call(arguments);\\n    var length = _.max(_.pluck(args, 'length'));\\n    var results = new Array(length);\\n    for (var i = 0; i < length; i++) {\\n      results[i] = _.pluck(args, \\\"\\\" + i);\\n    }\\n    return results;\\n  };\\n\\n  // Converts lists into objects. Pass either a single array of `[key, value]`\\n  // pairs, or two parallel arrays of the same length -- one of keys, and one of\\n  // the corresponding values.\\n  _.object = function(list, values) {\\n    if (list == null) return {};\\n    var result = {};\\n    for (var i = 0, l = list.length; i < l; i++) {\\n      if (values) {\\n        result[list[i]] = values[i];\\n      } else {\\n        result[list[i][0]] = list[i][1];\\n      }\\n    }\\n    return result;\\n  };\\n\\n  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),\\n  // we need this function. Return the position of the first occurrence of an\\n  // item in an array, or -1 if the item is not included in the array.\\n  // Delegates to **ECMAScript 5**'s native `indexOf` if available.\\n  // If the array is large and already in sort order, pass `true`\\n  // for **isSorted** to use binary search.\\n  _.indexOf = function(array, item, isSorted) {\\n    if (array == null) return -1;\\n    var i = 0, l = array.length;\\n    if (isSorted) {\\n      if (typeof isSorted == 'number') {\\n        i = (isSorted < 0 ? Math.max(0, l + isSorted) : isSorted);\\n      } else {\\n        i = _.sortedIndex(array, item);\\n        return array[i] === item ? i : -1;\\n      }\\n    }\\n    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);\\n    for (; i < l; i++) if (array[i] === item) return i;\\n    return -1;\\n  };\\n\\n  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.\\n  _.lastIndexOf = function(array, item, from) {\\n    if (array == null) return -1;\\n    var hasIndex = from != null;\\n    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {\\n      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);\\n    }\\n    var i = (hasIndex ? from : array.length);\\n    while (i--) if (array[i] === item) return i;\\n    return -1;\\n  };\\n\\n  // Generate an integer Array containing an arithmetic progression. A port of\\n  // the native Python `range()` function. See\\n  // [the Python documentation](http://docs.python.org/library/functions.html#range).\\n  _.range = function(start, stop, step) {\\n    if (arguments.length <= 1) {\\n      stop = start || 0;\\n      start = 0;\\n    }\\n    step = arguments[2] || 1;\\n\\n    var len = Math.max(Math.ceil((stop - start) / step), 0);\\n    var idx = 0;\\n    var range = new Array(len);\\n\\n    while(idx < len) {\\n      range[idx++] = start;\\n      start += step;\\n    }\\n\\n    return range;\\n  };\\n\\n  // Function (ahem) Functions\\n  // ------------------\\n\\n  // Create a function bound to a given object (assigning `this`, and arguments,\\n  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if\\n  // available.\\n  _.bind = function(func, context) {\\n    if (func.bind === nativeBind && nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));\\n    var args = slice.call(arguments, 2);\\n    return function() {\\n      return func.apply(context, args.concat(slice.call(arguments)));\\n    };\\n  };\\n\\n  // Partially apply a function by creating a version that has had some of its\\n  // arguments pre-filled, without changing its dynamic `this` context.\\n  _.partial = function(func) {\\n    var args = slice.call(arguments, 1);\\n    return function() {\\n      return func.apply(this, args.concat(slice.call(arguments)));\\n    };\\n  };\\n\\n  // Bind all of an object's methods to that object. Useful for ensuring that\\n  // all callbacks defined on an object belong to it.\\n  _.bindAll = function(obj) {\\n    var funcs = slice.call(arguments, 1);\\n    if (funcs.length === 0) funcs = _.functions(obj);\\n    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });\\n    return obj;\\n  };\\n\\n  // Memoize an expensive function by storing its results.\\n  _.memoize = function(func, hasher) {\\n    var memo = {};\\n    hasher || (hasher = _.identity);\\n    return function() {\\n      var key = hasher.apply(this, arguments);\\n      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));\\n    };\\n  };\\n\\n  // Delays a function for the given number of milliseconds, and then calls\\n  // it with the arguments supplied.\\n  _.delay = function(func, wait) {\\n    var args = slice.call(arguments, 2);\\n    return setTimeout(function(){ return func.apply(null, args); }, wait);\\n  };\\n\\n  // Defers a function, scheduling it to run after the current call stack has\\n  // cleared.\\n  _.defer = function(func) {\\n    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));\\n  };\\n\\n  // Returns a function, that, when invoked, will only be triggered at most once\\n  // during a given window of time.\\n  _.throttle = function(func, wait) {\\n    var context, args, timeout, result;\\n    var previous = 0;\\n    var later = function() {\\n      previous = new Date;\\n      timeout = null;\\n      result = func.apply(context, args);\\n    };\\n    return function() {\\n      var now = new Date;\\n      var remaining = wait - (now - previous);\\n      context = this;\\n      args = arguments;\\n      if (remaining <= 0) {\\n        clearTimeout(timeout);\\n        timeout = null;\\n        previous = now;\\n        result = func.apply(context, args);\\n      } else if (!timeout) {\\n        timeout = setTimeout(later, remaining);\\n      }\\n      return result;\\n    };\\n  };\\n\\n  // Returns a function, that, as long as it continues to be invoked, will not\\n  // be triggered. The function will be called after it stops being called for\\n  // N milliseconds. If `immediate` is passed, trigger the function on the\\n  // leading edge, instead of the trailing.\\n  _.debounce = function(func, wait, immediate) {\\n    var timeout, result;\\n    return function() {\\n      var context = this, args = arguments;\\n      var later = function() {\\n        timeout = null;\\n        if (!immediate) result = func.apply(context, args);\\n      };\\n      var callNow = immediate && !timeout;\\n      clearTimeout(timeout);\\n      timeout = setTimeout(later, wait);\\n      if (callNow) result = func.apply(context, args);\\n      return result;\\n    };\\n  };\\n\\n  // Returns a function that will be executed at most one time, no matter how\\n  // often you call it. Useful for lazy initialization.\\n  _.once = function(func) {\\n    var ran = false, memo;\\n    return function() {\\n      if (ran) return memo;\\n      ran = true;\\n      memo = func.apply(this, arguments);\\n      func = null;\\n      return memo;\\n    };\\n  };\\n\\n  // Returns the first function passed as an argument to the second,\\n  // allowing you to adjust arguments, run code before and after, and\\n  // conditionally execute the original function.\\n  _.wrap = function(func, wrapper) {\\n    return function() {\\n      var args = [func];\\n      push.apply(args, arguments);\\n      return wrapper.apply(this, args);\\n    };\\n  };\\n\\n  // Returns a function that is the composition of a list of functions, each\\n  // consuming the return value of the function that follows.\\n  _.compose = function() {\\n    var funcs = arguments;\\n    return function() {\\n      var args = arguments;\\n      for (var i = funcs.length - 1; i >= 0; i--) {\\n        args = [funcs[i].apply(this, args)];\\n      }\\n      return args[0];\\n    };\\n  };\\n\\n  // Returns a function that will only be executed after being called N times.\\n  _.after = function(times, func) {\\n    if (times <= 0) return func();\\n    return function() {\\n      if (--times < 1) {\\n        return func.apply(this, arguments);\\n      }\\n    };\\n  };\\n\\n  // Object Functions\\n  // ----------------\\n\\n  // Retrieve the names of an object's properties.\\n  // Delegates to **ECMAScript 5**'s native `Object.keys`\\n  _.keys = nativeKeys || function(obj) {\\n    if (obj !== Object(obj)) throw new TypeError('Invalid object');\\n    var keys = [];\\n    for (var key in obj) if (_.has(obj, key)) keys[keys.length] = key;\\n    return keys;\\n  };\\n\\n  // Retrieve the values of an object's properties.\\n  _.values = function(obj) {\\n    var values = [];\\n    for (var key in obj) if (_.has(obj, key)) values.push(obj[key]);\\n    return values;\\n  };\\n\\n  // Convert an object into a list of `[key, value]` pairs.\\n  _.pairs = function(obj) {\\n    var pairs = [];\\n    for (var key in obj) if (_.has(obj, key)) pairs.push([key, obj[key]]);\\n    return pairs;\\n  };\\n\\n  // Invert the keys and values of an object. The values must be serializable.\\n  _.invert = function(obj) {\\n    var result = {};\\n    for (var key in obj) if (_.has(obj, key)) result[obj[key]] = key;\\n    return result;\\n  };\\n\\n  // Return a sorted list of the function names available on the object.\\n  // Aliased as `methods`\\n  _.functions = _.methods = function(obj) {\\n    var names = [];\\n    for (var key in obj) {\\n      if (_.isFunction(obj[key])) names.push(key);\\n    }\\n    return names.sort();\\n  };\\n\\n  // Extend a given object with all the properties in passed-in object(s).\\n  _.extend = function(obj) {\\n    each(slice.call(arguments, 1), function(source) {\\n      if (source) {\\n        for (var prop in source) {\\n          obj[prop] = source[prop];\\n        }\\n      }\\n    });\\n    return obj;\\n  };\\n\\n  // Return a copy of the object only containing the whitelisted properties.\\n  _.pick = function(obj) {\\n    var copy = {};\\n    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));\\n    each(keys, function(key) {\\n      if (key in obj) copy[key] = obj[key];\\n    });\\n    return copy;\\n  };\\n\\n   // Return a copy of the object without the blacklisted properties.\\n  _.omit = function(obj) {\\n    var copy = {};\\n    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));\\n    for (var key in obj) {\\n      if (!_.contains(keys, key)) copy[key] = obj[key];\\n    }\\n    return copy;\\n  };\\n\\n  // Fill in a given object with default properties.\\n  _.defaults = function(obj) {\\n    each(slice.call(arguments, 1), function(source) {\\n      if (source) {\\n        for (var prop in source) {\\n          if (obj[prop] == null) obj[prop] = source[prop];\\n        }\\n      }\\n    });\\n    return obj;\\n  };\\n\\n  // Create a (shallow-cloned) duplicate of an object.\\n  _.clone = function(obj) {\\n    if (!_.isObject(obj)) return obj;\\n    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);\\n  };\\n\\n  // Invokes interceptor with the obj, and then returns obj.\\n  // The primary purpose of this method is to \\\"tap into\\\" a method chain, in\\n  // order to perform operations on intermediate results within the chain.\\n  _.tap = function(obj, interceptor) {\\n    interceptor(obj);\\n    return obj;\\n  };\\n\\n  // Internal recursive comparison function for `isEqual`.\\n  var eq = function(a, b, aStack, bStack) {\\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\\n    // See the Harmony `egal` proposal: http://wiki.ecmascript.org/doku.php?id=harmony:egal.\\n    if (a === b) return a !== 0 || 1 / a == 1 / b;\\n    // A strict comparison is necessary because `null == undefined`.\\n    if (a == null || b == null) return a === b;\\n    // Unwrap any wrapped objects.\\n    if (a instanceof _) a = a._wrapped;\\n    if (b instanceof _) b = b._wrapped;\\n    // Compare `[[Class]]` names.\\n    var className = toString.call(a);\\n    if (className != toString.call(b)) return false;\\n    switch (className) {\\n      // Strings, numbers, dates, and booleans are compared by value.\\n      case '[object String]':\\n        // Primitives and their corresponding object wrappers are equivalent; thus, `\\\"5\\\"` is\\n        // equivalent to `new String(\\\"5\\\")`.\\n        return a == String(b);\\n      case '[object Number]':\\n        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for\\n        // other numeric values.\\n        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);\\n      case '[object Date]':\\n      case '[object Boolean]':\\n        // Coerce dates and booleans to numeric primitive values. Dates are compared by their\\n        // millisecond representations. Note that invalid dates with millisecond representations\\n        // of `NaN` are not equivalent.\\n        return +a == +b;\\n      // RegExps are compared by their source patterns and flags.\\n      case '[object RegExp]':\\n        return a.source == b.source &&\\n               a.global == b.global &&\\n               a.multiline == b.multiline &&\\n               a.ignoreCase == b.ignoreCase;\\n    }\\n    if (typeof a != 'object' || typeof b != 'object') return false;\\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic\\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\\n    var length = aStack.length;\\n    while (length--) {\\n      // Linear search. Performance is inversely proportional to the number of\\n      // unique nested structures.\\n      if (aStack[length] == a) return bStack[length] == b;\\n    }\\n    // Add the first object to the stack of traversed objects.\\n    aStack.push(a);\\n    bStack.push(b);\\n    var size = 0, result = true;\\n    // Recursively compare objects and arrays.\\n    if (className == '[object Array]') {\\n      // Compare array lengths to determine if a deep comparison is necessary.\\n      size = a.length;\\n      result = size == b.length;\\n      if (result) {\\n        // Deep compare the contents, ignoring non-numeric properties.\\n        while (size--) {\\n          if (!(result = eq(a[size], b[size], aStack, bStack))) break;\\n        }\\n      }\\n    } else {\\n      // Objects with different constructors are not equivalent, but `Object`s\\n      // from different frames are.\\n      var aCtor = a.constructor, bCtor = b.constructor;\\n      if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&\\n                               _.isFunction(bCtor) && (bCtor instanceof bCtor))) {\\n        return false;\\n      }\\n      // Deep compare objects.\\n      for (var key in a) {\\n        if (_.has(a, key)) {\\n          // Count the expected number of properties.\\n          size++;\\n          // Deep compare each member.\\n          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;\\n        }\\n      }\\n      // Ensure that both objects contain the same number of properties.\\n      if (result) {\\n        for (key in b) {\\n          if (_.has(b, key) && !(size--)) break;\\n        }\\n        result = !size;\\n      }\\n    }\\n    // Remove the first object from the stack of traversed objects.\\n    aStack.pop();\\n    bStack.pop();\\n    return result;\\n  };\\n\\n  // Perform a deep comparison to check if two objects are equal.\\n  _.isEqual = function(a, b) {\\n    return eq(a, b, [], []);\\n  };\\n\\n  // Is a given array, string, or object empty?\\n  // An \\\"empty\\\" object has no enumerable own-properties.\\n  _.isEmpty = function(obj) {\\n    if (obj == null) return true;\\n    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;\\n    for (var key in obj) if (_.has(obj, key)) return false;\\n    return true;\\n  };\\n\\n  // Is a given value a DOM element?\\n  _.isElement = function(obj) {\\n    return !!(obj && obj.nodeType === 1);\\n  };\\n\\n  // Is a given value an array?\\n  // Delegates to ECMA5's native Array.isArray\\n  _.isArray = nativeIsArray || function(obj) {\\n    return toString.call(obj) == '[object Array]';\\n  };\\n\\n  // Is a given variable an object?\\n  _.isObject = function(obj) {\\n    return obj === Object(obj);\\n  };\\n\\n  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.\\n  each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {\\n    _['is' + name] = function(obj) {\\n      return toString.call(obj) == '[object ' + name + ']';\\n    };\\n  });\\n\\n  // Define a fallback version of the method in browsers (ahem, IE), where\\n  // there isn't any inspectable \\\"Arguments\\\" type.\\n  if (!_.isArguments(arguments)) {\\n    _.isArguments = function(obj) {\\n      return !!(obj && _.has(obj, 'callee'));\\n    };\\n  }\\n\\n  // Optimize `isFunction` if appropriate.\\n  if (typeof (/./) !== 'function') {\\n    _.isFunction = function(obj) {\\n      return typeof obj === 'function';\\n    };\\n  }\\n\\n  // Is a given object a finite number?\\n  _.isFinite = function(obj) {\\n    return isFinite(obj) && !isNaN(parseFloat(obj));\\n  };\\n\\n  // Is the given value `NaN`? (NaN is the only number which does not equal itself).\\n  _.isNaN = function(obj) {\\n    return _.isNumber(obj) && obj != +obj;\\n  };\\n\\n  // Is a given value a boolean?\\n  _.isBoolean = function(obj) {\\n    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\\n  };\\n\\n  // Is a given value equal to null?\\n  _.isNull = function(obj) {\\n    return obj === null;\\n  };\\n\\n  // Is a given variable undefined?\\n  _.isUndefined = function(obj) {\\n    return obj === void 0;\\n  };\\n\\n  // Shortcut function for checking if an object has a given property directly\\n  // on itself (in other words, not on a prototype).\\n  _.has = function(obj, key) {\\n    return hasOwnProperty.call(obj, key);\\n  };\\n\\n  // Utility Functions\\n  // -----------------\\n\\n  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its\\n  // previous owner. Returns a reference to the Underscore object.\\n  _.noConflict = function() {\\n    root._ = previousUnderscore;\\n    return this;\\n  };\\n\\n  // Keep the identity function around for default iterators.\\n  _.identity = function(value) {\\n    return value;\\n  };\\n\\n  // Run a function **n** times.\\n  _.times = function(n, iterator, context) {\\n    var accum = Array(n);\\n    for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);\\n    return accum;\\n  };\\n\\n  // Return a random integer between min and max (inclusive).\\n  _.random = function(min, max) {\\n    if (max == null) {\\n      max = min;\\n      min = 0;\\n    }\\n    return min + Math.floor(Math.random() * (max - min + 1));\\n  };\\n\\n  // List of HTML entities for escaping.\\n  var entityMap = {\\n    escape: {\\n      '&': '&amp;',\\n      '<': '&lt;',\\n      '>': '&gt;',\\n      '\\\"': '&quot;',\\n      \\\"'\\\": '&#x27;',\\n      '/': '&#x2F;'\\n    }\\n  };\\n  entityMap.unescape = _.invert(entityMap.escape);\\n\\n  // Regexes containing the keys and values listed immediately above.\\n  var entityRegexes = {\\n    escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),\\n    unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')\\n  };\\n\\n  // Functions for escaping and unescaping strings to/from HTML interpolation.\\n  _.each(['escape', 'unescape'], function(method) {\\n    _[method] = function(string) {\\n      if (string == null) return '';\\n      return ('' + string).replace(entityRegexes[method], function(match) {\\n        return entityMap[method][match];\\n      });\\n    };\\n  });\\n\\n  // If the value of the named property is a function then invoke it;\\n  // otherwise, return it.\\n  _.result = function(object, property) {\\n    if (object == null) return null;\\n    var value = object[property];\\n    return _.isFunction(value) ? value.call(object) : value;\\n  };\\n\\n  // Add your own custom functions to the Underscore object.\\n  _.mixin = function(obj) {\\n    each(_.functions(obj), function(name){\\n      var func = _[name] = obj[name];\\n      _.prototype[name] = function() {\\n        var args = [this._wrapped];\\n        push.apply(args, arguments);\\n        return result.call(this, func.apply(_, args));\\n      };\\n    });\\n  };\\n\\n  // Generate a unique integer id (unique within the entire client session).\\n  // Useful for temporary DOM ids.\\n  var idCounter = 0;\\n  _.uniqueId = function(prefix) {\\n    var id = ++idCounter + '';\\n    return prefix ? prefix + id : id;\\n  };\\n\\n  // By default, Underscore uses ERB-style template delimiters, change the\\n  // following template settings to use alternative delimiters.\\n  _.templateSettings = {\\n    evaluate    : /<%([\\\\s\\\\S]+?)%>/g,\\n    interpolate : /<%=([\\\\s\\\\S]+?)%>/g,\\n    escape      : /<%-([\\\\s\\\\S]+?)%>/g\\n  };\\n\\n  // When customizing `templateSettings`, if you don't want to define an\\n  // interpolation, evaluation or escaping regex, we need one that is\\n  // guaranteed not to match.\\n  var noMatch = /(.)^/;\\n\\n  // Certain characters need to be escaped so that they can be put into a\\n  // string literal.\\n  var escapes = {\\n    \\\"'\\\":      \\\"'\\\",\\n    '\\\\\\\\':     '\\\\\\\\',\\n    '\\\\r':     'r',\\n    '\\\\n':     'n',\\n    '\\\\t':     't',\\n    '\\\\u2028': 'u2028',\\n    '\\\\u2029': 'u2029'\\n  };\\n\\n  var escaper = /\\\\\\\\|'|\\\\r|\\\\n|\\\\t|\\\\u2028|\\\\u2029/g;\\n\\n  // JavaScript micro-templating, similar to John Resig's implementation.\\n  // Underscore templating handles arbitrary delimiters, preserves whitespace,\\n  // and correctly escapes quotes within interpolated code.\\n  _.template = function(text, data, settings) {\\n    var render;\\n    settings = _.defaults({}, settings, _.templateSettings);\\n\\n    // Combine delimiters into one regular expression via alternation.\\n    var matcher = new RegExp([\\n      (settings.escape || noMatch).source,\\n      (settings.interpolate || noMatch).source,\\n      (settings.evaluate || noMatch).source\\n    ].join('|') + '|$', 'g');\\n\\n    // Compile the template source, escaping string literals appropriately.\\n    var index = 0;\\n    var source = \\\"__p+='\\\";\\n    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {\\n      source += text.slice(index, offset)\\n        .replace(escaper, function(match) { return '\\\\\\\\' + escapes[match]; });\\n\\n      if (escape) {\\n        source += \\\"'+\\\\n((__t=(\\\" + escape + \\\"))==null?'':_.escape(__t))+\\\\n'\\\";\\n      }\\n      if (interpolate) {\\n        source += \\\"'+\\\\n((__t=(\\\" + interpolate + \\\"))==null?'':__t)+\\\\n'\\\";\\n      }\\n      if (evaluate) {\\n        source += \\\"';\\\\n\\\" + evaluate + \\\"\\\\n__p+='\\\";\\n      }\\n      index = offset + match.length;\\n      return match;\\n    });\\n    source += \\\"';\\\\n\\\";\\n\\n    // If a variable is not specified, place data values in local scope.\\n    if (!settings.variable) source = 'with(obj||{}){\\\\n' + source + '}\\\\n';\\n\\n    source = \\\"var __t,__p='',__j=Array.prototype.join,\\\" +\\n      \\\"print=function(){__p+=__j.call(arguments,'');};\\\\n\\\" +\\n      source + \\\"return __p;\\\\n\\\";\\n\\n    try {\\n      render = new Function(settings.variable || 'obj', '_', source);\\n    } catch (e) {\\n      e.source = source;\\n      throw e;\\n    }\\n\\n    if (data) return render(data, _);\\n    var template = function(data) {\\n      return render.call(this, data, _);\\n    };\\n\\n    // Provide the compiled function source as a convenience for precompilation.\\n    template.source = 'function(' + (settings.variable || 'obj') + '){\\\\n' + source + '}';\\n\\n    return template;\\n  };\\n\\n  // Add a \\\"chain\\\" function, which will delegate to the wrapper.\\n  _.chain = function(obj) {\\n    return _(obj).chain();\\n  };\\n\\n  // OOP\\n  // ---------------\\n  // If Underscore is called as a function, it returns a wrapped object that\\n  // can be used OO-style. This wrapper holds altered versions of all the\\n  // underscore functions. Wrapped objects may be chained.\\n\\n  // Helper function to continue chaining intermediate results.\\n  var result = function(obj) {\\n    return this._chain ? _(obj).chain() : obj;\\n  };\\n\\n  // Add all of the Underscore functions to the wrapper object.\\n  _.mixin(_);\\n\\n  // Add all mutator Array functions to the wrapper.\\n  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {\\n    var method = ArrayProto[name];\\n    _.prototype[name] = function() {\\n      var obj = this._wrapped;\\n      method.apply(obj, arguments);\\n      if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];\\n      return result.call(this, obj);\\n    };\\n  });\\n\\n  // Add all accessor Array functions to the wrapper.\\n  each(['concat', 'join', 'slice'], function(name) {\\n    var method = ArrayProto[name];\\n    _.prototype[name] = function() {\\n      return result.call(this, method.apply(this._wrapped, arguments));\\n    };\\n  });\\n\\n  _.extend(_.prototype, {\\n\\n    // Start chaining a wrapped Underscore object.\\n    chain: function() {\\n      this._chain = true;\\n      return this;\\n    },\\n\\n    // Extracts the result from a wrapped and chained object.\\n    value: function() {\\n      return this._wrapped;\\n    }\\n\\n  });\\n\\n}).call(this);\\n\\n/*global _: false, $: false, localStorage: false, process: true,\\n  XMLHttpRequest: false, XDomainRequest: false, exports: false,\\n  require: false, setTimeout: true */\\n(function(root) {\\n  root.Parse = root.Parse || {};\\n  /**\\n   * Contains all Parse API classes and functions.\\n   * @name Parse\\n   * @namespace\\n   *\\n   * Contains all Parse API classes and functions.\\n   */\\n  var Parse = root.Parse;\\n\\n  var req = typeof(require) === 'function' ? require : null;\\n  // Load references to other dependencies\\n  if (typeof(XMLHttpRequest) !== 'undefined') {\\n    Parse.XMLHttpRequest = XMLHttpRequest;\\n  } else if (typeof(require) === 'function' &&\\n      typeof(require.ensure) === 'undefined') {\\n    Parse.XMLHttpRequest = req('xmlhttprequest').XMLHttpRequest;\\n  }\\n  // Import Parse's local copy of underscore.\\n  if (typeof(exports) !== 'undefined' && exports._) {\\n    // We're running in a CommonJS environment\\n    Parse._ = exports._.noConflict();\\n    exports.Parse = Parse;\\n  } else {\\n    Parse._ = _.noConflict();\\n  }\\n\\n  // If jQuery or Zepto has been included, grab a reference to it.\\n  if (typeof($) !== \\\"undefined\\\") {\\n    Parse.$ = $;\\n  }\\n\\n  // Helpers\\n  // -------\\n\\n  // Shared empty constructor function to aid in prototype-chain creation.\\n  var EmptyConstructor = function() {};\\n\\n  // TODO: fix this so that ParseObjects aren't all called \\\"child\\\" in debugger.\\n  // Helper function to correctly set up the prototype chain, for subclasses.\\n  // Similar to `goog.inherits`, but uses a hash of prototype properties and\\n  // class properties to be extended.\\n  var inherits = function(parent, protoProps, staticProps) {\\n    var child;\\n\\n    // The constructor function for the new subclass is either defined by you\\n    // (the \\\"constructor\\\" property in your `extend` definition), or defaulted\\n    // by us to simply call the parent's constructor.\\n    if (protoProps && protoProps.hasOwnProperty('constructor')) {\\n      child = protoProps.constructor;\\n    } else {\\n      /** @ignore */\\n      child = function(){ parent.apply(this, arguments); };\\n    }\\n\\n    // Inherit class (static) properties from parent.\\n    Parse._.extend(child, parent);\\n\\n    // Set the prototype chain to inherit from `parent`, without calling\\n    // `parent`'s constructor function.\\n    EmptyConstructor.prototype = parent.prototype;\\n    child.prototype = new EmptyConstructor();\\n\\n    // Add prototype properties (instance properties) to the subclass,\\n    // if supplied.\\n    if (protoProps) {\\n      Parse._.extend(child.prototype, protoProps);\\n    }\\n\\n    // Add static properties to the constructor function, if supplied.\\n    if (staticProps) {\\n      Parse._.extend(child, staticProps);\\n    }\\n\\n    // Correctly set child's `prototype.constructor`.\\n    child.prototype.constructor = child;\\n\\n    // Set a convenience property in case the parent's prototype is\\n    // needed later.\\n    child.__super__ = parent.prototype;\\n\\n    return child;\\n  };\\n\\n  // Set the server for Parse to talk to.\\n  Parse.serverURL = \\\"https://api.parse.com\\\";\\n\\n  // Check whether we are running in Node.js.\\n  if (typeof(process) !== \\\"undefined\\\" &&\\n      process.versions &&\\n      process.versions.node) {\\n    Parse._isNode = true;\\n  }\\n\\n  /**\\n   * Call this method first to set up your authentication tokens for Parse.\\n   * You can get your keys from the Data Browser on parse.com.\\n   * @param {String} applicationId Your Parse Application ID.\\n   * @param {String} javaScriptKey Your Parse JavaScript Key.\\n   * @param {String} masterKey (optional) Your Parse Master Key. (Node.js only!)\\n   */\\n  Parse.initialize = function(applicationId, javaScriptKey, masterKey) {\\n    if (masterKey) {\\n      throw \\\"Parse.initialize() was passed a Master Key, which is only \\\" +\\n        \\\"allowed from within Node.js.\\\";\\n    }\\n    Parse._initialize(applicationId, javaScriptKey);\\n  };\\n\\n  /**\\n   * Call this method first to set up master authentication tokens for Parse.\\n   * This method is for Parse's own private use.\\n   * @param {String} applicationId Your Parse Application ID.\\n   * @param {String} javaScriptKey Your Parse JavaScript Key.\\n   * @param {String} masterKey Your Parse Master Key.\\n   */\\n  Parse._initialize = function(applicationId, javaScriptKey, masterKey) {\\n    Parse.applicationId = applicationId;\\n    Parse.javaScriptKey = javaScriptKey;\\n    Parse.masterKey = masterKey;\\n    Parse._useMasterKey = false;\\n  };\\n\\n  // If we're running in node.js, allow using the master key.\\n  if (Parse._isNode) {\\n    Parse.initialize = Parse._initialize;\\n\\n    Parse.Cloud = Parse.Cloud || {};\\n    /**\\n     * Switches the Parse SDK to using the Master key.  The Master key grants\\n     * priveleged access to the data in Parse and can be used to bypass ACLs and\\n     * other restrictions that are applied to the client SDKs.\\n     * <p><strong><em>Available in Cloud Code and Node.js only.</em></strong>\\n     * </p>\\n     */\\n    Parse.Cloud.useMasterKey = function() {\\n      Parse._useMasterKey = true;\\n    };\\n  }\\n\\n  /**\\n   * Returns prefix for Storage keys used by this instance of Parse.\\n   * @param {String} path The relative suffix to append to it.\\n   *     null or undefined is treated as the empty string.\\n   * @return {String} The full key name.\\n   */\\n  Parse._getParsePath = function(path) {\\n    if (!Parse.applicationId) {\\n      throw \\\"You need to call Parse.initialize before using Parse.\\\";\\n    }\\n    if (!path) {\\n      path = \\\"\\\";\\n    }\\n    if (!Parse._.isString(path)) {\\n      throw \\\"Tried to get a Storage path that wasn't a String.\\\";\\n    }\\n    if (path[0] === \\\"/\\\") {\\n      path = path.substring(1);\\n    }\\n    return \\\"Parse/\\\" + Parse.applicationId + \\\"/\\\" + path;\\n  };\\n\\n  /**\\n   * Returns a Promise that is resolved with the unique string for this app on\\n   * this machine.\\n   * Gets reset when Storage is cleared.\\n   */\\n  Parse._installationId = null;\\n  Parse._getInstallationId = function() {\\n    // See if it's cached in RAM.\\n    if (Parse._installationId) {\\n      return Parse.Promise.as(Parse._installationId);\\n    }\\n\\n    // Try to get it from Storage.\\n    var path = Parse._getParsePath(\\\"installationId\\\");\\n    return (Parse.Storage.getItemAsync(path)\\n      .then(function(value) {\\n        Parse._installationId = value;\\n\\n        if (!Parse._installationId || Parse._installationId === \\\"\\\") {\\n          // It wasn't in Storage, so create a new one.\\n          var hexOctet = function() {\\n            return (\\n              Math.floor((1+Math.random())*0x10000).toString(16).substring(1)\\n            );\\n          };\\n          Parse._installationId = (\\n            hexOctet() + hexOctet() + \\\"-\\\" +\\n            hexOctet() + \\\"-\\\" +\\n            hexOctet() + \\\"-\\\" +\\n            hexOctet() + \\\"-\\\" +\\n            hexOctet() + hexOctet() + hexOctet());\\n          return Parse.Storage.setItemAsync(path, Parse._installationId);\\n        }\\n\\n        return Parse.Promise.as(Parse._installationId);\\n      })\\n    );\\n  };\\n\\n  Parse._parseDate = function(iso8601) {\\n    var regexp = new RegExp(\\n      \\\"^([0-9]{1,4})-([0-9]{1,2})-([0-9]{1,2})\\\" + \\\"T\\\" +\\n      \\\"([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2})\\\" +\\n      \\\"(.([0-9]+))?\\\" + \\\"Z$\\\");\\n    var match = regexp.exec(iso8601);\\n    if (!match) {\\n      return null;\\n    }\\n\\n    var year = match[1] || 0;\\n    var month = (match[2] || 1) - 1;\\n    var day = match[3] || 0;\\n    var hour = match[4] || 0;\\n    var minute = match[5] || 0;\\n    var second = match[6] || 0;\\n    var milli = match[8] || 0;\\n\\n    return new Date(Date.UTC(year, month, day, hour, minute, second, milli));\\n  };\\n\\n  Parse._ajaxIE8 = function(method, url, data) {\\n    var promise = new Parse.Promise();\\n    var xdr = new XDomainRequest();\\n    xdr.onload = function() {\\n      var response;\\n      try {\\n        response = JSON.parse(xdr.responseText);\\n      } catch (e) {\\n        promise.reject(e);\\n      }\\n      if (response) {\\n        promise.resolve(response);\\n      }\\n    };\\n    xdr.onerror = xdr.ontimeout = function() {\\n      // Let's fake a real error message.\\n      var fakeResponse = {\\n        responseText: JSON.stringify({\\n          code: Parse.Error.X_DOMAIN_REQUEST,\\n          error: \\\"IE's XDomainRequest does not supply error info.\\\"\\n        })\\n      };\\n      promise.reject(fakeResponse);\\n    };\\n    xdr.onprogress = function() {};\\n    xdr.open(method, url);\\n    xdr.send(data);\\n    return promise;\\n  };\\n\\n  Parse._useXDomainRequest = function() {\\n    if (typeof(XDomainRequest) !== \\\"undefined\\\") {\\n      // We're in IE 8+.\\n      if ('withCredentials' in new XMLHttpRequest()) {\\n        // We're in IE 10+.\\n        return false;\\n      }\\n      return true;\\n    }\\n    return false;\\n  };\\n\\n  // TODO(klimt): Get rid of success/error usage in website.\\n  Parse._ajax = function(method, url, data, success, error) {\\n    var options = {\\n      success: success,\\n      error: error\\n    };\\n\\n    if (Parse._useXDomainRequest()) {\\n      return Parse._ajaxIE8(method, url, data)._thenRunCallbacks(options);\\n    }\\n\\n    var promise = new Parse.Promise();\\n    var attempts = 0;\\n\\n    var dispatch = function() {\\n      var handled = false;\\n      var xhr = new Parse.XMLHttpRequest();\\n\\n      xhr.onreadystatechange = function() {\\n        if (xhr.readyState === 4) {\\n          if (handled) {\\n            return;\\n          }\\n          handled = true;\\n\\n          if (xhr.status >= 200 && xhr.status < 300) {\\n            var response;\\n            try {\\n              response = JSON.parse(xhr.responseText);\\n            } catch (e) {\\n              promise.reject(e);\\n            }\\n            if (response) {\\n              promise.resolve(response, xhr.status, xhr);\\n            }\\n          } else if (xhr.status >= 500) { // Retry on 5XX\\n            if (++attempts < 5) {\\n              // Exponentially-growing delay\\n              var delay = Math.round(\\n                Math.random() * 125 * Math.pow(2, attempts)\\n              );\\n              setTimeout(dispatch, delay);\\n            } else {\\n              // After 5 retries, fail\\n              promise.reject(xhr);\\n            }\\n          } else {\\n            promise.reject(xhr);\\n          }\\n        }\\n      };\\n\\n      xhr.open(method, url, true);\\n      xhr.setRequestHeader('Content-Type', 'text/plain');  // avoid pre-flight.\\n      if (Parse._isNode) {\\n        // Add a special user agent just for request from node.js.\\n        xhr.setRequestHeader(\\\"User-Agent\\\",\\n                             \\\"Parse/\\\" + Parse.VERSION +\\n                             \\\" (NodeJS \\\" + process.versions.node + \\\")\\\");\\n      }\\n      xhr.send(data);\\n    };\\n\\n    dispatch();\\n    return promise._thenRunCallbacks(options); \\n  };\\n\\n  // A self-propagating extend function.\\n  Parse._extend = function(protoProps, classProps) {\\n    var child = inherits(this, protoProps, classProps);\\n    child.extend = this.extend;\\n    return child;\\n  };\\n\\n  /**\\n   * Options:\\n   *   route: is classes, users, login, etc.\\n   *   objectId: null if there is no associated objectId.\\n   *   method: the http method for the REST API.\\n   *   dataObject: the payload as an object, or null if there is none.\\n   *   useMasterKey: overrides whether to use the master key if set.\\n   * @ignore\\n   */\\n  Parse._request = function(options) {\\n    var route = options.route;\\n    var className = options.className;\\n    var objectId = options.objectId;\\n    var method = options.method;\\n    var useMasterKey = options.useMasterKey;\\n    var sessionToken = options.sessionToken;\\n    var dataObject = options.data;\\n\\n    if (!Parse.applicationId) {\\n      throw \\\"You must specify your applicationId using Parse.initialize.\\\";\\n    }\\n\\n    if (!Parse.javaScriptKey && !Parse.masterKey) {\\n      throw \\\"You must specify a key using Parse.initialize.\\\";\\n    }\\n\\n    // TODO: We can remove this check later, but it's useful for development.\\n    if (route !== \\\"batch\\\" &&\\n        route !== \\\"classes\\\" &&\\n        route !== \\\"events\\\" &&\\n        route !== \\\"files\\\" &&\\n        route !== \\\"functions\\\" &&\\n        route !== \\\"login\\\" &&\\n        route !== \\\"logout\\\" &&\\n        route !== \\\"push\\\" &&\\n        route !== \\\"requestPasswordReset\\\" &&\\n        route !== \\\"rest_verify_analytics\\\" &&\\n        route !== \\\"users\\\" &&\\n        route !== \\\"jobs\\\" &&\\n        route !== \\\"config\\\" &&\\n        route !== \\\"sessions\\\" &&\\n        route !== \\\"upgradeToRevocableSession\\\") {\\n      throw \\\"Bad route: '\\\" + route + \\\"'.\\\";\\n    }\\n\\n    var url = Parse.serverURL;\\n    if (url.charAt(url.length - 1) !== \\\"/\\\") {\\n      url += \\\"/\\\";\\n    }\\n    url += \\\"1/\\\" + route;\\n    if (className) {\\n      url += \\\"/\\\" + className;\\n    }\\n    if (objectId) {\\n      url += \\\"/\\\" + objectId;\\n    }\\n\\n    dataObject = Parse._.clone(dataObject || {});\\n    if (method !== \\\"POST\\\") {\\n      dataObject._method = method;\\n      method = \\\"POST\\\";\\n    }\\n\\n    if (Parse._.isUndefined(useMasterKey)) {\\n      useMasterKey = Parse._useMasterKey;\\n    }\\n\\n    dataObject._ApplicationId = Parse.applicationId;\\n    if (!useMasterKey) {\\n      dataObject._JavaScriptKey = Parse.javaScriptKey;\\n    } else if (!Parse.masterKey) {\\n      throw new Error('Cannot use the Master Key, it has not been provided.');\\n    } else {\\n      dataObject._MasterKey = Parse.masterKey;\\n    }\\n\\n    dataObject._ClientVersion = Parse.VERSION;\\n\\n    return Parse._getInstallationId().then(function(iid) {\\n      dataObject._InstallationId = iid;\\n\\n      if (sessionToken) {\\n        return Parse.Promise.as({ _sessionToken: sessionToken });\\n      }\\n      if (!Parse.User._canUseCurrentUser()) {\\n        return Parse.Promise.as(null);\\n      }\\n\\n      return Parse.User._currentAsync();\\n    }).then(function(currentUser) {\\n      if (currentUser && currentUser._sessionToken) {\\n        dataObject._SessionToken = currentUser._sessionToken;\\n      }\\n\\n      if (Parse.User._isRevocableSessionEnabled) {\\n        dataObject._RevocableSession = '1';\\n      }\\n\\n      var data = JSON.stringify(dataObject);\\n\\n      return Parse._ajax(method, url, data);\\n    }).then(null, function(response) {\\n      // Transform the error into an instance of Parse.Error by trying to parse\\n      // the error string as JSON.\\n      var error;\\n      if (response && response.responseText) {\\n        try {\\n          var errorJSON = JSON.parse(response.responseText);\\n          error = new Parse.Error(errorJSON.code, errorJSON.error);\\n        } catch (e) {\\n          // If we fail to parse the error text, that's okay.\\n          error = new Parse.Error(\\n              Parse.Error.INVALID_JSON,\\n              \\\"Received an error with invalid JSON from Parse: \\\" +\\n                  response.responseText);\\n        }\\n      } else {\\n        error = new Parse.Error(\\n            Parse.Error.CONNECTION_FAILED,\\n            \\\"XMLHttpRequest failed: \\\" + JSON.stringify(response));\\n      }\\n      // By explicitly returning a rejected Promise, this will work with\\n      // either jQuery or Promises/A semantics.\\n      return Parse.Promise.error(error);\\n    });\\n  };\\n\\n  // Helper function to get a value from a Backbone object as a property\\n  // or as a function.\\n  Parse._getValue = function(object, prop) {\\n    if (!(object && object[prop])) {\\n      return null;\\n    }\\n    return Parse._.isFunction(object[prop]) ? object[prop]() : object[prop];\\n  };\\n\\n  /**\\n   * Converts a value in a Parse Object into the appropriate representation.\\n   * This is the JS equivalent of Java's Parse.maybeReferenceAndEncode(Object)\\n   * if seenObjects is falsey. Otherwise any Parse.Objects not in\\n   * seenObjects will be fully embedded rather than encoded\\n   * as a pointer.  This array will be used to prevent going into an infinite\\n   * loop because we have circular references.  If seenObjects\\n   * is set, then none of the Parse Objects that are serialized can be dirty.\\n   */\\n  Parse._encode = function(value, seenObjects, disallowObjects) {\\n    var _ = Parse._;\\n    if (value instanceof Parse.Object) {\\n      if (disallowObjects) {\\n        throw \\\"Parse.Objects not allowed here\\\";\\n      }\\n      if (!seenObjects || _.include(seenObjects, value) || !value._hasData) {\\n        return value._toPointer();\\n      }\\n      if (!value.dirty()) {\\n        seenObjects = seenObjects.concat(value);\\n        return Parse._encode(value._toFullJSON(seenObjects),\\n                             seenObjects,\\n                             disallowObjects);\\n      }\\n      throw \\\"Tried to save an object with a pointer to a new, unsaved object.\\\";\\n    }\\n    if (value instanceof Parse.ACL) {\\n      return value.toJSON();\\n    }\\n    if (_.isDate(value)) {\\n      if (isNaN(value)) {\\n        throw new Error('Cannot encode invalid Date');\\n      }\\n      return { \\\"__type\\\": \\\"Date\\\", \\\"iso\\\": value.toJSON() };\\n    }\\n    if (value instanceof Parse.GeoPoint) {\\n      return value.toJSON();\\n    }\\n    if (_.isArray(value)) {\\n      return _.map(value, function(x) {\\n        return Parse._encode(x, seenObjects, disallowObjects);\\n      });\\n    }\\n    if (_.isRegExp(value)) {\\n      return value.source;\\n    }\\n    if (value instanceof Parse.Relation) {\\n      return value.toJSON();\\n    }\\n    if (value instanceof Parse.Op) {\\n      return value.toJSON();\\n    }\\n    if (value instanceof Parse.File) {\\n      if (!value.url()) {\\n        throw \\\"Tried to save an object containing an unsaved file.\\\";\\n      }\\n      return {\\n        __type: \\\"File\\\",\\n        name: value.name(),\\n        url: value.url()\\n      };\\n    }\\n    if (_.isObject(value)) {\\n      var output = {};\\n      Parse._objectEach(value, function(v, k) {\\n        output[k] = Parse._encode(v, seenObjects, disallowObjects);\\n      });\\n      return output;\\n    }\\n    return value;\\n  };\\n\\n  /**\\n   * The inverse function of Parse._encode.\\n   * TODO: make decode not mutate value.\\n   */\\n  Parse._decode = function(key, value) {\\n    var _ = Parse._;\\n    if (!_.isObject(value)) {\\n      return value;\\n    }\\n    if (_.isArray(value)) {\\n      Parse._arrayEach(value, function(v, k) {\\n        value[k] = Parse._decode(k, v);\\n      });\\n      return value;\\n    }\\n    if (value instanceof Parse.Object) {\\n      return value;\\n    }\\n    if (value instanceof Parse.File) {\\n      return value;\\n    }\\n    if (value instanceof Parse.Op) {\\n      return value;\\n    }\\n    if (value.__op) {\\n      return Parse.Op._decode(value);\\n    }\\n    if (value.__type === \\\"Pointer\\\" && value.className) {\\n      var pointer = Parse.Object._create(value.className);\\n      pointer._finishFetch({ objectId: value.objectId }, false);\\n      return pointer;\\n    }\\n    if (value.__type === \\\"Object\\\" && value.className) {\\n      // It's an Object included in a query result.\\n      var className = value.className;\\n      delete value.__type;\\n      delete value.className;\\n      var object = Parse.Object._create(className);\\n      object._finishFetch(value, true);\\n      return object;\\n    }\\n    if (value.__type === \\\"Date\\\") {\\n      return Parse._parseDate(value.iso);\\n    }\\n    if (value.__type === \\\"GeoPoint\\\") {\\n      return new Parse.GeoPoint({\\n        latitude: value.latitude,\\n        longitude: value.longitude\\n      });\\n    }\\n    if (key === \\\"ACL\\\") {\\n      if (value instanceof Parse.ACL) {\\n        return value;\\n      }\\n      return new Parse.ACL(value);\\n    }\\n    if (value.__type === \\\"Relation\\\") {\\n      var relation = new Parse.Relation(null, key);\\n      relation.targetClassName = value.className;\\n      return relation;\\n    }\\n    if (value.__type === \\\"File\\\") {\\n      var file = new Parse.File(value.name);\\n      file._url = value.url;\\n      return file;\\n    }\\n    Parse._objectEach(value, function(v, k) {\\n      value[k] = Parse._decode(k, v);\\n    });\\n    return value;\\n  };\\n\\n  Parse._arrayEach = Parse._.each;\\n\\n  /**\\n   * Does a deep traversal of every item in object, calling func on every one.\\n   * @param {Object} object The object or array to traverse deeply.\\n   * @param {Function} func The function to call for every item. It will\\n   *     be passed the item as an argument. If it returns a truthy value, that\\n   *     value will replace the item in its parent container.\\n   * @returns {} the result of calling func on the top-level object itself.\\n   */\\n  Parse._traverse = function(object, func, seen) {\\n    if (object instanceof Parse.Object) {\\n      seen = seen || [];\\n      if (Parse._.indexOf(seen, object) >= 0) {\\n        // We've already visited this object in this call.\\n        return;\\n      }\\n      seen.push(object);\\n      Parse._traverse(object.attributes, func, seen);\\n      return func(object);\\n    }\\n    if (object instanceof Parse.Relation || object instanceof Parse.File) {\\n      // Nothing needs to be done, but we don't want to recurse into the\\n      // object's parent infinitely, so we catch this case.\\n      return func(object);\\n    }\\n    if (Parse._.isArray(object)) {\\n      Parse._.each(object, function(child, index) {\\n        var newChild = Parse._traverse(child, func, seen);\\n        if (newChild) {\\n          object[index] = newChild;\\n        }\\n      });\\n      return func(object);\\n    }\\n    if (Parse._.isObject(object)) {\\n      Parse._each(object, function(child, key) {\\n        var newChild = Parse._traverse(child, func, seen);\\n        if (newChild) {\\n          object[key] = newChild;\\n        }\\n      });\\n      return func(object);\\n    }\\n    return func(object);\\n  };\\n\\n  /**\\n   * This is like _.each, except:\\n   * * it doesn't work for so-called array-like objects,\\n   * * it does work for dictionaries with a \\\"length\\\" attribute.\\n   */\\n  Parse._objectEach = Parse._each = function(obj, callback) {\\n    var _ = Parse._;\\n    if (_.isObject(obj)) {\\n      _.each(_.keys(obj), function(key) {\\n        callback(obj[key], key);\\n      });\\n    } else {\\n      _.each(obj, callback);\\n    }\\n  };\\n\\n  // Helper function to check null or undefined.\\n  Parse._isNullOrUndefined = function(x) {\\n    return Parse._.isNull(x) || Parse._.isUndefined(x);\\n  };\\n}(this));\\n\\n/* global require: false, localStorage: false */\\n(function(root) {\\n  root.Parse = root.Parse || {};\\n  var Parse = root.Parse;\\n  \\n  var Storage = {\\n    async: false,\\n  };\\n\\n  var hasLocalStorage = (typeof localStorage !== 'undefined');\\n  if (hasLocalStorage) {\\n    try {\\n      localStorage.setItem('supported', true);\\n      localStorage.removeItem('supported');\\n    } catch(e) {\\n      hasLocalStorage = false;\\n    }\\n  }\\n  if (hasLocalStorage) {\\n    Storage.getItem = function(path) {\\n      return localStorage.getItem(path);\\n    };\\n\\n    Storage.setItem = function(path, value) {\\n      return localStorage.setItem(path, value);\\n    };\\n\\n    Storage.removeItem = function(path) {\\n      return localStorage.removeItem(path);\\n    };\\n\\n    Storage.clear = function() {\\n      return localStorage.clear();\\n    };\\n  } else if (typeof require === 'function') {\\n    var AsyncStorage;\\n    try {\\n      AsyncStorage = eval(\\\"require('AsyncStorage')\\\"); // jshint ignore:line\\n\\n      Storage.async = true;\\n\\n      Storage.getItemAsync = function(path) {\\n        var p = new Parse.Promise();\\n        AsyncStorage.getItem(path, function(err, value) {\\n          if (err) {\\n            p.reject(err);\\n          } else {\\n            p.resolve(value);\\n          }\\n        });\\n        return p;\\n      };\\n\\n      Storage.setItemAsync = function(path, value) {\\n        var p = new Parse.Promise();\\n        AsyncStorage.setItem(path, value, function(err) {\\n          if (err) {\\n            p.reject(err);\\n          } else {\\n            p.resolve(value);\\n          }\\n        });\\n        return p;\\n      };\\n\\n      Storage.removeItemAsync = function(path) {\\n        var p = new Parse.Promise();\\n        AsyncStorage.removeItem(path, function(err) {\\n          if (err) {\\n            p.reject(err);\\n          } else {\\n            p.resolve();\\n          }\\n        });\\n        return p;\\n      };\\n\\n      Storage.clear = function() {\\n        AsyncStorage.clear();\\n      };\\n    } catch (e) { }\\n  }\\n  if (!Storage.async && !Storage.getItem) {\\n    var memMap = Storage.inMemoryMap = {};\\n    Storage.getItem = function(path) {\\n      if (memMap.hasOwnProperty(path)) {\\n        return memMap[path];\\n      }\\n      return null;\\n    };\\n\\n    Storage.setItem = function(path, value) {\\n      memMap[path] = String(value);\\n    };\\n\\n    Storage.removeItem = function(path) {\\n      delete memMap[path];\\n    };\\n\\n    Storage.clear = function() {\\n      for (var key in memMap) {\\n        if (memMap.hasOwnProperty(key)) {\\n          delete memMap[key];\\n        }\\n      }\\n    };\\n  }\\n\\n  // We can use synchronous methods from async scenarios, but not vice-versa\\n  if (!Storage.async) {\\n    Storage.getItemAsync = function(path) {\\n      return Parse.Promise.as(\\n        Storage.getItem(path)\\n      );\\n    };\\n\\n    Storage.setItemAsync = function(path, value) {\\n      Storage.setItem(path, value);\\n      return Parse.Promise.as(value);\\n    };\\n\\n    Storage.removeItemAsync = function(path) {\\n      return Parse.Promise.as(\\n        Storage.removeItem(path)\\n      );\\n    };\\n  }\\n\\n  Parse.Storage = Storage;\\n\\n})(this);\\n\\n(function(root) {\\n  root.Parse = root.Parse || {};\\n  var Parse = root.Parse;\\n  var _ = Parse._;\\n\\n  /**\\n   * @namespace Provides an interface to Parse's logging and analytics backend.\\n   */\\n  Parse.Analytics = Parse.Analytics || {};\\n\\n  _.extend(Parse.Analytics, /** @lends Parse.Analytics */ {\\n    /**\\n     * Tracks the occurrence of a custom event with additional dimensions.\\n     * Parse will store a data point at the time of invocation with the given\\n     * event name.\\n     *\\n     * Dimensions will allow segmentation of the occurrences of this custom\\n     * event. Keys and values should be {@code String}s, and will throw\\n     * otherwise.\\n     *\\n     * To track a user signup along with additional metadata, consider the\\n     * following:\\n     * <pre>\\n     * var dimensions = {\\n     *  gender: 'm',\\n     *  source: 'web',\\n     *  dayType: 'weekend'\\n     * };\\n     * Parse.Analytics.track('signup', dimensions);\\n     * </pre>\\n     *\\n     * There is a default limit of 8 dimensions per event tracked.\\n     *\\n     * @param {String} name The name of the custom event to report to Parse as\\n     * having happened.\\n     * @param {Object} dimensions The dictionary of information by which to\\n     * segment this event.\\n     * @param {Object} options A Backbone-style callback object.\\n     * @return {Parse.Promise} A promise that is resolved when the round-trip\\n     * to the server completes.\\n     */\\n    track: function(name, dimensions, options) {\\n      name = name || '';\\n      name = name.replace(/^\\\\s*/, '');\\n      name = name.replace(/\\\\s*$/, '');\\n      if (name.length === 0) {\\n        throw 'A name for the custom event must be provided';\\n      }\\n\\n      _.each(dimensions, function(val, key) {\\n        if (!_.isString(key) || !_.isString(val)) {\\n          throw 'track() dimensions expects keys and values of type \\\"string\\\".';\\n        }\\n      });\\n\\n      options = options || {};\\n      return Parse._request({\\n        route: 'events',\\n        className: name,\\n        method: 'POST',\\n        data: { dimensions: dimensions }\\n      })._thenRunCallbacks(options);\\n    }\\n  });\\n}(this));\\n\\n(function(root) {\\n  root.Parse = root.Parse || {};\\n  var Parse = root.Parse;\\n  var _ = Parse._;\\n\\n  /**\\n   * @class Parse.Config is a local representation of configuration data that\\n   * can be set from the Parse dashboard.\\n   */\\n  Parse.Config = function() {\\n    this.attributes = {};\\n    this._escapedAttributes = {};\\n  };\\n\\n  /**\\n   * Retrieves the most recently-fetched configuration object, either from\\n   * memory or from local storage if necessary.\\n   *\\n   * @return {Parse.Config} The most recently-fetched Parse.Config if it\\n   *     exists, else an empty Parse.Config.\\n   */\\n  Parse.Config.current = function() {\\n    if (Parse.Config._currentConfig) {\\n      return Parse.Config._currentConfig;\\n    }\\n\\n    var config = new Parse.Config();\\n\\n    if (Parse.Storage.async) {\\n      return config;\\n    }\\n\\n    var configData = Parse.Storage.getItem(Parse._getParsePath(\\n          Parse.Config._CURRENT_CONFIG_KEY));\\n\\n    if (configData) {  \\n      config._finishFetch(JSON.parse(configData));\\n      Parse.Config._currentConfig = config;\\n    }\\n    return config;\\n  };\\n\\n  /**\\n   * Gets a new configuration object from the server.\\n   * @param {Object} options A Backbone-style options object.\\n   * Valid options are:<ul>\\n   *   <li>success: Function to call when the get completes successfully.\\n   *   <li>error: Function to call when the get fails.\\n   * </ul>\\n   * @return {Parse.Promise} A promise that is resolved with a newly-created\\n   *     configuration object when the get completes.\\n   */\\n  Parse.Config.get = function(options) {\\n    options = options || {};\\n\\n    var request = Parse._request({\\n      route: \\\"config\\\",\\n      method: \\\"GET\\\",\\n    });\\n\\n    return request.then(function(response) {\\n      if (!response || !response.params) {\\n        var errorObject = new Parse.Error(\\n          Parse.Error.INVALID_JSON,\\n          \\\"Config JSON response invalid.\\\");\\n        return Parse.Promise.error(errorObject);\\n      }\\n\\n      var config = new Parse.Config();\\n      config._finishFetch(response);\\n      Parse.Config._currentConfig = config;\\n      return config;\\n    })._thenRunCallbacks(options);\\n  };\\n\\n  Parse.Config.prototype = {\\n\\n    /**\\n     * Gets the HTML-escaped value of an attribute.\\n     */\\n    escape: function(attr) {\\n      var html = this._escapedAttributes[attr];\\n      if (html) {\\n        return html;\\n      }\\n      var val = this.attributes[attr];\\n      var escaped;\\n      if (Parse._isNullOrUndefined(val)) {\\n        escaped = '';\\n      } else {\\n        escaped = _.escape(val.toString());\\n      }\\n      this._escapedAttributes[attr] = escaped;\\n      return escaped;\\n    },\\n\\n    /**\\n     * Gets the value of an attribute.\\n     * @param {String} attr The name of an attribute.\\n     */\\n    get: function(attr) {\\n      return this.attributes[attr];\\n    },\\n\\n    _finishFetch: function(serverData) {\\n      this.attributes = Parse._decode(null, _.clone(serverData.params));\\n      if (!Parse.Storage.async) {\\n        // We only provide local caching of config with synchronous Storage\\n        Parse.Storage.setItem(\\n            Parse._getParsePath(Parse.Config._CURRENT_CONFIG_KEY),\\n            JSON.stringify(serverData));\\n      }\\n    }\\n  };\\n\\n  Parse.Config._currentConfig = null;\\n\\n  Parse.Config._CURRENT_CONFIG_KEY = \\\"currentConfig\\\";\\n\\n}(this));\\n\\n\\n(function(root) {\\n  root.Parse = root.Parse || {};\\n  var Parse = root.Parse;\\n  var _ = Parse._;\\n\\n  /**\\n   * Constructs a new Parse.Error object with the given code and message.\\n   * @param {Number} code An error code constant from <code>Parse.Error</code>.\\n   * @param {String} message A detailed description of the error.\\n   * @class\\n   *\\n   * <p>Class used for all objects passed to error callbacks.</p>\\n   */\\n  Parse.Error = function(code, message) {\\n    this.code = code;\\n    this.message = message;\\n  };\\n\\n  _.extend(Parse.Error, /** @lends Parse.Error */ {\\n    /**\\n     * Error code indicating some error other than those enumerated here.\\n     * @constant\\n     */\\n    OTHER_CAUSE: -1,\\n\\n    /**\\n     * Error code indicating that something has gone wrong with the server.\\n     * If you get this error code, it is Parse's fault. Contact us at \\n     * https://parse.com/help\\n     * @constant\\n     */\\n    INTERNAL_SERVER_ERROR: 1,\\n\\n    /**\\n     * Error code indicating the connection to the Parse servers failed.\\n     * @constant\\n     */\\n    CONNECTION_FAILED: 100,\\n\\n    /**\\n     * Error code indicating the specified object doesn't exist.\\n     * @constant\\n     */\\n    OBJECT_NOT_FOUND: 101,\\n\\n    /**\\n     * Error code indicating you tried to query with a datatype that doesn't\\n     * support it, like exact matching an array or object.\\n     * @constant\\n     */\\n    INVALID_QUERY: 102,\\n\\n    /**\\n     * Error code indicating a missing or invalid classname. Classnames are\\n     * case-sensitive. They must start with a letter, and a-zA-Z0-9_ are the\\n     * only valid characters.\\n     * @constant\\n     */\\n    INVALID_CLASS_NAME: 103,\\n\\n    /**\\n     * Error code indicating an unspecified object id.\\n     * @constant\\n     */\\n    MISSING_OBJECT_ID: 104,\\n\\n    /**\\n     * Error code indicating an invalid key name. Keys are case-sensitive. They\\n     * must start with a letter, and a-zA-Z0-9_ are the only valid characters.\\n     * @constant\\n     */\\n    INVALID_KEY_NAME: 105,\\n\\n    /**\\n     * Error code indicating a malformed pointer. You should not see this unless\\n     * you have been mucking about changing internal Parse code.\\n     * @constant\\n     */\\n    INVALID_POINTER: 106,\\n\\n    /**\\n     * Error code indicating that badly formed JSON was received upstream. This\\n     * either indicates you have done something unusual with modifying how\\n     * things encode to JSON, or the network is failing badly.\\n     * @constant\\n     */\\n    INVALID_JSON: 107,\\n\\n    /**\\n     * Error code indicating that the feature you tried to access is only\\n     * available internally for testing purposes.\\n     * @constant\\n     */\\n    COMMAND_UNAVAILABLE: 108,\\n\\n    /**\\n     * You must call Parse.initialize before using the Parse library.\\n     * @constant\\n     */\\n    NOT_INITIALIZED: 109,\\n\\n    /**\\n     * Error code indicating that a field was set to an inconsistent type.\\n     * @constant\\n     */\\n    INCORRECT_TYPE: 111,\\n\\n    /**\\n     * Error code indicating an invalid channel name. A channel name is either\\n     * an empty string (the broadcast channel) or contains only a-zA-Z0-9_\\n     * characters and starts with a letter.\\n     * @constant\\n     */\\n    INVALID_CHANNEL_NAME: 112,\\n\\n    /**\\n     * Error code indicating that push is misconfigured.\\n     * @constant\\n     */\\n    PUSH_MISCONFIGURED: 115,\\n\\n    /**\\n     * Error code indicating that the object is too large.\\n     * @constant\\n     */\\n    OBJECT_TOO_LARGE: 116,\\n\\n    /**\\n     * Error code indicating that the operation isn't allowed for clients.\\n     * @constant\\n     */\\n    OPERATION_FORBIDDEN: 119,\\n\\n    /**\\n     * Error code indicating the result was not found in the cache.\\n     * @constant\\n     */\\n    CACHE_MISS: 120,\\n\\n    /**\\n     * Error code indicating that an invalid key was used in a nested\\n     * JSONObject.\\n     * @constant\\n     */\\n    INVALID_NESTED_KEY: 121,\\n\\n    /**\\n     * Error code indicating that an invalid filename was used for ParseFile.\\n     * A valid file name contains only a-zA-Z0-9_. characters and is between 1\\n     * and 128 characters.\\n     * @constant\\n     */\\n    INVALID_FILE_NAME: 122,\\n\\n    /**\\n     * Error code indicating an invalid ACL was provided.\\n     * @constant\\n     */\\n    INVALID_ACL: 123,\\n\\n    /**\\n     * Error code indicating that the request timed out on the server. Typically\\n     * this indicates that the request is too expensive to run.\\n     * @constant\\n     */\\n    TIMEOUT: 124,\\n\\n    /**\\n     * Error code indicating that the email address was invalid.\\n     * @constant\\n     */\\n    INVALID_EMAIL_ADDRESS: 125,\\n\\n    /**\\n     * Error code indicating a missing content type.\\n     * @constant\\n     */\\n    MISSING_CONTENT_TYPE: 126,\\n\\n    /**\\n     * Error code indicating a missing content length.\\n     * @constant\\n     */\\n    MISSING_CONTENT_LENGTH: 127,\\n\\n    /**\\n     * Error code indicating an invalid content length.\\n     * @constant\\n     */\\n    INVALID_CONTENT_LENGTH: 128,\\n\\n    /**\\n     * Error code indicating a file that was too large.\\n     * @constant\\n     */\\n    FILE_TOO_LARGE: 129,\\n\\n    /**\\n     * Error code indicating an error saving a file.\\n     * @constant\\n     */\\n    FILE_SAVE_ERROR: 130,\\n\\n    /**\\n     * Error code indicating that a unique field was given a value that is\\n     * already taken.\\n     * @constant\\n     */\\n    DUPLICATE_VALUE: 137,\\n\\n    /**\\n     * Error code indicating that a role's name is invalid.\\n     * @constant\\n     */\\n    INVALID_ROLE_NAME: 139,\\n\\n    /**\\n     * Error code indicating that an application quota was exceeded.  Upgrade to\\n     * resolve.\\n     * @constant\\n     */\\n    EXCEEDED_QUOTA: 140,\\n\\n    /**\\n     * Error code indicating that a Cloud Code script failed.\\n     * @constant\\n     */\\n    SCRIPT_FAILED: 141,\\n\\n    /**\\n     * Error code indicating that a Cloud Code validation failed.\\n     * @constant\\n     */\\n    VALIDATION_ERROR: 142,\\n\\n    /**\\n     * Error code indicating that invalid image data was provided.\\n     * @constant\\n     */\\n    INVALID_IMAGE_DATA: 150,\\n\\n    /**\\n     * Error code indicating an unsaved file.\\n     * @constant\\n     */\\n    UNSAVED_FILE_ERROR: 151,\\n\\n    /**\\n     * Error code indicating an invalid push time.\\n     */\\n    INVALID_PUSH_TIME_ERROR: 152,\\n\\n    /**\\n     * Error code indicating an error deleting a file.\\n     * @constant\\n     */\\n    FILE_DELETE_ERROR: 153,\\n\\n    /**\\n     * Error code indicating that the application has exceeded its request\\n     * limit.\\n     * @constant\\n     */\\n    REQUEST_LIMIT_EXCEEDED: 155,\\n\\n    /**\\n     * Error code indicating an invalid event name.\\n     */\\n    INVALID_EVENT_NAME: 160,\\n\\n    /**\\n     * Error code indicating that the username is missing or empty.\\n     * @constant\\n     */\\n    USERNAME_MISSING: 200,\\n\\n    /**\\n     * Error code indicating that the password is missing or empty.\\n     * @constant\\n     */\\n    PASSWORD_MISSING: 201,\\n\\n    /**\\n     * Error code indicating that the username has already been taken.\\n     * @constant\\n     */\\n    USERNAME_TAKEN: 202,\\n\\n    /**\\n     * Error code indicating that the email has already been taken.\\n     * @constant\\n     */\\n    EMAIL_TAKEN: 203,\\n\\n    /**\\n     * Error code indicating that the email is missing, but must be specified.\\n     * @constant\\n     */\\n    EMAIL_MISSING: 204,\\n\\n    /**\\n     * Error code indicating that a user with the specified email was not found.\\n     * @constant\\n     */\\n    EMAIL_NOT_FOUND: 205,\\n\\n    /**\\n     * Error code indicating that a user object without a valid session could\\n     * not be altered.\\n     * @constant\\n     */\\n    SESSION_MISSING: 206,\\n\\n    /**\\n     * Error code indicating that a user can only be created through signup.\\n     * @constant\\n     */\\n    MUST_CREATE_USER_THROUGH_SIGNUP: 207,\\n\\n    /**\\n     * Error code indicating that an an account being linked is already linked\\n     * to another user.\\n     * @constant\\n     */\\n    ACCOUNT_ALREADY_LINKED: 208,\\n\\n    /**\\n     * Error code indicating that the current session token is invalid.\\n     * @constant\\n     */\\n    INVALID_SESSION_TOKEN: 209,\\n\\n    /**\\n     * Error code indicating that a user cannot be linked to an account because\\n     * that account's id could not be found.\\n     * @constant\\n     */\\n    LINKED_ID_MISSING: 250,\\n\\n    /**\\n     * Error code indicating that a user with a linked (e.g. Facebook) account\\n     * has an invalid session.\\n     * @constant\\n     */\\n    INVALID_LINKED_SESSION: 251,\\n\\n    /**\\n     * Error code indicating that a service being linked (e.g. Facebook or\\n     * Twitter) is unsupported.\\n     * @constant\\n     */\\n    UNSUPPORTED_SERVICE: 252,\\n\\n    /**\\n     * Error code indicating that there were multiple errors. Aggregate errors\\n     * have an \\\"errors\\\" property, which is an array of error objects with more\\n     * detail about each error that occurred.\\n     * @constant\\n     */\\n    AGGREGATE_ERROR: 600,\\n\\n    /**\\n     * Error code indicating the client was unable to read an input file.\\n     * @constant\\n     */\\n    FILE_READ_ERROR: 601,\\n\\n    /**\\n     * Error code indicating a real error code is unavailable because\\n     * we had to use an XDomainRequest object to allow CORS requests in\\n     * Internet Explorer, which strips the body from HTTP responses that have\\n     * a non-2XX status code.\\n     * @constant\\n     */\\n    X_DOMAIN_REQUEST: 602\\n  });\\n\\n}(this));\\n\\n/*global _: false */\\n(function() {\\n  var root = this;\\n  var Parse = (root.Parse || (root.Parse = {}));\\n  var eventSplitter = /\\\\s+/;\\n  var slice = Array.prototype.slice;\\n\\n  /**\\n   * @class\\n   *\\n   * <p>Parse.Events is a fork of Backbone's Events module, provided for your\\n   * convenience.</p>\\n   *\\n   * <p>A module that can be mixed in to any object in order to provide\\n   * it with custom events. You may bind callback functions to an event\\n   * with `on`, or remove these functions with `off`.\\n   * Triggering an event fires all callbacks in the order that `on` was\\n   * called.\\n   *\\n   * <pre>\\n   *     var object = {};\\n   *     _.extend(object, Parse.Events);\\n   *     object.on('expand', function(){ alert('expanded'); });\\n   *     object.trigger('expand');</pre></p>\\n   *\\n   * <p>For more information, see the\\n   * <a href=\\\"http://documentcloud.github.com/backbone/#Events\\\">Backbone\\n   * documentation</a>.</p>\\n   */\\n  Parse.Events = {\\n    /**\\n     * Bind one or more space separated events, `events`, to a `callback`\\n     * function. Passing `\\\"all\\\"` will bind the callback to all events fired.\\n     */\\n    on: function(events, callback, context) {\\n\\n      var calls, event, node, tail, list;\\n      if (!callback) {\\n        return this;\\n      }\\n      events = events.split(eventSplitter);\\n      calls = this._callbacks || (this._callbacks = {});\\n\\n      // Create an immutable callback list, allowing traversal during\\n      // modification.  The tail is an empty object that will always be used\\n      // as the next node.\\n      event = events.shift();\\n      while (event) {\\n        list = calls[event];\\n        node = list ? list.tail : {};\\n        node.next = tail = {};\\n        node.context = context;\\n        node.callback = callback;\\n        calls[event] = {tail: tail, next: list ? list.next : node};\\n        event = events.shift();\\n      }\\n\\n      return this;\\n    },\\n\\n    /**\\n     * Remove one or many callbacks. If `context` is null, removes all callbacks\\n     * with that function. If `callback` is null, removes all callbacks for the\\n     * event. If `events` is null, removes all bound callbacks for all events.\\n     */\\n    off: function(events, callback, context) {\\n      var event, calls, node, tail, cb, ctx;\\n\\n      // No events, or removing *all* events.\\n      if (!(calls = this._callbacks)) {\\n        return;\\n      }\\n      if (!(events || callback || context)) {\\n        delete this._callbacks;\\n        return this;\\n      }\\n\\n      // Loop through the listed events and contexts, splicing them out of the\\n      // linked list of callbacks if appropriate.\\n      events = events ? events.split(eventSplitter) : Object.keys(calls);\\n      event = events.shift();\\n      while (event) {\\n        node = calls[event];\\n        delete calls[event];\\n        if (!node || !(callback || context)) {\\n          event = events.shift();\\n          continue;\\n        }\\n        // Create a new list, omitting the indicated callbacks.\\n        tail = node.tail;\\n        node = node.next;\\n        while (node !== tail) {\\n          cb = node.callback;\\n          ctx = node.context;\\n          if ((callback && cb !== callback) || (context && ctx !== context)) {\\n            this.on(event, cb, ctx);\\n          }\\n          node = node.next;\\n        }\\n        event = events.shift();\\n      }\\n\\n      return this;\\n    },\\n\\n    /**\\n     * Trigger one or many events, firing all bound callbacks. Callbacks are\\n     * passed the same arguments as `trigger` is, apart from the event name\\n     * (unless you're listening on `\\\"all\\\"`, which will cause your callback to\\n     * receive the true name of the event as the first argument).\\n     */\\n    trigger: function(events) {\\n      var event, node, calls, tail, args, all, rest;\\n      if (!(calls = this._callbacks)) {\\n        return this;\\n      }\\n      all = calls.all;\\n      events = events.split(eventSplitter);\\n      rest = slice.call(arguments, 1);\\n\\n      // For each event, walk through the linked list of callbacks twice,\\n      // first to trigger the event, then to trigger any `\\\"all\\\"` callbacks.\\n      event = events.shift();\\n      while (event) {\\n        node = calls[event];\\n        if (node) {\\n          tail = node.tail;\\n          while ((node = node.next) !== tail) {\\n            node.callback.apply(node.context || this, rest);\\n          }\\n        }\\n        node = all;\\n        if (node) {\\n          tail = node.tail;\\n          args = [event].concat(rest);\\n          while ((node = node.next) !== tail) {\\n            node.callback.apply(node.context || this, args);\\n          }\\n        }\\n        event = events.shift();\\n      }\\n\\n      return this;\\n    }\\n  };  \\n\\n  /**\\n   * @function\\n   */\\n  Parse.Events.bind = Parse.Events.on;\\n\\n  /**\\n   * @function\\n   */\\n  Parse.Events.unbind = Parse.Events.off;\\n}.call(this));\\n\\n\\n/*global navigator: false */\\n(function(root) {\\n  root.Parse = root.Parse || {};\\n  var Parse = root.Parse;\\n  var _ = Parse._;\\n\\n  /**\\n   * Creates a new GeoPoint with any of the following forms:<br>\\n   *   <pre>\\n   *   new GeoPoint(otherGeoPoint)\\n   *   new GeoPoint(30, 30)\\n   *   new GeoPoint([30, 30])\\n   *   new GeoPoint({latitude: 30, longitude: 30})\\n   *   new GeoPoint()  // defaults to (0, 0)\\n   *   </pre>\\n   * @class\\n   *\\n   * <p>Represents a latitude / longitude point that may be associated\\n   * with a key in a ParseObject or used as a reference point for geo queries.\\n   * This allows proximity-based queries on the key.</p>\\n   *\\n   * <p>Only one key in a class may contain a GeoPoint.</p>\\n   *\\n   * <p>Example:<pre>\\n   *   var point = new Parse.GeoPoint(30.0, -20.0);\\n   *   var object = new Parse.Object(\\\"PlaceObject\\\");\\n   *   object.set(\\\"location\\\", point);\\n   *   object.save();</pre></p>\\n   */\\n  Parse.GeoPoint = function(arg1, arg2) {\\n    if (_.isArray(arg1)) {\\n      Parse.GeoPoint._validate(arg1[0], arg1[1]);\\n      this.latitude = arg1[0];\\n      this.longitude = arg1[1];\\n    } else if (_.isObject(arg1)) {\\n      Parse.GeoPoint._validate(arg1.latitude, arg1.longitude);\\n      this.latitude = arg1.latitude;\\n      this.longitude = arg1.longitude;\\n    } else if (_.isNumber(arg1) && _.isNumber(arg2)) {\\n      Parse.GeoPoint._validate(arg1, arg2);\\n      this.latitude = arg1;\\n      this.longitude = arg2;\\n    } else {\\n      this.latitude = 0;\\n      this.longitude = 0;\\n    }\\n\\n    // Add properties so that anyone using Webkit or Mozilla will get an error\\n    // if they try to set values that are out of bounds.\\n    var self = this;\\n    if (this.__defineGetter__ && this.__defineSetter__) {\\n      // Use _latitude and _longitude to actually store the values, and add\\n      // getters and setters for latitude and longitude.\\n      this._latitude = this.latitude;\\n      this._longitude = this.longitude;\\n      this.__defineGetter__(\\\"latitude\\\", function() {\\n        return self._latitude;\\n      });\\n      this.__defineGetter__(\\\"longitude\\\", function() {\\n        return self._longitude;\\n      });\\n      this.__defineSetter__(\\\"latitude\\\", function(val) {\\n        Parse.GeoPoint._validate(val, self.longitude);\\n        self._latitude = val;\\n      });\\n      this.__defineSetter__(\\\"longitude\\\", function(val) {\\n        Parse.GeoPoint._validate(self.latitude, val);\\n        self._longitude = val;\\n      });\\n    }\\n  };\\n\\n  /**\\n   * @lends Parse.GeoPoint.prototype\\n   * @property {float} latitude North-south portion of the coordinate, in range\\n   *   [-90, 90].  Throws an exception if set out of range in a modern browser.\\n   * @property {float} longitude East-west portion of the coordinate, in range\\n   *   [-180, 180].  Throws if set out of range in a modern browser.\\n   */\\n\\n  /**\\n   * Throws an exception if the given lat-long is out of bounds.\\n   */\\n  Parse.GeoPoint._validate = function(latitude, longitude) {\\n    if (latitude < -90.0) {\\n      throw \\\"Parse.GeoPoint latitude \\\" + latitude + \\\" < -90.0.\\\";\\n    }\\n    if (latitude > 90.0) {\\n      throw \\\"Parse.GeoPoint latitude \\\" + latitude + \\\" > 90.0.\\\";\\n    }\\n    if (longitude < -180.0) {\\n      throw \\\"Parse.GeoPoint longitude \\\" + longitude + \\\" < -180.0.\\\";\\n    }\\n    if (longitude > 180.0) {\\n      throw \\\"Parse.GeoPoint longitude \\\" + longitude + \\\" > 180.0.\\\";\\n    }\\n  };\\n\\n  /**\\n   * Creates a GeoPoint with the user's current location, if available.\\n   * Calls options.success with a new GeoPoint instance or calls options.error.\\n   * @param {Object} options An object with success and error callbacks.\\n   */\\n  Parse.GeoPoint.current = function(options) {\\n    var promise = new Parse.Promise();\\n    navigator.geolocation.getCurrentPosition(function(location) {\\n      promise.resolve(new Parse.GeoPoint({\\n        latitude: location.coords.latitude,\\n        longitude: location.coords.longitude\\n      }));\\n\\n    }, function(error) {\\n      promise.reject(error);\\n    });\\n\\n    return promise._thenRunCallbacks(options);\\n  };\\n\\n  Parse.GeoPoint.prototype = {\\n    /**\\n     * Returns a JSON representation of the GeoPoint, suitable for Parse.\\n     * @return {Object}\\n     */\\n    toJSON: function() {\\n      Parse.GeoPoint._validate(this.latitude, this.longitude);\\n      return {\\n        \\\"__type\\\": \\\"GeoPoint\\\",\\n        latitude: this.latitude,\\n        longitude: this.longitude\\n      };\\n    },\\n\\n    /**\\n     * Returns the distance from this GeoPoint to another in radians.\\n     * @param {Parse.GeoPoint} point the other Parse.GeoPoint.\\n     * @return {Number}\\n     */\\n    radiansTo: function(point) {\\n      var d2r = Math.PI / 180.0;\\n      var lat1rad = this.latitude * d2r;\\n      var long1rad = this.longitude * d2r;\\n      var lat2rad = point.latitude * d2r;\\n      var long2rad = point.longitude * d2r;\\n      var deltaLat = lat1rad - lat2rad;\\n      var deltaLong = long1rad - long2rad;\\n      var sinDeltaLatDiv2 = Math.sin(deltaLat / 2);\\n      var sinDeltaLongDiv2 = Math.sin(deltaLong / 2);\\n      // Square of half the straight line chord distance between both points.\\n      var a = ((sinDeltaLatDiv2 * sinDeltaLatDiv2) +\\n               (Math.cos(lat1rad) * Math.cos(lat2rad) *\\n                sinDeltaLongDiv2 * sinDeltaLongDiv2));\\n      a = Math.min(1.0, a);\\n      return 2 * Math.asin(Math.sqrt(a));\\n    },\\n\\n    /**\\n     * Returns the distance from this GeoPoint to another in kilometers.\\n     * @param {Parse.GeoPoint} point the other Parse.GeoPoint.\\n     * @return {Number}\\n     */\\n    kilometersTo: function(point) {\\n      return this.radiansTo(point) * 6371.0;\\n    },\\n\\n    /**\\n     * Returns the distance from this GeoPoint to another in miles.\\n     * @param {Parse.GeoPoint} point the other Parse.GeoPoint.\\n     * @return {Number}\\n     */\\n    milesTo: function(point) {\\n      return this.radiansTo(point) * 3958.8;\\n    }\\n  };\\n}(this));\\n\\n/*global navigator: false */\\n(function(root) {\\n  root.Parse = root.Parse || {};\\n  var Parse = root.Parse;\\n  var _ = Parse._;\\n\\n  var PUBLIC_KEY = \\\"*\\\";\\n\\n  /**\\n   * Creates a new ACL.\\n   * If no argument is given, the ACL has no permissions for anyone.\\n   * If the argument is a Parse.User, the ACL will have read and write\\n   *   permission for only that user.\\n   * If the argument is any other JSON object, that object will be interpretted\\n   *   as a serialized ACL created with toJSON().\\n   * @see Parse.Object#setACL\\n   * @class\\n   *\\n   * <p>An ACL, or Access Control List can be added to any\\n   * <code>Parse.Object</code> to restrict access to only a subset of users\\n   * of your application.</p>\\n   */\\n  Parse.ACL = function(arg1) {\\n    var self = this;\\n    self.permissionsById = {};\\n    if (_.isObject(arg1)) {\\n      if (arg1 instanceof Parse.User) {\\n        self.setReadAccess(arg1, true);\\n        self.setWriteAccess(arg1, true);\\n      } else {\\n        if (_.isFunction(arg1)) {\\n          throw \\\"Parse.ACL() called with a function.  Did you forget ()?\\\";\\n        }\\n        Parse._objectEach(arg1, function(accessList, userId) {\\n          if (!_.isString(userId)) {\\n            throw \\\"Tried to create an ACL with an invalid userId.\\\";\\n          }\\n          self.permissionsById[userId] = {};\\n          Parse._objectEach(accessList, function(allowed, permission) {\\n            if (permission !== \\\"read\\\" && permission !== \\\"write\\\") {\\n              throw \\\"Tried to create an ACL with an invalid permission type.\\\";\\n            }\\n            if (!_.isBoolean(allowed)) {\\n              throw \\\"Tried to create an ACL with an invalid permission value.\\\";\\n            }\\n            self.permissionsById[userId][permission] = allowed;\\n          });\\n        });\\n      }\\n    }\\n  };\\n\\n  /**\\n   * Returns a JSON-encoded version of the ACL.\\n   * @return {Object}\\n   */\\n  Parse.ACL.prototype.toJSON = function() {\\n    return _.clone(this.permissionsById);\\n  };\\n\\n  Parse.ACL.prototype._setAccess = function(accessType, userId, allowed) {\\n    if (userId instanceof Parse.User) {\\n      userId = userId.id;\\n    } else if (userId instanceof Parse.Role) {\\n      userId = \\\"role:\\\" + userId.getName();\\n    }\\n    if (!_.isString(userId)) {\\n      throw \\\"userId must be a string.\\\";\\n    }\\n    if (!_.isBoolean(allowed)) {\\n      throw \\\"allowed must be either true or false.\\\";\\n    }\\n    var permissions = this.permissionsById[userId];\\n    if (!permissions) {\\n      if (!allowed) {\\n        // The user already doesn't have this permission, so no action needed.\\n        return;\\n      } else {\\n        permissions = {};\\n        this.permissionsById[userId] = permissions;\\n      }\\n    }\\n\\n    if (allowed) {\\n      this.permissionsById[userId][accessType] = true;\\n    } else {\\n      delete permissions[accessType];\\n      if (_.isEmpty(permissions)) {\\n        delete permissions[userId];\\n      }\\n    }\\n  };\\n\\n  Parse.ACL.prototype._getAccess = function(accessType, userId) {\\n    if (userId instanceof Parse.User) {\\n      userId = userId.id;\\n    } else if (userId instanceof Parse.Role) {\\n      userId = \\\"role:\\\" + userId.getName();\\n    }\\n    var permissions = this.permissionsById[userId];\\n    if (!permissions) {\\n      return false;\\n    }\\n    return permissions[accessType] ? true : false;\\n  };\\n\\n  /**\\n   * Set whether the given user is allowed to read this object.\\n   * @param userId An instance of Parse.User or its objectId.\\n   * @param {Boolean} allowed Whether that user should have read access.\\n   */\\n  Parse.ACL.prototype.setReadAccess = function(userId, allowed) {\\n    this._setAccess(\\\"read\\\", userId, allowed);\\n  };\\n\\n  /**\\n   * Get whether the given user id is *explicitly* allowed to read this object.\\n   * Even if this returns false, the user may still be able to access it if\\n   * getPublicReadAccess returns true or a role that the user belongs to has\\n   * write access.\\n   * @param userId An instance of Parse.User or its objectId, or a Parse.Role.\\n   * @return {Boolean}\\n   */\\n  Parse.ACL.prototype.getReadAccess = function(userId) {\\n    return this._getAccess(\\\"read\\\", userId);\\n  };\\n\\n  /**\\n   * Set whether the given user id is allowed to write this object.\\n   * @param userId An instance of Parse.User or its objectId, or a Parse.Role..\\n   * @param {Boolean} allowed Whether that user should have write access.\\n   */\\n  Parse.ACL.prototype.setWriteAccess = function(userId, allowed) {\\n    this._setAccess(\\\"write\\\", userId, allowed);\\n  };\\n\\n  /**\\n   * Get whether the given user id is *explicitly* allowed to write this object.\\n   * Even if this returns false, the user may still be able to write it if\\n   * getPublicWriteAccess returns true or a role that the user belongs to has\\n   * write access.\\n   * @param userId An instance of Parse.User or its objectId, or a Parse.Role.\\n   * @return {Boolean}\\n   */\\n  Parse.ACL.prototype.getWriteAccess = function(userId) {\\n    return this._getAccess(\\\"write\\\", userId);\\n  };\\n\\n  /**\\n   * Set whether the public is allowed to read this object.\\n   * @param {Boolean} allowed\\n   */\\n  Parse.ACL.prototype.setPublicReadAccess = function(allowed) {\\n    this.setReadAccess(PUBLIC_KEY, allowed);\\n  };\\n\\n  /**\\n   * Get whether the public is allowed to read this object.\\n   * @return {Boolean}\\n   */\\n  Parse.ACL.prototype.getPublicReadAccess = function() {\\n    return this.getReadAccess(PUBLIC_KEY);\\n  };\\n\\n  /**\\n   * Set whether the public is allowed to write this object.\\n   * @param {Boolean} allowed\\n   */\\n  Parse.ACL.prototype.setPublicWriteAccess = function(allowed) {\\n    this.setWriteAccess(PUBLIC_KEY, allowed);\\n  };\\n\\n  /**\\n   * Get whether the public is allowed to write this object.\\n   * @return {Boolean}\\n   */\\n  Parse.ACL.prototype.getPublicWriteAccess = function() {\\n    return this.getWriteAccess(PUBLIC_KEY);\\n  };\\n  \\n  /**\\n   * Get whether users belonging to the given role are allowed\\n   * to read this object. Even if this returns false, the role may\\n   * still be able to write it if a parent role has read access.\\n   * \\n   * @param role The name of the role, or a Parse.Role object.\\n   * @return {Boolean} true if the role has read access. false otherwise.\\n   * @throws {String} If role is neither a Parse.Role nor a String.\\n   */\\n  Parse.ACL.prototype.getRoleReadAccess = function(role) {\\n    if (role instanceof Parse.Role) {\\n      // Normalize to the String name\\n      role = role.getName();\\n    }\\n    if (_.isString(role)) {\\n      return this.getReadAccess(\\\"role:\\\" + role);\\n    }\\n    throw \\\"role must be a Parse.Role or a String\\\";\\n  };\\n  \\n  /**\\n   * Get whether users belonging to the given role are allowed\\n   * to write this object. Even if this returns false, the role may\\n   * still be able to write it if a parent role has write access.\\n   * \\n   * @param role The name of the role, or a Parse.Role object.\\n   * @return {Boolean} true if the role has write access. false otherwise.\\n   * @throws {String} If role is neither a Parse.Role nor a String.\\n   */\\n  Parse.ACL.prototype.getRoleWriteAccess = function(role) {\\n    if (role instanceof Parse.Role) {\\n      // Normalize to the String name\\n      role = role.getName();\\n    }\\n    if (_.isString(role)) {\\n      return this.getWriteAccess(\\\"role:\\\" + role);\\n    }\\n    throw \\\"role must be a Parse.Role or a String\\\";\\n  };\\n  \\n  /**\\n   * Set whether users belonging to the given role are allowed\\n   * to read this object.\\n   * \\n   * @param role The name of the role, or a Parse.Role object.\\n   * @param {Boolean} allowed Whether the given role can read this object.\\n   * @throws {String} If role is neither a Parse.Role nor a String.\\n   */\\n  Parse.ACL.prototype.setRoleReadAccess = function(role, allowed) {\\n    if (role instanceof Parse.Role) {\\n      // Normalize to the String name\\n      role = role.getName();\\n    }\\n    if (_.isString(role)) {\\n      this.setReadAccess(\\\"role:\\\" + role, allowed);\\n      return;\\n    }\\n    throw \\\"role must be a Parse.Role or a String\\\";\\n  };\\n  \\n  /**\\n   * Set whether users belonging to the given role are allowed\\n   * to write this object.\\n   * \\n   * @param role The name of the role, or a Parse.Role object.\\n   * @param {Boolean} allowed Whether the given role can write this object.\\n   * @throws {String} If role is neither a Parse.Role nor a String.\\n   */\\n  Parse.ACL.prototype.setRoleWriteAccess = function(role, allowed) {\\n    if (role instanceof Parse.Role) {\\n      // Normalize to the String name\\n      role = role.getName();\\n    }\\n    if (_.isString(role)) {\\n      this.setWriteAccess(\\\"role:\\\" + role, allowed);\\n      return;\\n    }\\n    throw \\\"role must be a Parse.Role or a String\\\";\\n  };\\n\\n}(this));\\n\\n(function(root) {\\n  root.Parse = root.Parse || {};\\n  var Parse = root.Parse;\\n  var _ = Parse._;\\n\\n  /**\\n   * @class\\n   * A Parse.Op is an atomic operation that can be applied to a field in a\\n   * Parse.Object. For example, calling <code>object.set(\\\"foo\\\", \\\"bar\\\")</code>\\n   * is an example of a Parse.Op.Set. Calling <code>object.unset(\\\"foo\\\")</code>\\n   * is a Parse.Op.Unset. These operations are stored in a Parse.Object and\\n   * sent to the server as part of <code>object.save()</code> operations.\\n   * Instances of Parse.Op should be immutable.\\n   *\\n   * You should not create subclasses of Parse.Op or instantiate Parse.Op\\n   * directly.\\n   */\\n  Parse.Op = function() {\\n    this._initialize.apply(this, arguments);\\n  };\\n\\n  Parse.Op.prototype = {\\n    _initialize: function() {}\\n  };\\n\\n  _.extend(Parse.Op, {\\n    /**\\n     * To create a new Op, call Parse.Op._extend();\\n     */\\n    _extend: Parse._extend,\\n\\n    // A map of __op string to decoder function.\\n    _opDecoderMap: {},\\n\\n    /**\\n     * Registers a function to convert a json object with an __op field into an\\n     * instance of a subclass of Parse.Op.\\n     */\\n    _registerDecoder: function(opName, decoder) {\\n      Parse.Op._opDecoderMap[opName] = decoder;\\n    },\\n\\n    /**\\n     * Converts a json object into an instance of a subclass of Parse.Op.\\n     */\\n    _decode: function(json) {\\n      var decoder = Parse.Op._opDecoderMap[json.__op];\\n      if (decoder) {\\n        return decoder(json);\\n      } else {\\n        return undefined;\\n      }\\n    }\\n  });\\n\\n  /*\\n   * Add a handler for Batch ops.\\n   */\\n  Parse.Op._registerDecoder(\\\"Batch\\\", function(json) {\\n    var op = null;\\n    Parse._arrayEach(json.ops, function(nextOp) {\\n      nextOp = Parse.Op._decode(nextOp);\\n      op = nextOp._mergeWithPrevious(op);\\n    });\\n    return op;\\n  });\\n\\n  /**\\n   * @class\\n   * A Set operation indicates that either the field was changed using\\n   * Parse.Object.set, or it is a mutable container that was detected as being\\n   * changed.\\n   */\\n  Parse.Op.Set = Parse.Op._extend(/** @lends Parse.Op.Set.prototype */ {\\n    _initialize: function(value) {\\n      this._value = value;\\n    },\\n\\n    /**\\n     * Returns the new value of this field after the set.\\n     */\\n    value: function() {\\n      return this._value;\\n    },\\n\\n    /**\\n     * Returns a JSON version of the operation suitable for sending to Parse.\\n     * @return {Object}\\n     */\\n    toJSON: function() {\\n      return Parse._encode(this.value());\\n    },\\n\\n    _mergeWithPrevious: function(previous) {\\n      return this;\\n    },\\n\\n    _estimate: function(oldValue) {\\n      return this.value();\\n    }\\n  });\\n\\n  /**\\n   * A sentinel value that is returned by Parse.Op.Unset._estimate to\\n   * indicate the field should be deleted. Basically, if you find _UNSET as a\\n   * value in your object, you should remove that key.\\n   */\\n  Parse.Op._UNSET = {};\\n\\n  /**\\n   * @class\\n   * An Unset operation indicates that this field has been deleted from the\\n   * object.\\n   */\\n  Parse.Op.Unset = Parse.Op._extend(/** @lends Parse.Op.Unset.prototype */ {\\n    /**\\n     * Returns a JSON version of the operation suitable for sending to Parse.\\n     * @return {Object}\\n     */\\n    toJSON: function() {\\n      return { __op: \\\"Delete\\\" };\\n    },\\n\\n    _mergeWithPrevious: function(previous) {\\n      return this;\\n    },\\n\\n    _estimate: function(oldValue) {\\n      return Parse.Op._UNSET;\\n    }\\n  });\\n\\n  Parse.Op._registerDecoder(\\\"Delete\\\", function(json) {\\n    return new Parse.Op.Unset();\\n  });\\n\\n  /**\\n   * @class\\n   * An Increment is an atomic operation where the numeric value for the field\\n   * will be increased by a given amount.\\n   */\\n  Parse.Op.Increment = Parse.Op._extend(\\n      /** @lends Parse.Op.Increment.prototype */ {\\n\\n    _initialize: function(amount) {\\n      this._amount = amount;\\n    },\\n\\n    /**\\n     * Returns the amount to increment by.\\n     * @return {Number} the amount to increment by.\\n     */\\n    amount: function() {\\n      return this._amount;\\n    },\\n\\n    /**\\n     * Returns a JSON version of the operation suitable for sending to Parse.\\n     * @return {Object}\\n     */\\n    toJSON: function() {\\n      return { __op: \\\"Increment\\\", amount: this._amount };\\n    },\\n\\n    _mergeWithPrevious: function(previous) {\\n      if (!previous) {\\n        return this;\\n      } else if (previous instanceof Parse.Op.Unset) {\\n        return new Parse.Op.Set(this.amount());\\n      } else if (previous instanceof Parse.Op.Set) {\\n        return new Parse.Op.Set(previous.value() + this.amount());\\n      } else if (previous instanceof Parse.Op.Increment) {\\n        return new Parse.Op.Increment(this.amount() + previous.amount());\\n      } else {\\n        throw \\\"Op is invalid after previous op.\\\";\\n      }\\n    },\\n\\n    _estimate: function(oldValue) {\\n      if (!oldValue) {\\n        return this.amount();\\n      }\\n      return oldValue + this.amount();\\n    }\\n  });\\n\\n  Parse.Op._registerDecoder(\\\"Increment\\\", function(json) {\\n    return new Parse.Op.Increment(json.amount);\\n  });\\n\\n  /**\\n   * @class\\n   * Add is an atomic operation where the given objects will be appended to the\\n   * array that is stored in this field.\\n   */\\n  Parse.Op.Add = Parse.Op._extend(/** @lends Parse.Op.Add.prototype */ {\\n    _initialize: function(objects) {\\n      this._objects = objects;\\n    },\\n\\n    /**\\n     * Returns the objects to be added to the array.\\n     * @return {Array} The objects to be added to the array.\\n     */\\n    objects: function() {\\n      return this._objects;\\n    },\\n\\n    /**\\n     * Returns a JSON version of the operation suitable for sending to Parse.\\n     * @return {Object}\\n     */\\n    toJSON: function() {\\n      return { __op: \\\"Add\\\", objects: Parse._encode(this.objects()) };\\n    },\\n\\n    _mergeWithPrevious: function(previous) {\\n      if (!previous) {\\n        return this;\\n      } else if (previous instanceof Parse.Op.Unset) {\\n        return new Parse.Op.Set(this.objects());\\n      } else if (previous instanceof Parse.Op.Set) {\\n        return new Parse.Op.Set(this._estimate(previous.value()));\\n      } else if (previous instanceof Parse.Op.Add) {\\n        return new Parse.Op.Add(previous.objects().concat(this.objects()));\\n      } else {\\n        throw \\\"Op is invalid after previous op.\\\";\\n      }\\n    },\\n\\n    _estimate: function(oldValue) {\\n      if (!oldValue) {\\n        return _.clone(this.objects());\\n      } else {\\n        return oldValue.concat(this.objects());\\n      }\\n    }\\n  });\\n\\n  Parse.Op._registerDecoder(\\\"Add\\\", function(json) {\\n    return new Parse.Op.Add(Parse._decode(undefined, json.objects));\\n  });\\n\\n  /**\\n   * @class\\n   * AddUnique is an atomic operation where the given items will be appended to\\n   * the array that is stored in this field only if they were not already\\n   * present in the array.\\n   */\\n  Parse.Op.AddUnique = Parse.Op._extend(\\n      /** @lends Parse.Op.AddUnique.prototype */ {\\n\\n    _initialize: function(objects) {\\n      this._objects = _.uniq(objects);\\n    },\\n\\n    /**\\n     * Returns the objects to be added to the array.\\n     * @return {Array} The objects to be added to the array.\\n     */\\n    objects: function() {\\n      return this._objects;\\n    },\\n\\n    /**\\n     * Returns a JSON version of the operation suitable for sending to Parse.\\n     * @return {Object}\\n     */\\n    toJSON: function() {\\n      return { __op: \\\"AddUnique\\\", objects: Parse._encode(this.objects()) };\\n    },\\n\\n    _mergeWithPrevious: function(previous) {\\n      if (!previous) {\\n        return this;\\n      } else if (previous instanceof Parse.Op.Unset) {\\n        return new Parse.Op.Set(this.objects());\\n      } else if (previous instanceof Parse.Op.Set) {\\n        return new Parse.Op.Set(this._estimate(previous.value()));\\n      } else if (previous instanceof Parse.Op.AddUnique) {\\n        return new Parse.Op.AddUnique(this._estimate(previous.objects()));\\n      } else {\\n        throw \\\"Op is invalid after previous op.\\\";\\n      }\\n    },\\n\\n    _estimate: function(oldValue) {\\n      if (!oldValue) {\\n        return _.clone(this.objects());\\n      } else {\\n        // We can't just take the _.uniq(_.union(...)) of oldValue and\\n        // this.objects, because the uniqueness may not apply to oldValue\\n        // (especially if the oldValue was set via .set())\\n        var newValue = _.clone(oldValue);\\n        Parse._arrayEach(this.objects(), function(obj) {\\n          if (obj instanceof Parse.Object && obj.id) {\\n            var matchingObj = _.find(newValue, function(anObj) {\\n              return (anObj instanceof Parse.Object) && (anObj.id === obj.id);\\n            });\\n            if (!matchingObj) {\\n              newValue.push(obj);\\n            } else {\\n              var index = _.indexOf(newValue, matchingObj);\\n              newValue[index] = obj;\\n            }\\n          } else if (!_.contains(newValue, obj)) {\\n            newValue.push(obj);\\n          }\\n        });\\n        return newValue;\\n      }\\n    }\\n  });\\n\\n  Parse.Op._registerDecoder(\\\"AddUnique\\\", function(json) {\\n    return new Parse.Op.AddUnique(Parse._decode(undefined, json.objects));\\n  });\\n\\n  /**\\n   * @class\\n   * Remove is an atomic operation where the given objects will be removed from\\n   * the array that is stored in this field.\\n   */\\n  Parse.Op.Remove = Parse.Op._extend(/** @lends Parse.Op.Remove.prototype */ {\\n    _initialize: function(objects) {\\n      this._objects = _.uniq(objects);\\n    },\\n\\n    /**\\n     * Returns the objects to be removed from the array.\\n     * @return {Array} The objects to be removed from the array.\\n     */\\n    objects: function() {\\n      return this._objects;\\n    },\\n\\n    /**\\n     * Returns a JSON version of the operation suitable for sending to Parse.\\n     * @return {Object}\\n     */\\n    toJSON: function() {\\n      return { __op: \\\"Remove\\\", objects: Parse._encode(this.objects()) };\\n    },\\n\\n    _mergeWithPrevious: function(previous) {\\n      if (!previous) {\\n        return this;\\n      } else if (previous instanceof Parse.Op.Unset) {\\n        return previous;\\n      } else if (previous instanceof Parse.Op.Set) {\\n        return new Parse.Op.Set(this._estimate(previous.value()));\\n      } else if (previous instanceof Parse.Op.Remove) {\\n        return new Parse.Op.Remove(_.union(previous.objects(), this.objects()));\\n      } else {\\n        throw \\\"Op is invalid after previous op.\\\";\\n      }\\n    },\\n\\n    _estimate: function(oldValue) {\\n      if (!oldValue) {\\n        return [];\\n      } else {\\n        var newValue = _.difference(oldValue, this.objects());\\n        // If there are saved Parse Objects being removed, also remove them.\\n        Parse._arrayEach(this.objects(), function(obj) {\\n          if (obj instanceof Parse.Object && obj.id) {\\n            newValue = _.reject(newValue, function(other) {\\n              return (other instanceof Parse.Object) && (other.id === obj.id);\\n            });\\n          }\\n        });\\n        return newValue;\\n      }\\n    }\\n  });\\n\\n  Parse.Op._registerDecoder(\\\"Remove\\\", function(json) {\\n    return new Parse.Op.Remove(Parse._decode(undefined, json.objects));\\n  });\\n\\n  /**\\n   * @class\\n   * A Relation operation indicates that the field is an instance of\\n   * Parse.Relation, and objects are being added to, or removed from, that\\n   * relation.\\n   */\\n  Parse.Op.Relation = Parse.Op._extend(\\n      /** @lends Parse.Op.Relation.prototype */ {\\n\\n    _initialize: function(adds, removes) {\\n      this._targetClassName = null;\\n\\n      var self = this;\\n\\n      var pointerToId = function(object) {\\n        if (object instanceof Parse.Object) {\\n          if (!object.id) {\\n            throw \\\"You can't add an unsaved Parse.Object to a relation.\\\";\\n          }\\n          if (!self._targetClassName) {\\n            self._targetClassName = object.className;\\n          }\\n          if (self._targetClassName !== object.className) {\\n            throw \\\"Tried to create a Parse.Relation with 2 different types: \\\" +\\n                  self._targetClassName + \\\" and \\\" + object.className + \\\".\\\";\\n          }\\n          return object.id;\\n        }\\n        return object;\\n      };\\n\\n      this.relationsToAdd = _.uniq(_.map(adds, pointerToId));\\n      this.relationsToRemove = _.uniq(_.map(removes, pointerToId));\\n    },\\n\\n    /**\\n     * Returns an array of unfetched Parse.Object that are being added to the\\n     * relation.\\n     * @return {Array}\\n     */\\n    added: function() {\\n      var self = this;\\n      return _.map(this.relationsToAdd, function(objectId) {\\n        var object = Parse.Object._create(self._targetClassName);\\n        object.id = objectId;\\n        return object;\\n      });\\n    },\\n\\n    /**\\n     * Returns an array of unfetched Parse.Object that are being removed from\\n     * the relation.\\n     * @return {Array}\\n     */\\n    removed: function() {\\n      var self = this;\\n      return _.map(this.relationsToRemove, function(objectId) {\\n        var object = Parse.Object._create(self._targetClassName);\\n        object.id = objectId;\\n        return object;\\n      });\\n    },\\n\\n    /**\\n     * Returns a JSON version of the operation suitable for sending to Parse.\\n     * @return {Object}\\n     */\\n    toJSON: function() {\\n      var adds = null;\\n      var removes = null;\\n      var self = this;\\n      var idToPointer = function(id) {\\n        return { __type: 'Pointer',\\n                 className: self._targetClassName,\\n                 objectId: id };\\n      };\\n      var pointers = null;\\n      if (this.relationsToAdd.length > 0) {\\n        pointers = _.map(this.relationsToAdd, idToPointer);\\n        adds = { \\\"__op\\\": \\\"AddRelation\\\", \\\"objects\\\": pointers };\\n      }\\n\\n      if (this.relationsToRemove.length > 0) {\\n        pointers = _.map(this.relationsToRemove, idToPointer);\\n        removes = { \\\"__op\\\": \\\"RemoveRelation\\\", \\\"objects\\\": pointers };\\n      }\\n\\n      if (adds && removes) {\\n        return { \\\"__op\\\": \\\"Batch\\\", \\\"ops\\\": [adds, removes]};\\n      }\\n\\n      return adds || removes || {};\\n    },\\n\\n    _mergeWithPrevious: function(previous) {\\n      if (!previous) {\\n        return this;\\n      } else if (previous instanceof Parse.Op.Unset) {\\n        throw \\\"You can't modify a relation after deleting it.\\\";\\n      } else if (previous instanceof Parse.Op.Relation) {\\n        if (previous._targetClassName &&\\n            previous._targetClassName !== this._targetClassName) {\\n          throw \\\"Related object must be of class \\\" + previous._targetClassName +\\n              \\\", but \\\" + this._targetClassName + \\\" was passed in.\\\";\\n        }\\n        var newAdd = _.union(_.difference(previous.relationsToAdd,\\n                                          this.relationsToRemove),\\n                             this.relationsToAdd);\\n        var newRemove = _.union(_.difference(previous.relationsToRemove,\\n                                             this.relationsToAdd),\\n                                this.relationsToRemove);\\n\\n        var newRelation = new Parse.Op.Relation(newAdd, newRemove);\\n        newRelation._targetClassName = this._targetClassName;\\n        return newRelation;\\n      } else {\\n        throw \\\"Op is invalid after previous op.\\\";\\n      }\\n    },\\n\\n    _estimate: function(oldValue, object, key) {\\n      if (!oldValue) {\\n        var relation = new Parse.Relation(object, key);\\n        relation.targetClassName = this._targetClassName;\\n      } else if (oldValue instanceof Parse.Relation) {\\n        if (this._targetClassName) {\\n          if (oldValue.targetClassName) {\\n            if (oldValue.targetClassName !== this._targetClassName) {\\n              throw \\\"Related object must be a \\\" + oldValue.targetClassName +\\n                  \\\", but a \\\" + this._targetClassName + \\\" was passed in.\\\";\\n            }\\n          } else {\\n            oldValue.targetClassName = this._targetClassName;\\n          }\\n        }\\n        return oldValue;\\n      } else {\\n        throw \\\"Op is invalid after previous op.\\\";\\n      }\\n    }\\n  });\\n\\n  Parse.Op._registerDecoder(\\\"AddRelation\\\", function(json) {\\n    return new Parse.Op.Relation(Parse._decode(undefined, json.objects), []);\\n  });\\n  Parse.Op._registerDecoder(\\\"RemoveRelation\\\", function(json) {\\n    return new Parse.Op.Relation([], Parse._decode(undefined, json.objects));\\n  });\\n\\n}(this));\\n\\n(function(root) {\\n  root.Parse = root.Parse || {};\\n  var Parse = root.Parse;\\n  var _ = Parse._;\\n\\n  /**\\n   * Creates a new Relation for the given parent object and key. This\\n   * constructor should rarely be used directly, but rather created by\\n   * Parse.Object.relation.\\n   * @param {Parse.Object} parent The parent of this relation.\\n   * @param {String} key The key for this relation on the parent.\\n   * @see Parse.Object#relation\\n   * @class\\n   *\\n   * <p>\\n   * A class that is used to access all of the children of a many-to-many\\n   * relationship.  Each instance of Parse.Relation is associated with a\\n   * particular parent object and key.\\n   * </p>\\n   */\\n  Parse.Relation = function(parent, key) {\\n    this.parent = parent;\\n    this.key = key;\\n    this.targetClassName = null;\\n  };\\n\\n  Parse.Relation.prototype = {\\n    /**\\n     * Makes sure that this relation has the right parent and key.\\n     */\\n    _ensureParentAndKey: function(parent, key) {\\n      this.parent = this.parent || parent;\\n      this.key = this.key || key;\\n      if (this.parent !== parent) {\\n        throw \\\"Internal Error. Relation retrieved from two different Objects.\\\";\\n      }\\n      if (this.key !== key) {\\n        throw \\\"Internal Error. Relation retrieved from two different keys.\\\";\\n      }\\n    },\\n\\n    /**\\n     * Adds a Parse.Object or an array of Parse.Objects to the relation.\\n     * @param {} objects The item or items to add.\\n     */\\n    add: function(objects) {\\n      if (!_.isArray(objects)) {\\n        objects = [objects];\\n      }\\n\\n      var change = new Parse.Op.Relation(objects, []);\\n      this.parent.set(this.key, change);\\n      this.targetClassName = change._targetClassName;\\n    },\\n\\n    /**\\n     * Removes a Parse.Object or an array of Parse.Objects from this relation.\\n     * @param {} objects The item or items to remove.\\n     */\\n    remove: function(objects) {\\n      if (!_.isArray(objects)) {\\n        objects = [objects];\\n      }\\n\\n      var change = new Parse.Op.Relation([], objects);\\n      this.parent.set(this.key, change);\\n      this.targetClassName = change._targetClassName;\\n    },\\n\\n    /**\\n     * Returns a JSON version of the object suitable for saving to disk.\\n     * @return {Object}\\n     */\\n    toJSON: function() {\\n      return { \\\"__type\\\": \\\"Relation\\\", \\\"className\\\": this.targetClassName };\\n    },\\n\\n    /**\\n     * Returns a Parse.Query that is limited to objects in this\\n     * relation.\\n     * @return {Parse.Query}\\n     */\\n    query: function() {\\n      var targetClass;\\n      var query;\\n      if (!this.targetClassName) {\\n        targetClass = Parse.Object._getSubclass(this.parent.className);\\n        query = new Parse.Query(targetClass);\\n        query._extraOptions.redirectClassNameForKey = this.key;\\n      } else {\\n        targetClass = Parse.Object._getSubclass(this.targetClassName);\\n        query = new Parse.Query(targetClass);\\n      }\\n      query._addCondition(\\\"$relatedTo\\\", \\\"object\\\", this.parent._toPointer());\\n      query._addCondition(\\\"$relatedTo\\\", \\\"key\\\", this.key);\\n\\n      return query;\\n    }\\n  };\\n}(this));\\n\\n/*global window: false, process: false */\\n(function(root) {\\n  root.Parse = root.Parse || {};\\n  var Parse = root.Parse;\\n  var _ = Parse._;\\n\\n  /**\\n   * A Promise is returned by async methods as a hook to provide callbacks to be\\n   * called when the async task is fulfilled.\\n   *\\n   * <p>Typical usage would be like:<pre>\\n   *    query.find().then(function(results) {\\n   *      results[0].set(\\\"foo\\\", \\\"bar\\\");\\n   *      return results[0].saveAsync();\\n   *    }).then(function(result) {\\n   *      console.log(\\\"Updated \\\" + result.id);\\n   *    });\\n   * </pre></p>\\n   *\\n   * @see Parse.Promise.prototype.then\\n   * @class\\n   */\\n  Parse.Promise = function() {\\n    this._resolved = false;\\n    this._rejected = false;\\n    this._resolvedCallbacks = [];\\n    this._rejectedCallbacks = [];\\n  };\\n\\n  _.extend(Parse.Promise, /** @lends Parse.Promise */ {\\n\\n    _isPromisesAPlusCompliant: false,\\n\\n    /**\\n     * Returns true iff the given object fulfils the Promise interface.\\n     * @return {Boolean}\\n     */\\n    is: function(promise) {\\n      return promise && promise.then && _.isFunction(promise.then);\\n    },\\n\\n    /**\\n     * Returns a new promise that is resolved with a given value.\\n     * @return {Parse.Promise} the new promise.\\n     */\\n    as: function() {\\n      var promise = new Parse.Promise();\\n      promise.resolve.apply(promise, arguments);\\n      return promise;\\n    },\\n\\n    /**\\n     * Returns a new promise that is rejected with a given error.\\n     * @return {Parse.Promise} the new promise.\\n     */\\n    error: function() {\\n      var promise = new Parse.Promise();\\n      promise.reject.apply(promise, arguments);\\n      return promise;\\n    },\\n\\n    /**\\n     * Returns a new promise that is fulfilled when all of the input promises\\n     * are resolved. If any promise in the list fails, then the returned promise\\n     * will fail with the last error. If they all succeed, then the returned\\n     * promise will succeed, with the results being the results of all the input\\n     * promises. For example: <pre>\\n     *   var p1 = Parse.Promise.as(1);\\n     *   var p2 = Parse.Promise.as(2);\\n     *   var p3 = Parse.Promise.as(3);\\n     *\\n     *   Parse.Promise.when(p1, p2, p3).then(function(r1, r2, r3) {\\n     *     console.log(r1);  // prints 1\\n     *     console.log(r2);  // prints 2\\n     *     console.log(r3);  // prints 3\\n     *   });</pre>\\n     *\\n     * The input promises can also be specified as an array: <pre>\\n     *   var promises = [p1, p2, p3];\\n     *   Parse.Promise.when(promises).then(function(r1, r2, r3) {\\n     *     console.log(r1);  // prints 1\\n     *     console.log(r2);  // prints 2\\n     *     console.log(r3);  // prints 3\\n     *   });\\n     * </pre>\\n     * @param {Array} promises a list of promises to wait for.\\n     * @return {Parse.Promise} the new promise.\\n     */\\n    when: function(promises) {\\n      // Allow passing in Promises as separate arguments instead of an Array.\\n      var objects;\\n      if (promises && Parse._isNullOrUndefined(promises.length)) {\\n        objects = arguments;\\n      } else {\\n        objects = promises;\\n      }\\n\\n      var total = objects.length;\\n      var hadError = false;\\n      var results = [];\\n      var errors = [];\\n      results.length = objects.length;\\n      errors.length = objects.length;\\n\\n      if (total === 0) {\\n        return Parse.Promise.as.apply(this, results);\\n      }\\n\\n      var promise = new Parse.Promise();\\n\\n      var resolveOne = function() {\\n        total = total - 1;\\n        if (total === 0) {\\n          if (hadError) {\\n            promise.reject(errors);\\n          } else {\\n            promise.resolve.apply(promise, results);\\n          }\\n        }\\n      };\\n\\n      Parse._arrayEach(objects, function(object, i) {\\n        if (Parse.Promise.is(object)) {\\n          object.then(function(result) {\\n            results[i] = result;\\n            resolveOne();\\n          }, function(error) {\\n            errors[i] = error;\\n            hadError = true;\\n            resolveOne();\\n          });\\n        } else {\\n          results[i] = object;\\n          resolveOne();\\n        }\\n      });\\n\\n      return promise;\\n    },\\n\\n    /**\\n     * Runs the given asyncFunction repeatedly, as long as the predicate\\n     * function returns a truthy value. Stops repeating if asyncFunction returns\\n     * a rejected promise.\\n     * @param {Function} predicate should return false when ready to stop.\\n     * @param {Function} asyncFunction should return a Promise.\\n     */\\n    _continueWhile: function(predicate, asyncFunction) {\\n      if (predicate()) {\\n        return asyncFunction().then(function() {\\n          return Parse.Promise._continueWhile(predicate, asyncFunction);\\n        });\\n      }\\n      return Parse.Promise.as();\\n    }\\n  });\\n\\n  _.extend(Parse.Promise.prototype, /** @lends Parse.Promise.prototype */ {\\n\\n    /**\\n     * Marks this promise as fulfilled, firing any callbacks waiting on it.\\n     * @param {Object} result the result to pass to the callbacks.\\n     */\\n    resolve: function(result) {\\n      if (this._resolved || this._rejected) {\\n        throw \\\"A promise was resolved even though it had already been \\\" +\\n          (this._resolved ? \\\"resolved\\\" : \\\"rejected\\\") + \\\".\\\";\\n      }\\n      this._resolved = true;\\n      this._result = arguments;\\n      var results = arguments;\\n      Parse._arrayEach(this._resolvedCallbacks, function(resolvedCallback) {\\n        resolvedCallback.apply(this, results);\\n      });\\n      this._resolvedCallbacks = [];\\n      this._rejectedCallbacks = [];\\n    },\\n\\n    /**\\n     * Marks this promise as fulfilled, firing any callbacks waiting on it.\\n     * @param {Object} error the error to pass to the callbacks.\\n     */\\n    reject: function(error) {\\n      if (this._resolved || this._rejected) {\\n        throw \\\"A promise was rejected even though it had already been \\\" +\\n          (this._resolved ? \\\"resolved\\\" : \\\"rejected\\\") + \\\".\\\";\\n      }\\n      this._rejected = true;\\n      this._error = error;\\n      Parse._arrayEach(this._rejectedCallbacks, function(rejectedCallback) {\\n        rejectedCallback(error);\\n      });\\n      this._resolvedCallbacks = [];\\n      this._rejectedCallbacks = [];\\n    },\\n\\n    /**\\n     * Adds callbacks to be called when this promise is fulfilled. Returns a new\\n     * Promise that will be fulfilled when the callback is complete. It allows\\n     * chaining. If the callback itself returns a Promise, then the one returned\\n     * by \\\"then\\\" will not be fulfilled until that one returned by the callback\\n     * is fulfilled.\\n     * @param {Function} resolvedCallback Function that is called when this\\n     * Promise is resolved. Once the callback is complete, then the Promise\\n     * returned by \\\"then\\\" will also be fulfilled.\\n     * @param {Function} rejectedCallback Function that is called when this\\n     * Promise is rejected with an error. Once the callback is complete, then\\n     * the promise returned by \\\"then\\\" with be resolved successfully. If\\n     * rejectedCallback is null, or it returns a rejected Promise, then the\\n     * Promise returned by \\\"then\\\" will be rejected with that error.\\n     * @return {Parse.Promise} A new Promise that will be fulfilled after this\\n     * Promise is fulfilled and either callback has completed. If the callback\\n     * returned a Promise, then this Promise will not be fulfilled until that\\n     * one is.\\n     */\\n    then: function(resolvedCallback, rejectedCallback) {\\n      var promise = new Parse.Promise();\\n\\n      var wrappedResolvedCallback = function() {\\n        var result = arguments;\\n        if (resolvedCallback) {\\n          if (Parse.Promise._isPromisesAPlusCompliant) {\\n            try {\\n              result = [resolvedCallback.apply(this, result)];\\n            } catch (e) {\\n              result = [Parse.Promise.error(e)];\\n            }\\n          } else {\\n            result = [resolvedCallback.apply(this, result)];\\n          }\\n        }\\n        if (result.length === 1 && Parse.Promise.is(result[0])) {\\n          result[0].then(function() {\\n            promise.resolve.apply(promise, arguments);\\n          }, function(error) {\\n            promise.reject(error);\\n          });\\n        } else {\\n          promise.resolve.apply(promise, result);\\n        }\\n      };\\n\\n      var wrappedRejectedCallback = function(error) {\\n        var result = [];\\n        if (rejectedCallback) {\\n          if (Parse.Promise._isPromisesAPlusCompliant) {\\n            try {\\n              result = [rejectedCallback(error)];\\n            } catch (e) {\\n              result = [Parse.Promise.error(e)];\\n            }\\n          } else {\\n            result = [rejectedCallback(error)];\\n          }\\n          if (result.length === 1 && Parse.Promise.is(result[0])) {\\n            result[0].then(function() {\\n              promise.resolve.apply(promise, arguments);\\n            }, function(error) {\\n              promise.reject(error);\\n            });\\n          } else {\\n            if (Parse.Promise._isPromisesAPlusCompliant) {\\n              promise.resolve.apply(promise, result);\\n            } else {\\n              promise.reject(result[0]);\\n            }\\n          }\\n        } else {\\n          promise.reject(error);\\n        }\\n      };\\n\\n      var runLater = function(func) {\\n        func.call();\\n      };\\n      if (Parse.Promise._isPromisesAPlusCompliant) {\\n        if (typeof(window) !== 'undefined' && window.setTimeout) {\\n          runLater = function(func) {\\n            window.setTimeout(func, 0);\\n          };\\n        } else if (typeof(process) !== 'undefined' && process.nextTick) {\\n          runLater = function(func) {\\n            process.nextTick(func);\\n          };\\n        }\\n      }\\n\\n      var self = this;\\n      if (this._resolved) {\\n        runLater(function() {\\n          wrappedResolvedCallback.apply(self, self._result);\\n        });\\n      } else if (this._rejected) {\\n        runLater(function() {\\n          wrappedRejectedCallback(self._error);\\n        });\\n      } else {\\n        this._resolvedCallbacks.push(wrappedResolvedCallback);\\n        this._rejectedCallbacks.push(wrappedRejectedCallback);\\n      }\\n\\n      return promise;\\n    },\\n\\n    /**\\n     * Add handlers to be called when the promise \\n     * is either resolved or rejected\\n     */\\n    always: function(callback) {\\n      return this.then(callback, callback);\\n    },\\n\\n    /**\\n     * Add handlers to be called when the Promise object is resolved\\n     */\\n    done: function(callback) {\\n      return this.then(callback);\\n    },\\n\\n    /**\\n     * Add handlers to be called when the Promise object is rejected\\n     */\\n    fail: function(callback) {\\n      return this.then(null, callback);\\n    },\\n\\n    /**\\n     * Run the given callbacks after this promise is fulfilled.\\n     * @param optionsOrCallback {} A Backbone-style options callback, or a\\n     * callback function. If this is an options object and contains a \\\"model\\\"\\n     * attributes, that will be passed to error callbacks as the first argument.\\n     * @param model {} If truthy, this will be passed as the first result of\\n     * error callbacks. This is for Backbone-compatability.\\n     * @return {Parse.Promise} A promise that will be resolved after the\\n     * callbacks are run, with the same result as this.\\n     */\\n    _thenRunCallbacks: function(optionsOrCallback, model) {\\n      var options;\\n      if (_.isFunction(optionsOrCallback)) {\\n        var callback = optionsOrCallback;\\n        options = {\\n          success: function(result) {\\n            callback(result, null);\\n          },\\n          error: function(error) {\\n            callback(null, error);\\n          }\\n        };\\n      } else {\\n        options = _.clone(optionsOrCallback);\\n      }\\n      options = options || {};\\n\\n      return this.then(function(result) {\\n        if (options.success) {\\n          options.success.apply(this, arguments);\\n        } else if (model) {\\n          // When there's no callback, a sync event should be triggered.\\n          model.trigger('sync', model, result, options);\\n        }\\n        return Parse.Promise.as.apply(Parse.Promise, arguments);\\n      }, function(error) {\\n        if (options.error) {\\n          if (!_.isUndefined(model)) {\\n            options.error(model, error);\\n          } else {\\n            options.error(error);\\n          }\\n        } else if (model) {\\n          // When there's no error callback, an error event should be triggered.\\n          model.trigger('error', model, error, options);\\n        }\\n        // By explicitly returning a rejected Promise, this will work with\\n        // either jQuery or Promises/A semantics.\\n        return Parse.Promise.error(error);\\n      });\\n    },\\n\\n    /**\\n     * Adds a callback function that should be called regardless of whether\\n     * this promise failed or succeeded. The callback will be given either the\\n     * array of results for its first argument, or the error as its second,\\n     * depending on whether this Promise was rejected or resolved. Returns a\\n     * new Promise, like \\\"then\\\" would.\\n     * @param {Function} continuation the callback.\\n     */\\n    _continueWith: function(continuation) {\\n      return this.then(function() {\\n        return continuation(arguments, null);\\n      }, function(error) {\\n        return continuation(null, error);\\n      });\\n    }\\n\\n  });\\n\\n}(this));\\n\\n/*jshint bitwise:false *//*global FileReader: true, File: true */\\n(function(root) {\\n  root.Parse = root.Parse || {};\\n  var Parse = root.Parse;\\n  var _ = Parse._;\\n\\n  var b64Digit = function(number) {\\n    if (number < 26) {\\n      return String.fromCharCode(65 + number);\\n    }\\n    if (number < 52) {\\n      return String.fromCharCode(97 + (number - 26));\\n    }\\n    if (number < 62) {\\n      return String.fromCharCode(48 + (number - 52));\\n    }\\n    if (number === 62) {\\n      return \\\"+\\\";\\n    }\\n    if (number === 63) {\\n      return \\\"/\\\";\\n    }\\n    throw \\\"Tried to encode large digit \\\" + number + \\\" in base64.\\\";\\n  };\\n\\n  var encodeBase64 = function(array) {\\n    var chunks = [];\\n    chunks.length = Math.ceil(array.length / 3);\\n    _.times(chunks.length, function(i) {\\n      var b1 = array[i * 3];\\n      var b2 = array[i * 3 + 1] || 0;\\n      var b3 = array[i * 3 + 2] || 0;\\n\\n      var has2 = (i * 3 + 1) < array.length;\\n      var has3 = (i * 3 + 2) < array.length;\\n\\n      chunks[i] = [\\n        b64Digit((b1 >> 2) & 0x3F),\\n        b64Digit(((b1 << 4) & 0x30) | ((b2 >> 4) & 0x0F)),\\n        has2 ? b64Digit(((b2 << 2) & 0x3C) | ((b3 >> 6) & 0x03)) : \\\"=\\\",\\n        has3 ? b64Digit(b3 & 0x3F) : \\\"=\\\"\\n      ].join(\\\"\\\");\\n    });\\n    return chunks.join(\\\"\\\");\\n  };\\n\\n  /**\\n   * Reads a File using a FileReader.\\n   * @param file {File} the File to read.\\n   * @param type {String} (optional) the mimetype to override with.\\n   * @return {Parse.Promise} A Promise that will be fulfilled with a\\n   *     base64-encoded string of the data and its mime type.\\n   */\\n  var readAsync = function(file, type) {\\n    var promise = new Parse.Promise();\\n\\n    if (typeof(FileReader) === \\\"undefined\\\") {\\n      return Parse.Promise.error(new Parse.Error(\\n          Parse.Error.FILE_READ_ERROR,\\n          \\\"Attempted to use a FileReader on an unsupported browser.\\\"));\\n    }\\n\\n    var reader = new FileReader();\\n    reader.onloadend = function() {\\n      if (reader.readyState !== 2) {\\n        promise.reject(new Parse.Error(\\n            Parse.Error.FILE_READ_ERROR,\\n            \\\"Error reading file.\\\"));\\n        return;\\n      }\\n\\n      var dataURL = reader.result;\\n      var matches = /^data:([^;]*);base64,(.*)$/.exec(dataURL);\\n      if (!matches) {\\n        promise.reject(new Parse.Error(\\n            Parse.Error.FILE_READ_ERROR,\\n            \\\"Unable to interpret data URL: \\\" + dataURL));\\n        return;\\n      }\\n\\n      promise.resolve(matches[2], type || matches[1]);\\n    };\\n    reader.readAsDataURL(file);\\n    return promise;\\n  };\\n\\n  /**\\n   * A Parse.File is a local representation of a file that is saved to the Parse\\n   * cloud.\\n   * @class\\n   * @param name {String} The file's name. This will be prefixed by a unique\\n   *     value once the file has finished saving. The file name must begin with\\n   *     an alphanumeric character, and consist of alphanumeric characters,\\n   *     periods, spaces, underscores, or dashes.\\n   * @param data {Array} The data for the file, as either:\\n   *     1. an Array of byte value Numbers, or\\n   *     2. an Object like { base64: \\\"...\\\" } with a base64-encoded String.\\n   *     3. a File object selected with a file upload control. (3) only works\\n   *        in Firefox 3.6+, Safari 6.0.2+, Chrome 7+, and IE 10+.\\n   *        For example:<pre>\\n   * var fileUploadControl = $(\\\"#profilePhotoFileUpload\\\")[0];\\n   * if (fileUploadControl.files.length > 0) {\\n   *   var file = fileUploadControl.files[0];\\n   *   var name = \\\"photo.jpg\\\";\\n   *   var parseFile = new Parse.File(name, file);\\n   *   parseFile.save().then(function() {\\n   *     // The file has been saved to Parse.\\n   *   }, function(error) {\\n   *     // The file either could not be read, or could not be saved to Parse.\\n   *   });\\n   * }</pre>\\n   * @param type {String} Optional Content-Type header to use for the file. If\\n   *     this is omitted, the content type will be inferred from the name's\\n   *     extension.\\n   */\\n  Parse.File = function(name, data, type) {\\n    this._name = name;\\n\\n    // Guess the content type from the extension if we need to.\\n    var extension = /\\\\.([^.]*)$/.exec(name);\\n    if (extension) {\\n      extension = extension[1].toLowerCase();\\n    }\\n    var specifiedType = type || '';\\n\\n    if (_.isArray(data)) {\\n      this._source = Parse.Promise.as(encodeBase64(data), specifiedType);\\n    } else if (data && data.base64) {\\n      // if it contains data uri, extract based64 and the type out of it.\\n      /*jslint maxlen: 1000*/\\n      var dataUriRegexp = /^data:([a-zA-Z]*\\\\/[a-zA-Z+.-]*);(charset=[a-zA-Z0-9\\\\-\\\\/\\\\s]*,)?base64,(\\\\S+)/;\\n      /*jslint maxlen: 80*/\\n\\n      var matches = dataUriRegexp.exec(data.base64);\\n      if (matches && matches.length > 0) {\\n        // if data URI with charset, there will have 4 matches.\\n        this._source = Parse.Promise.as(\\n          (matches.length === 4 ? matches[3] : matches[2]), matches[1]\\n        );\\n      } else {\\n        this._source = Parse.Promise.as(data.base64, specifiedType);\\n      }\\n    } else if (typeof(File) !== \\\"undefined\\\" && data instanceof File) {\\n      this._source = readAsync(data, type);\\n    } else if (_.isString(data)) {\\n      throw \\\"Creating a Parse.File from a String is not yet supported.\\\";\\n    }\\n  };\\n\\n  Parse.File.prototype = {\\n\\n    /**\\n     * Gets the name of the file. Before save is called, this is the filename\\n     * given by the user. After save is called, that name gets prefixed with a\\n     * unique identifier.\\n     */\\n    name: function() {\\n      return this._name;\\n    },\\n\\n    /**\\n     * Gets the url of the file. It is only available after you save the file or\\n     * after you get the file from a Parse.Object.\\n     * @return {String}\\n     */\\n    url: function() {\\n      return this._url;\\n    },\\n\\n    /**\\n     * Saves the file to the Parse cloud.\\n     * @param {Object} options A Backbone-style options object.\\n     * @return {Parse.Promise} Promise that is resolved when the save finishes.\\n     */\\n    save: function(options) {\\n      options= options || {};\\n\\n      var self = this;\\n      if (!self._previousSave) {\\n        self._previousSave = self._source.then(function(base64, type) {\\n          var data = {\\n            base64: base64,\\n            _ContentType: type\\n          };\\n          return Parse._request({\\n            route: \\\"files\\\",\\n            className: self._name,\\n            method: 'POST',\\n            data: data,\\n            useMasterKey: options.useMasterKey\\n          });\\n\\n        }).then(function(response) {\\n          self._name = response.name;\\n          self._url = response.url;\\n          return self;\\n        });\\n      }\\n      return self._previousSave._thenRunCallbacks(options);\\n    }\\n  };\\n\\n}(this));\\n\\n// Parse.Object is analogous to the Java ParseObject.\\n// It also implements the same interface as a Backbone model.\\n// TODO: multiple dispatch for callbacks\\n(function(root) {\\n  root.Parse = root.Parse || {};\\n  var Parse = root.Parse;\\n  var _ = Parse._;\\n\\n  /**\\n   * Creates a new model with defined attributes. A client id (cid) is\\n   * automatically generated and assigned for you.\\n   *\\n   * <p>You won't normally call this method directly.  It is recommended that\\n   * you use a subclass of <code>Parse.Object</code> instead, created by calling\\n   * <code>extend</code>.</p>\\n   *\\n   * <p>However, if you don't want to use a subclass, or aren't sure which\\n   * subclass is appropriate, you can use this form:<pre>\\n   *     var object = new Parse.Object(\\\"ClassName\\\");\\n   * </pre>\\n   * That is basically equivalent to:<pre>\\n   *     var MyClass = Parse.Object.extend(\\\"ClassName\\\");\\n   *     var object = new MyClass();\\n   * </pre></p>\\n   *\\n   * @param {Object} attributes The initial set of data to store in the object.\\n   * @param {Object} options A set of Backbone-like options for creating the\\n   *     object.  The only option currently supported is \\\"collection\\\".\\n   * @see Parse.Object.extend\\n   *\\n   * @class\\n   *\\n   * <p>The fundamental unit of Parse data, which implements the Backbone Model\\n   * interface.</p>\\n   */\\n  Parse.Object = function(attributes, options) {\\n    // Allow new Parse.Object(\\\"ClassName\\\") as a shortcut to _create.\\n    if (_.isString(attributes)) {\\n      return Parse.Object._create.apply(this, arguments);\\n    }\\n\\n    attributes = attributes || {};\\n    if (options && options.parse) {\\n      attributes = this.parse(attributes);\\n    }\\n    var defaults = Parse._getValue(this, 'defaults');\\n    if (defaults) {\\n      attributes = _.extend({}, defaults, attributes);\\n    }\\n    if (options && options.collection) {\\n      this.collection = options.collection;\\n    }\\n\\n    this._serverData = {};  // The last known data for this object from cloud.\\n    this._opSetQueue = [{}];  // List of sets of changes to the data.\\n    this.attributes = {};  // The best estimate of this's current data.\\n\\n    this._hashedJSON = {};  // Hash of values of containers at last save.\\n    this._escapedAttributes = {};\\n    this.cid = _.uniqueId('c');\\n    this.changed = {};\\n    this._silent = {};\\n    this._pending = {};\\n    if (!this.set(attributes, {silent: true})) {\\n      throw new Error(\\\"Can't create an invalid Parse.Object\\\");\\n    }\\n    this.changed = {};\\n    this._silent = {};\\n    this._pending = {};\\n    this._hasData = true;\\n    this._previousAttributes = _.clone(this.attributes);\\n    this.initialize.apply(this, arguments);\\n  };\\n\\n  /**\\n   * The ID of this object, unique within its class.\\n   * @name id\\n   * @type String\\n   * @field\\n   * @memberOf Parse.Object.prototype\\n   */\\n\\n  /**\\n   * The first time this object was saved on the server.\\n   * @name createdAt\\n   * @type Date\\n   * @field\\n   * @memberOf Parse.Object.prototype\\n   */\\n\\n  /**\\n   * The last time this object was updated on the server.\\n   * @name updatedAt\\n   * @type Date\\n   * @field\\n   * @memberOf Parse.Object.prototype\\n   */\\n\\n  /**\\n   * Saves the given list of Parse.Object.\\n   * If any error is encountered, stops and calls the error handler.\\n   *\\n   * <pre>\\n   *   Parse.Object.saveAll([object1, object2, ...], {\\n   *     success: function(list) {\\n   *       // All the objects were saved.\\n   *     },\\n   *     error: function(error) {\\n   *       // An error occurred while saving one of the objects.\\n   *     },\\n   *   });\\n   * </pre>\\n   *\\n   * @param {Array} list A list of <code>Parse.Object</code>.\\n   * @param {Object} options A Backbone-style callback object.\\n   * Valid options are:<ul>\\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\\n   *     be used for this request.\\n   *   <li>sessionToken: A valid session token, used for making a request on\\n   *       behalf of a specific user.\\n   * </ul>\\n   */\\n  Parse.Object.saveAll = function(list, options) {\\n    options = options || {};\\n    return Parse.Object._deepSaveAsync(list, {\\n      useMasterKey: options.useMasterKey,\\n      sessionToken: options.sessionToken\\n    })._thenRunCallbacks(options);\\n  };\\n\\n  /**\\n   * Destroy the given list of models on the server if it was already persisted.\\n   * Optimistically removes each model from its collection, if it has one.\\n   * If `wait: true` is passed, waits for the server to respond before removal.\\n   *\\n   * <p>Unlike saveAll, if an error occurs while deleting an individual model,\\n   * this method will continue trying to delete the rest of the models if\\n   * possible, except in the case of a fatal error like a connection error.\\n   *\\n   * <p>In particular, the Parse.Error object returned in the case of error may\\n   * be one of two types:\\n   *\\n   * <ul>\\n   *   <li>A Parse.Error.AGGREGATE_ERROR. This object's \\\"errors\\\" property is an\\n   *       array of other Parse.Error objects. Each error object in this array\\n   *       has an \\\"object\\\" property that references the object that could not be\\n   *       deleted (for instance, because that object could not be found).</li>\\n   *   <li>A non-aggregate Parse.Error. This indicates a serious error that\\n   *       caused the delete operation to be aborted partway through (for\\n   *       instance, a connection failure in the middle of the delete).</li>\\n   * </ul>\\n   *\\n   * <pre>\\n   *   Parse.Object.destroyAll([object1, object2, ...], {\\n   *     success: function() {\\n   *       // All the objects were deleted.\\n   *     },\\n   *     error: function(error) {\\n   *       // An error occurred while deleting one or more of the objects.\\n   *       // If this is an aggregate error, then we can inspect each error\\n   *       // object individually to determine the reason why a particular\\n   *       // object was not deleted.\\n   *       if (error.code == Parse.Error.AGGREGATE_ERROR) {\\n   *         for (var i = 0; i < error.errors.length; i++) {\\n   *           console.log(\\\"Couldn't delete \\\" + error.errors[i].object.id +\\n   *             \\\"due to \\\" + error.errors[i].message);\\n   *         }\\n   *       } else {\\n   *         console.log(\\\"Delete aborted because of \\\" + error.message);\\n   *       }\\n   *     },\\n   *   });\\n   * </pre>\\n   *\\n   * @param {Array} list A list of <code>Parse.Object</code>.\\n   * @param {Object} options A Backbone-style callback object.\\n   * Valid options are:<ul>\\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\\n   *     be used for this request.\\n   *   <li>sessionToken: A valid session token, used for making a request on\\n   *       behalf of a specific user.\\n   * </ul>\\n   * @return {Parse.Promise} A promise that is fulfilled when the destroyAll\\n   *     completes.\\n   */\\n  Parse.Object.destroyAll = function(list, options) {\\n    options = options || {};\\n\\n    var triggerDestroy = function(object) {\\n      object.trigger('destroy', object, object.collection, options);\\n    };\\n\\n    var errors = [];\\n    var destroyBatch = function(batch) {\\n      var promise = Parse.Promise.as();\\n\\n      if (batch.length > 0) {\\n        promise = promise.then(function() {\\n          return Parse._request({\\n            route: \\\"batch\\\",\\n            method: \\\"POST\\\",\\n            useMasterKey: options.useMasterKey,\\n            sessionToken: options.sessionToken,\\n            data: {\\n              requests: _.map(batch, function(object) {\\n                return {\\n                  method: \\\"DELETE\\\",\\n                  path: \\\"/1/classes/\\\" + object.className + \\\"/\\\" + object.id\\n                };\\n              })\\n            }\\n          });\\n        }).then(function(responses, status, xhr) {\\n          Parse._arrayEach(batch, function(object, i) {\\n            if (responses[i].success && options.wait) {\\n              triggerDestroy(object);\\n            } else if (responses[i].error) {\\n              var error = new Parse.Error(responses[i].error.code,\\n                                          responses[i].error.error);\\n              error.object = object;\\n\\n              errors.push(error);\\n            }\\n          });\\n        });\\n      }\\n\\n      return promise;\\n    };\\n\\n    var promise = Parse.Promise.as();\\n    var batch = [];\\n    Parse._arrayEach(list, function(object, i) {\\n      if (!object.id || !options.wait) {\\n        triggerDestroy(object);\\n      }\\n\\n      if (object.id) {\\n        batch.push(object);\\n      }\\n\\n      if (batch.length === 20 || i+1 === list.length) {\\n        var thisBatch = batch;\\n        batch = [];\\n\\n        promise = promise.then(function() {\\n          return destroyBatch(thisBatch);\\n        });\\n      }\\n    });\\n\\n    return promise.then(function() {\\n      if (errors.length === 0) {\\n        return true;\\n      } else {\\n        var error = new Parse.Error(Parse.Error.AGGREGATE_ERROR,\\n                                    \\\"Error deleting an object in destroyAll\\\");\\n        error.errors = errors;\\n\\n        return Parse.Promise.error(error);\\n      }\\n    })._thenRunCallbacks(options);\\n  };\\n\\n  /**\\n   * Fetches the given list of Parse.Object.\\n   * If any error is encountered, stops and calls the error handler.\\n   *\\n   * <pre>\\n   *   Parse.Object.fetchAll([object1, object2, ...], {\\n   *     success: function(list) {\\n   *       // All the objects were fetched.\\n   *     },\\n   *     error: function(error) {\\n   *       // An error occurred while fetching one of the objects.\\n   *     },\\n   *   });\\n   * </pre>\\n   *\\n   * @param {Array} list A list of <code>Parse.Object</code>.\\n   * @param {Object} options A Backbone-style callback object.\\n   * Valid options are:<ul>\\n   *   <li>success: A Backbone-style success callback.\\n   *   <li>error: An Backbone-style error callback.\\n   * </ul>\\n   */\\n  Parse.Object.fetchAll = function(list, options) {\\n    return Parse.Object._fetchAll(\\n      list,\\n      true\\n    )._thenRunCallbacks(options);\\n  };\\n\\n  /**\\n   * Fetches the given list of Parse.Object if needed.\\n   * If any error is encountered, stops and calls the error handler.\\n   *\\n   * <pre>\\n   *   Parse.Object.fetchAllIfNeeded([object1, ...], {\\n   *     success: function(list) {\\n   *       // Objects were fetched and updated.\\n   *     },\\n   *     error: function(error) {\\n   *       // An error occurred while fetching one of the objects.\\n   *     },\\n   *   });\\n   * </pre>\\n   *\\n   * @param {Array} list A list of <code>Parse.Object</code>.\\n   * @param {Object} options A Backbone-style callback object.\\n   * Valid options are:<ul>\\n   *   <li>success: A Backbone-style success callback.\\n   *   <li>error: An Backbone-style error callback.\\n   * </ul>\\n   */\\n  Parse.Object.fetchAllIfNeeded = function(list, options) {\\n    return Parse.Object._fetchAll(\\n      list,\\n      false\\n    )._thenRunCallbacks(options);\\n  };\\n\\n  // Attach all inheritable methods to the Parse.Object prototype.\\n  _.extend(Parse.Object.prototype, Parse.Events,\\n           /** @lends Parse.Object.prototype */ {\\n    _existed: false,\\n\\n    /**\\n     * Initialize is an empty function by default. Override it with your own\\n     * initialization logic.\\n     */\\n    initialize: function(){},\\n\\n    /**\\n     * Returns a JSON version of the object suitable for saving to Parse.\\n     * @return {Object}\\n     */\\n    toJSON: function() {\\n      var json = this._toFullJSON();\\n      Parse._arrayEach([\\\"__type\\\", \\\"className\\\"],\\n                       function(key) { delete json[key]; });\\n      return json;\\n    },\\n\\n    _toFullJSON: function(seenObjects) {\\n      var json = _.clone(this.attributes);\\n      Parse._objectEach(json, function(val, key) {\\n        json[key] = Parse._encode(val, seenObjects);\\n      });\\n      Parse._objectEach(this._operations, function(val, key) {\\n        json[key] = val;\\n      });\\n\\n      if (_.has(this, \\\"id\\\")) {\\n        json.objectId = this.id;\\n      }\\n      if (_.has(this, \\\"createdAt\\\")) {\\n        if (_.isDate(this.createdAt)) {\\n          json.createdAt = this.createdAt.toJSON();\\n        } else {\\n          json.createdAt = this.createdAt;\\n        }\\n      }\\n\\n      if (_.has(this, \\\"updatedAt\\\")) {\\n        if (_.isDate(this.updatedAt)) {\\n          json.updatedAt = this.updatedAt.toJSON();\\n        } else {\\n          json.updatedAt = this.updatedAt;\\n        }\\n      }\\n      json.__type = \\\"Object\\\";\\n      json.className = this.className;\\n      return json;\\n    },\\n\\n    /**\\n     * Updates _hashedJSON to reflect the current state of this object.\\n     * Adds any changed hash values to the set of pending changes.\\n     */\\n    _refreshCache: function() {\\n      var self = this;\\n      if (self._refreshingCache) {\\n        return;\\n      }\\n      self._refreshingCache = true;\\n      Parse._objectEach(this.attributes, function(value, key) {\\n        if (value instanceof Parse.Object) {\\n          value._refreshCache();\\n        } else if (_.isObject(value)) {\\n          var objectArray = false;\\n          if (_.isArray(value)) {\\n            // We don't cache arrays of Parse.Objects\\n            _.each(value, function(arrVal) {\\n              if (arrVal instanceof Parse.Object) {\\n                objectArray = true;\\n                arrVal._refreshCache();\\n              }\\n            });\\n          }\\n          if (!objectArray && self._resetCacheForKey(key)) {\\n            self.set(key, new Parse.Op.Set(value), { silent: true });\\n          }\\n        }\\n      });\\n      delete self._refreshingCache;\\n    },\\n\\n    /**\\n     * Returns true if this object has been modified since its last\\n     * save/refresh.  If an attribute is specified, it returns true only if that\\n     * particular attribute has been modified since the last save/refresh.\\n     * @param {String} attr An attribute name (optional).\\n     * @return {Boolean}\\n     */\\n    dirty: function(attr) {\\n      this._refreshCache();\\n\\n      var currentChanges = _.last(this._opSetQueue);\\n\\n      if (attr) {\\n        return (currentChanges[attr] ? true : false);\\n      }\\n      if (!this.id) {\\n        return true;\\n      }\\n      if (_.keys(currentChanges).length > 0) {\\n        return true;\\n      }\\n      return false;\\n    },\\n\\n    /**\\n     * Returns an array of keys that have been modified since last save/refresh\\n     * @return {Array of string}\\n     */\\n    dirtyKeys: function() {\\n      return _.keys(_.last(this._opSetQueue));\\n    },\\n\\n    /**\\n     * Gets a Pointer referencing this Object.\\n     */\\n    _toPointer: function() {\\n      if (!this.id) {\\n        throw new Error(\\\"Can't serialize an unsaved Parse.Object\\\");\\n      }\\n      return { __type: \\\"Pointer\\\",\\n               className: this.className,\\n               objectId: this.id };\\n    },\\n\\n    /**\\n     * Gets the value of an attribute.\\n     * @param {String} attr The string name of an attribute.\\n     */\\n    get: function(attr) {\\n      return this.attributes[attr];\\n    },\\n\\n    /**\\n     * Gets a relation on the given class for the attribute.\\n     * @param String attr The attribute to get the relation for.\\n     */\\n    relation: function(attr) {\\n      var value = this.get(attr);\\n      if (value) {\\n        if (!(value instanceof Parse.Relation)) {\\n          throw \\\"Called relation() on non-relation field \\\" + attr;\\n        }\\n        value._ensureParentAndKey(this, attr);\\n        return value;\\n      } else {\\n        return new Parse.Relation(this, attr);\\n      }\\n    },\\n\\n    /**\\n     * Gets the HTML-escaped value of an attribute.\\n     */\\n    escape: function(attr) {\\n      var html = this._escapedAttributes[attr];\\n      if (html) {\\n        return html;\\n      }\\n      var val = this.attributes[attr];\\n      var escaped;\\n      if (Parse._isNullOrUndefined(val)) {\\n        escaped = '';\\n      } else {\\n        escaped = _.escape(val.toString());\\n      }\\n      this._escapedAttributes[attr] = escaped;\\n      return escaped;\\n    },\\n\\n    /**\\n     * Returns <code>true</code> if the attribute contains a value that is not\\n     * null or undefined.\\n     * @param {String} attr The string name of the attribute.\\n     * @return {Boolean}\\n     */\\n    has: function(attr) {\\n      return !Parse._isNullOrUndefined(this.attributes[attr]);\\n    },\\n\\n    /**\\n     * Pulls \\\"special\\\" fields like objectId, createdAt, etc. out of attrs\\n     * and puts them on \\\"this\\\" directly.  Removes them from attrs.\\n     * @param attrs - A dictionary with the data for this Parse.Object.\\n     */\\n    _mergeMagicFields: function(attrs) {\\n      // Check for changes of magic fields.\\n      var model = this;\\n      var specialFields = [\\\"id\\\", \\\"objectId\\\", \\\"createdAt\\\", \\\"updatedAt\\\"];\\n      Parse._arrayEach(specialFields, function(attr) {\\n        if (attrs[attr]) {\\n          if (attr === \\\"objectId\\\") {\\n            model.id = attrs[attr];\\n          } else if ((attr === \\\"createdAt\\\" || attr === \\\"updatedAt\\\") &&\\n                     !_.isDate(attrs[attr])) {\\n            model[attr] = Parse._parseDate(attrs[attr]);\\n          } else {\\n            model[attr] = attrs[attr];\\n          }\\n          delete attrs[attr];\\n        }\\n      });\\n    },\\n\\n    /**\\n     * Copies the given serverData to \\\"this\\\", refreshes attributes, and\\n     * clears pending changes;\\n     */\\n    _copyServerData: function(serverData) {\\n      // Copy server data\\n      var tempServerData = {};\\n      Parse._objectEach(serverData, function(value, key) {\\n        tempServerData[key] = Parse._decode(key, value);\\n      });\\n      this._serverData = tempServerData;\\n\\n      // Refresh the attributes.\\n      this._rebuildAllEstimatedData();\\n\\n      // TODO (bklimt): Revisit clearing operations, perhaps move to revert.\\n      // Clear out any changes the user might have made previously.\\n      this._refreshCache();\\n      this._opSetQueue = [{}];\\n\\n      // Refresh the attributes again.\\n      this._rebuildAllEstimatedData();\\n    },\\n\\n    /**\\n     * Merges another object's attributes into this object.\\n     */\\n    _mergeFromObject: function(other) {\\n      if (!other) {\\n        return;\\n      }\\n\\n      // This does the inverse of _mergeMagicFields.\\n      this.id = other.id;\\n      this.createdAt = other.createdAt;\\n      this.updatedAt = other.updatedAt;\\n\\n      this._copyServerData(other._serverData);\\n\\n      this._hasData = true;\\n    },\\n\\n    /**\\n     * Returns the json to be sent to the server.\\n     */\\n    _startSave: function() {\\n      this._opSetQueue.push({});\\n    },\\n\\n    /**\\n     * Called when a save fails because of an error. Any changes that were part\\n     * of the save need to be merged with changes made after the save. This\\n     * might throw an exception is you do conflicting operations. For example,\\n     * if you do:\\n     *   object.set(\\\"foo\\\", \\\"bar\\\");\\n     *   object.set(\\\"invalid field name\\\", \\\"baz\\\");\\n     *   object.save();\\n     *   object.increment(\\\"foo\\\");\\n     * then this will throw when the save fails and the client tries to merge\\n     * \\\"bar\\\" with the +1.\\n     */\\n    _cancelSave: function() {\\n      var self = this;\\n      var failedChanges = _.first(this._opSetQueue);\\n      this._opSetQueue = _.rest(this._opSetQueue);\\n      var nextChanges = _.first(this._opSetQueue);\\n      Parse._objectEach(failedChanges, function(op, key) {\\n        var op1 = failedChanges[key];\\n        var op2 = nextChanges[key];\\n        if (op1 && op2) {\\n          nextChanges[key] = op2._mergeWithPrevious(op1);\\n        } else if (op1) {\\n          nextChanges[key] = op1;\\n        }\\n      });\\n      this._saving = this._saving - 1;\\n    },\\n\\n    /**\\n     * Called when a save completes successfully. This merges the changes that\\n     * were saved into the known server data, and overrides it with any data\\n     * sent directly from the server.\\n     */\\n    _finishSave: function(serverData) {\\n      // Grab a copy of any object referenced by this object. These instances\\n      // may have already been fetched, and we don't want to lose their data.\\n      // Note that doing it like this means we will unify separate copies of the\\n      // same object, but that's a risk we have to take.\\n      var fetchedObjects = {};\\n      Parse._traverse(this.attributes, function(object) {\\n        if (object instanceof Parse.Object && object.id && object._hasData) {\\n          fetchedObjects[object.id] = object;\\n        }\\n      });\\n\\n      var savedChanges = _.first(this._opSetQueue);\\n      this._opSetQueue = _.rest(this._opSetQueue);\\n      this._applyOpSet(savedChanges, this._serverData);\\n      this._mergeMagicFields(serverData);\\n      var self = this;\\n      Parse._objectEach(serverData, function(value, key) {\\n        self._serverData[key] = Parse._decode(key, value);\\n\\n        // Look for any objects that might have become unfetched and fix them\\n        // by replacing their values with the previously observed values.\\n        var fetched = Parse._traverse(self._serverData[key], function(object) {\\n          if (object instanceof Parse.Object && fetchedObjects[object.id]) {\\n            return fetchedObjects[object.id];\\n          }\\n        });\\n        if (fetched) {\\n          self._serverData[key] = fetched;\\n        }\\n      });\\n      this._rebuildAllEstimatedData();\\n      this._saving = this._saving - 1;\\n    },\\n\\n    /**\\n     * Called when a fetch or login is complete to set the known server data to\\n     * the given object.\\n     */\\n    _finishFetch: function(serverData, hasData) {\\n      // TODO (bklimt): Revisit clearing operations, perhaps move to revert.\\n      this._opSetQueue = [{}];\\n\\n      // Bring in all the new server data.\\n      this._mergeMagicFields(serverData);\\n      this._copyServerData(serverData);\\n\\n      this._hasData = hasData;\\n    },\\n\\n    /**\\n     * Applies the set of Parse.Op in opSet to the object target.\\n     */\\n    _applyOpSet: function(opSet, target) {\\n      var self = this;\\n      Parse._objectEach(opSet, function(change, key) {\\n        target[key] = change._estimate(target[key], self, key);\\n        if (target[key] === Parse.Op._UNSET) {\\n          delete target[key];\\n        }\\n      });\\n    },\\n\\n    /**\\n     * Replaces the cached value for key with the current value.\\n     * Returns true if the new value is different than the old value.\\n     */\\n    _resetCacheForKey: function(key) {\\n      var value = this.attributes[key];\\n      if (_.isObject(value) &&\\n          !(value instanceof Parse.Object) &&\\n          !(value instanceof Parse.File)) {\\n        value = value.toJSON ? value.toJSON() : value;\\n        var json = JSON.stringify(value);\\n        if (this._hashedJSON[key] !== json) {\\n          var wasSet = !!this._hashedJSON[key];\\n          this._hashedJSON[key] = json;\\n          return wasSet;\\n        }\\n      }\\n      return false;\\n    },\\n\\n    /**\\n     * Populates attributes[key] by starting with the last known data from the\\n     * server, and applying all of the local changes that have been made to that\\n     * key since then.\\n     */\\n    _rebuildEstimatedDataForKey: function(key) {\\n      var self = this;\\n      delete this.attributes[key];\\n      if (this._serverData[key]) {\\n        this.attributes[key] = this._serverData[key];\\n      }\\n      Parse._arrayEach(this._opSetQueue, function(opSet) {\\n        var op = opSet[key];\\n        if (op) {\\n          self.attributes[key] = op._estimate(self.attributes[key], self, key);\\n          if (self.attributes[key] === Parse.Op._UNSET) {\\n            delete self.attributes[key];\\n          } else {\\n            self._resetCacheForKey(key);\\n          }\\n        }\\n      });\\n    },\\n\\n    /**\\n     * Populates attributes by starting with the last known data from the\\n     * server, and applying all of the local changes that have been made since\\n     * then.\\n     */\\n    _rebuildAllEstimatedData: function() {\\n      var self = this;\\n\\n      var previousAttributes = _.clone(this.attributes);\\n\\n      this.attributes = _.clone(this._serverData);\\n      Parse._arrayEach(this._opSetQueue, function(opSet) {\\n        self._applyOpSet(opSet, self.attributes);\\n        Parse._objectEach(opSet, function(op, key) {\\n          self._resetCacheForKey(key);\\n        });\\n      });\\n\\n      // Trigger change events for anything that changed because of the fetch.\\n      Parse._objectEach(previousAttributes, function(oldValue, key) {\\n        if (self.attributes[key] !== oldValue) {\\n          self.trigger('change:' + key, self, self.attributes[key], {});\\n        }\\n      });\\n      Parse._objectEach(this.attributes, function(newValue, key) {\\n        if (!_.has(previousAttributes, key)) {\\n          self.trigger('change:' + key, self, newValue, {});\\n        }\\n      });\\n    },\\n\\n    /**\\n     * Sets a hash of model attributes on the object, firing\\n     * <code>\\\"change\\\"</code> unless you choose to silence it.\\n     *\\n     * <p>You can call it with an object containing keys and values, or with one\\n     * key and value.  For example:<pre>\\n     *   gameTurn.set({\\n     *     player: player1,\\n     *     diceRoll: 2\\n     *   }, {\\n     *     error: function(gameTurnAgain, error) {\\n     *       // The set failed validation.\\n     *     }\\n     *   });\\n     *\\n     *   game.set(\\\"currentPlayer\\\", player2, {\\n     *     error: function(gameTurnAgain, error) {\\n     *       // The set failed validation.\\n     *     }\\n     *   });\\n     *\\n     *   game.set(\\\"finished\\\", true);</pre></p>\\n     *\\n     * @param {String} key The key to set.\\n     * @param {} value The value to give it.\\n     * @param {Object} options A set of Backbone-like options for the set.\\n     *     The only supported options are <code>silent</code>,\\n     *     <code>error</code>, and <code>promise</code>.\\n     * @return {Boolean} true if the set succeeded.\\n     * @see Parse.Object#validate\\n     * @see Parse.Error\\n     */\\n    set: function(key, value, options) {\\n      var attrs, attr;\\n      if (_.isObject(key) || Parse._isNullOrUndefined(key)) {\\n        attrs = key;\\n        Parse._objectEach(attrs, function(v, k) {\\n          attrs[k] = Parse._decode(k, v);\\n        });\\n        options = value;\\n      } else {\\n        attrs = {};\\n        attrs[key] = Parse._decode(key, value);\\n      }\\n\\n      // Extract attributes and options.\\n      options = options || {};\\n      if (!attrs) {\\n        return this;\\n      }\\n      if (attrs instanceof Parse.Object) {\\n        attrs = attrs.attributes;\\n      }\\n\\n      var self = this;\\n      Parse._objectEach(attrs, function(unused_value, key) {\\n        if (self.constructor.readOnlyAttributes &&\\n          self.constructor.readOnlyAttributes[key]) {\\n          throw new Error('Cannot modify readonly key: ' + key);\\n        }\\n      });\\n\\n      // If the unset option is used, every attribute should be a Unset.\\n      if (options.unset) {\\n        Parse._objectEach(attrs, function(unused_value, key) {\\n          attrs[key] = new Parse.Op.Unset();\\n        });\\n      }\\n\\n      // Apply all the attributes to get the estimated values.\\n      var dataToValidate = _.clone(attrs);\\n      Parse._objectEach(dataToValidate, function(value, key) {\\n        if (value instanceof Parse.Op) {\\n          dataToValidate[key] = value._estimate(self.attributes[key],\\n                                                self, key);\\n          if (dataToValidate[key] === Parse.Op._UNSET) {\\n            delete dataToValidate[key];\\n          }\\n        }\\n      });\\n\\n      // Run validation.\\n      if (!this._validate(attrs, options)) {\\n        return false;\\n      }\\n\\n      this._mergeMagicFields(attrs);\\n\\n      options.changes = {};\\n      var escaped = this._escapedAttributes;\\n      var prev = this._previousAttributes || {};\\n\\n      // Update attributes.\\n      Parse._arrayEach(_.keys(attrs), function(attr) {\\n        var val = attrs[attr];\\n\\n        // If this is a relation object we need to set the parent correctly,\\n        // since the location where it was parsed does not have access to\\n        // this object.\\n        if (val instanceof Parse.Relation) {\\n          val.parent = self;\\n        }\\n\\n        if (!(val instanceof Parse.Op)) {\\n          val = new Parse.Op.Set(val);\\n        }\\n\\n        // See if this change will actually have any effect.\\n        var isRealChange = true;\\n        if (val instanceof Parse.Op.Set &&\\n            _.isEqual(self.attributes[attr], val.value)) {\\n          isRealChange = false;\\n        }\\n\\n        if (isRealChange) {\\n          delete escaped[attr];\\n          if (options.silent) {\\n            self._silent[attr] = true;\\n          } else {\\n            options.changes[attr] = true;\\n          }\\n        }\\n\\n        var currentChanges = _.last(self._opSetQueue);\\n        currentChanges[attr] = val._mergeWithPrevious(currentChanges[attr]);\\n        self._rebuildEstimatedDataForKey(attr);\\n\\n        if (isRealChange) {\\n          self.changed[attr] = self.attributes[attr];\\n          if (!options.silent) {\\n            self._pending[attr] = true;\\n          }\\n        } else {\\n          delete self.changed[attr];\\n          delete self._pending[attr];\\n        }\\n      });\\n\\n      if (!options.silent) {\\n        this.change(options);\\n      }\\n      return this;\\n    },\\n\\n    /**\\n     * Remove an attribute from the model, firing <code>\\\"change\\\"</code> unless\\n     * you choose to silence it. This is a noop if the attribute doesn't\\n     * exist.\\n     */\\n    unset: function(attr, options) {\\n      options = options || {};\\n      options.unset = true;\\n      return this.set(attr, null, options);\\n    },\\n\\n    /**\\n     * Atomically increments the value of the given attribute the next time the\\n     * object is saved. If no amount is specified, 1 is used by default.\\n     *\\n     * @param attr {String} The key.\\n     * @param amount {Number} The amount to increment by.\\n     */\\n    increment: function(attr, amount) {\\n      if (_.isUndefined(amount) || _.isNull(amount)) {\\n        amount = 1;\\n      }\\n      return this.set(attr, new Parse.Op.Increment(amount));\\n    },\\n\\n    /**\\n     * Atomically add an object to the end of the array associated with a given\\n     * key.\\n     * @param attr {String} The key.\\n     * @param item {} The item to add.\\n     */\\n    add: function(attr, item) {\\n      return this.set(attr, new Parse.Op.Add([item]));\\n    },\\n\\n    /**\\n     * Atomically add an object to the array associated with a given key, only\\n     * if it is not already present in the array. The position of the insert is\\n     * not guaranteed.\\n     *\\n     * @param attr {String} The key.\\n     * @param item {} The object to add.\\n     */\\n    addUnique: function(attr, item) {\\n      return this.set(attr, new Parse.Op.AddUnique([item]));\\n    },\\n\\n    /**\\n     * Atomically remove all instances of an object from the array associated\\n     * with a given key.\\n     *\\n     * @param attr {String} The key.\\n     * @param item {} The object to remove.\\n     */\\n    remove: function(attr, item) {\\n      return this.set(attr, new Parse.Op.Remove([item]));\\n    },\\n\\n    /**\\n     * Returns an instance of a subclass of Parse.Op describing what kind of\\n     * modification has been performed on this field since the last time it was\\n     * saved. For example, after calling object.increment(\\\"x\\\"), calling\\n     * object.op(\\\"x\\\") would return an instance of Parse.Op.Increment.\\n     *\\n     * @param attr {String} The key.\\n     * @returns {Parse.Op} The operation, or undefined if none.\\n     */\\n    op: function(attr) {\\n      return _.last(this._opSetQueue)[attr];\\n    },\\n\\n    /**\\n     * Clear all attributes on the model, firing <code>\\\"change\\\"</code> unless\\n     * you choose to silence it.\\n     */\\n    clear: function(options) {\\n      options = options || {};\\n      options.unset = true;\\n      var keysToClear = _.extend(this.attributes, this._operations);\\n      return this.set(keysToClear, options);\\n    },\\n\\n    /**\\n     * Returns a JSON-encoded set of operations to be sent with the next save\\n     * request.\\n     */\\n    _getSaveJSON: function() {\\n      var json = _.clone(_.first(this._opSetQueue));\\n      Parse._objectEach(json, function(op, key) {\\n        json[key] = op.toJSON();\\n      });\\n      return json;\\n    },\\n\\n    /**\\n     * Returns true if this object can be serialized for saving.\\n     */\\n    _canBeSerialized: function() {\\n      return Parse.Object._canBeSerializedAsValue(this.attributes);\\n    },\\n\\n    /**\\n     * Fetch the model from the server. If the server's representation of the\\n     * model differs from its current attributes, they will be overriden,\\n     * triggering a <code>\\\"change\\\"</code> event.\\n     *\\n     * @param {Object} options A Backbone-style callback object.\\n     * Valid options are:<ul>\\n     *   <li>success: A Backbone-style success callback.\\n     *   <li>error: An Backbone-style error callback.\\n     *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\\n     *     be used for this request.\\n     *   <li>sessionToken: A valid session token, used for making a request on\\n     *       behalf of a specific user.\\n     * </ul>\\n     * @return {Parse.Promise} A promise that is fulfilled when the fetch\\n     *     completes.\\n     */\\n    fetch: function(options) {\\n      var self = this;\\n      options = options || {};\\n      var request = Parse._request({\\n        method: 'GET',\\n        route: \\\"classes\\\",\\n        className: this.className,\\n        objectId: this.id,\\n        useMasterKey: options.useMasterKey,\\n        sessionToken: options.sessionToken\\n      });\\n      return request.then(function(response, status, xhr) {\\n        self._finishFetch(self.parse(response, status, xhr), true);\\n        return self;\\n      })._thenRunCallbacks(options, this);\\n    },\\n\\n    /**\\n     * Set a hash of model attributes, and save the model to the server.\\n     * updatedAt will be updated when the request returns.\\n     * You can either call it as:<pre>\\n     *   object.save();</pre>\\n     * or<pre>\\n     *   object.save(null, options);</pre>\\n     * or<pre>\\n     *   object.save(attrs, options);</pre>\\n     * or<pre>\\n     *   object.save(key, value, options);</pre>\\n     *\\n     * For example, <pre>\\n     *   gameTurn.save({\\n     *     player: \\\"Jake Cutter\\\",\\n     *     diceRoll: 2\\n     *   }, {\\n     *     success: function(gameTurnAgain) {\\n     *       // The save was successful.\\n     *     },\\n     *     error: function(gameTurnAgain, error) {\\n     *       // The save failed.  Error is an instance of Parse.Error.\\n     *     }\\n     *   });</pre>\\n     * or with promises:<pre>\\n     *   gameTurn.save({\\n     *     player: \\\"Jake Cutter\\\",\\n     *     diceRoll: 2\\n     *   }).then(function(gameTurnAgain) {\\n     *     // The save was successful.\\n     *   }, function(error) {\\n     *     // The save failed.  Error is an instance of Parse.Error.\\n     *   });</pre>\\n     *\\n     * @param {Object} options A Backbone-style callback object.\\n     * Valid options are:<ul>\\n     *   <li>wait: Set to true to wait for the server to confirm a successful\\n     *   save before modifying the attributes on the object.\\n     *   <li>silent: Set to true to avoid firing the `set` event.\\n     *   <li>success: A Backbone-style success callback.\\n     *   <li>error: An Backbone-style error callback.\\n     *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\\n     *     be used for this request.\\n     *   <li>sessionToken: A valid session token, used for making a request on\\n     *       behalf of a specific user.\\n     * </ul>\\n     * @return {Parse.Promise} A promise that is fulfilled when the save\\n     *     completes.\\n     * @see Parse.Error\\n     */\\n    save: function(arg1, arg2, arg3) {\\n      var i, attrs, current, options, saved;\\n      if (_.isObject(arg1) || Parse._isNullOrUndefined(arg1)) {\\n        attrs = arg1;\\n        options = arg2;\\n      } else {\\n        attrs = {};\\n        attrs[arg1] = arg2;\\n        options = arg3;\\n      }\\n\\n      // Make save({ success: function() {} }) work.\\n      if (!options && attrs) {\\n        var extra_keys = _.reject(attrs, function(value, key) {\\n          return _.include([\\\"success\\\", \\\"error\\\", \\\"wait\\\"], key);\\n        });\\n        if (extra_keys.length === 0) {\\n          var all_functions = true;\\n          if (_.has(attrs, \\\"success\\\") && !_.isFunction(attrs.success)) {\\n            all_functions = false;\\n          }\\n          if (_.has(attrs, \\\"error\\\") && !_.isFunction(attrs.error)) {\\n            all_functions = false;\\n          }\\n          if (all_functions) {\\n            // This attrs object looks like it's really an options object,\\n            // and there's no other options object, so let's just use it.\\n            return this.save(null, attrs);\\n          }\\n        }\\n      }\\n\\n      options = _.clone(options) || {};\\n      if (options.wait) {\\n        current = _.clone(this.attributes);\\n      }\\n\\n      var setOptions = _.clone(options) || {};\\n      if (setOptions.wait) {\\n        setOptions.silent = true;\\n      }\\n      var setError;\\n      setOptions.error = function(model, error) {\\n        setError = error;\\n      };\\n      if (attrs && !this.set(attrs, setOptions)) {\\n        return Parse.Promise.error(setError)._thenRunCallbacks(options, this);\\n      }\\n\\n      var model = this;\\n\\n      // If there is any unsaved child, save it first.\\n      model._refreshCache();\\n\\n      // TODO(klimt): Refactor this so that the save starts now, not later.\\n\\n      var unsavedChildren = [];\\n      var unsavedFiles = [];\\n      Parse.Object._findUnsavedChildren(model.attributes,\\n                                        unsavedChildren,\\n                                        unsavedFiles);\\n      if (unsavedChildren.length + unsavedFiles.length > 0) {\\n        return Parse.Object._deepSaveAsync(this.attributes, {\\n          useMasterKey: options.useMasterKey,\\n          sessionToken: options.sessionToken\\n        }).then(function() {\\n          return model.save(null, options);\\n        }, function(error) {\\n          return Parse.Promise.error(error)._thenRunCallbacks(options, model);\\n        });\\n      }\\n\\n      this._startSave();\\n      this._saving = (this._saving || 0) + 1;\\n\\n      this._allPreviousSaves = this._allPreviousSaves || Parse.Promise.as();\\n      this._allPreviousSaves = this._allPreviousSaves._continueWith(function() {\\n        var method = model.id ? 'PUT' : 'POST';\\n\\n        var json = model._getSaveJSON();\\n\\n        var route = \\\"classes\\\";\\n        var className = model.className;\\n        if (model.className === \\\"_User\\\" && !model.id) {\\n          // Special-case user sign-up.\\n          route = \\\"users\\\";\\n          className = null;\\n        }\\n        var request = Parse._request({\\n          route: route,\\n          className: className,\\n          objectId: model.id,\\n          method: method,\\n          useMasterKey: options.useMasterKey,\\n          sessionToken: options.sessionToken,\\n          data: json\\n        });\\n\\n        request = request.then(function(resp, status, xhr) {\\n          var serverAttrs = model.parse(resp, status, xhr);\\n          if (options.wait) {\\n            serverAttrs = _.extend(attrs || {}, serverAttrs);\\n          }\\n          model._finishSave(serverAttrs);\\n          if (options.wait) {\\n            model.set(current, setOptions);\\n          }\\n          return model;\\n\\n        }, function(error) {\\n          model._cancelSave();\\n          return Parse.Promise.error(error);\\n\\n        })._thenRunCallbacks(options, model);\\n\\n        return request;\\n      });\\n      return this._allPreviousSaves;\\n    },\\n\\n    /**\\n     * Destroy this model on the server if it was already persisted.\\n     * Optimistically removes the model from its collection, if it has one.\\n     * If `wait: true` is passed, waits for the server to respond\\n     * before removal.\\n     *\\n     * @param {Object} options A Backbone-style callback object.\\n     * Valid options are:<ul>\\n     *   <li>wait: Set to true to wait for the server to confirm successful\\n     *   deletion of the object before triggering the `destroy` event.\\n     *   <li>success: A Backbone-style success callback\\n     *   <li>error: An Backbone-style error callback.\\n     *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\\n     *     be used for this request.\\n     *   <li>sessionToken: A valid session token, used for making a request on\\n     *       behalf of a specific user.\\n     * </ul>\\n     * @return {Parse.Promise} A promise that is fulfilled when the destroy\\n     *     completes.\\n     */\\n    destroy: function(options) {\\n      options = options || {};\\n      var model = this;\\n\\n      var triggerDestroy = function() {\\n        model.trigger('destroy', model, model.collection, options);\\n      };\\n\\n      if (!this.id) {\\n        return triggerDestroy();\\n      }\\n\\n      if (!options.wait) {\\n        triggerDestroy();\\n      }\\n\\n      var request = Parse._request({\\n        route: \\\"classes\\\",\\n        className: this.className,\\n        objectId: this.id,\\n        method: 'DELETE',\\n        useMasterKey: options.useMasterKey,\\n        sessionToken: options.sessionToken\\n      });\\n      return request.then(function() {\\n        if (options.wait) {\\n          triggerDestroy();\\n        }\\n        return model;\\n      })._thenRunCallbacks(options, this);\\n    },\\n\\n    /**\\n     * Converts a response into the hash of attributes to be set on the model.\\n     * @ignore\\n     */\\n    parse: function(resp, status, xhr) {\\n      var output = _.clone(resp);\\n      _([\\\"createdAt\\\", \\\"updatedAt\\\"]).each(function(key) {\\n        if (output[key]) {\\n          output[key] = Parse._parseDate(output[key]);\\n        }\\n      });\\n      if (!output.updatedAt) {\\n        output.updatedAt = output.createdAt;\\n      }\\n      if (status) {\\n        this._existed = (status !== 201);\\n      }\\n      return output;\\n    },\\n\\n    /**\\n     * Creates a new model with identical attributes to this one.\\n     * @return {Parse.Object}\\n     */\\n    clone: function() {\\n      return new this.constructor(this.attributes);\\n    },\\n\\n    /**\\n     * Returns true if this object has never been saved to Parse.\\n     * @return {Boolean}\\n     */\\n    isNew: function() {\\n      return !this.id;\\n    },\\n\\n    /**\\n     * Call this method to manually fire a `\\\"change\\\"` event for this model and\\n     * a `\\\"change:attribute\\\"` event for each changed attribute.\\n     * Calling this will cause all objects observing the model to update.\\n     */\\n    change: function(options) {\\n      options = options || {};\\n      var changing = this._changing;\\n      this._changing = true;\\n\\n      // Silent changes become pending changes.\\n      var self = this;\\n      Parse._objectEach(this._silent, function(attr) {\\n        self._pending[attr] = true;\\n      });\\n\\n      // Silent changes are triggered.\\n      var changes = _.extend({}, options.changes, this._silent);\\n      this._silent = {};\\n      Parse._objectEach(changes, function(unused_value, attr) {\\n        self.trigger('change:' + attr, self, self.get(attr), options);\\n      });\\n      if (changing) {\\n        return this;\\n      }\\n\\n      // This is to get around lint not letting us make a function in a loop.\\n      var deleteChanged = function(value, attr) {\\n        if (!self._pending[attr] && !self._silent[attr]) {\\n          delete self.changed[attr];\\n        }\\n      };\\n\\n      // Continue firing `\\\"change\\\"` events while there are pending changes.\\n      while (!_.isEmpty(this._pending)) {\\n        this._pending = {};\\n        this.trigger('change', this, options);\\n        // Pending and silent changes still remain.\\n        Parse._objectEach(this.changed, deleteChanged);\\n        self._previousAttributes = _.clone(this.attributes);\\n      }\\n\\n      this._changing = false;\\n      return this;\\n    },\\n\\n    /**\\n     * Returns true if this object was created by the Parse server when the\\n     * object might have already been there (e.g. in the case of a Facebook\\n     * login)\\n     */\\n    existed: function() {\\n      return this._existed;\\n    },\\n\\n    /**\\n     * Determine if the model has changed since the last <code>\\\"change\\\"</code>\\n     * event.  If you specify an attribute name, determine if that attribute\\n     * has changed.\\n     * @param {String} attr Optional attribute name\\n     * @return {Boolean}\\n     */\\n    hasChanged: function(attr) {\\n      if (!arguments.length) {\\n        return !_.isEmpty(this.changed);\\n      }\\n      return this.changed && _.has(this.changed, attr);\\n    },\\n\\n    /**\\n     * Returns an object containing all the attributes that have changed, or\\n     * false if there are no changed attributes. Useful for determining what\\n     * parts of a view need to be updated and/or what attributes need to be\\n     * persisted to the server. Unset attributes will be set to undefined.\\n     * You can also pass an attributes object to diff against the model,\\n     * determining if there *would be* a change.\\n     */\\n    changedAttributes: function(diff) {\\n      if (!diff) {\\n        return this.hasChanged() ? _.clone(this.changed) : false;\\n      }\\n      var changed = {};\\n      var old = this._previousAttributes;\\n      Parse._objectEach(diff, function(diffVal, attr) {\\n        if (!_.isEqual(old[attr], diffVal)) {\\n          changed[attr] = diffVal;\\n        }\\n      });\\n      return changed;\\n    },\\n\\n    /**\\n     * Gets the previous value of an attribute, recorded at the time the last\\n     * <code>\\\"change\\\"</code> event was fired.\\n     * @param {String} attr Name of the attribute to get.\\n     */\\n    previous: function(attr) {\\n      if (!arguments.length || !this._previousAttributes) {\\n        return null;\\n      }\\n      return this._previousAttributes[attr];\\n    },\\n\\n    /**\\n     * Gets all of the attributes of the model at the time of the previous\\n     * <code>\\\"change\\\"</code> event.\\n     * @return {Object}\\n     */\\n    previousAttributes: function() {\\n      return _.clone(this._previousAttributes);\\n    },\\n\\n    /**\\n     * Checks if the model is currently in a valid state. It's only possible to\\n     * get into an *invalid* state if you're using silent changes.\\n     * @return {Boolean}\\n     */\\n    isValid: function() {\\n      return !this.validate(this.attributes);\\n    },\\n\\n    /**\\n     * You should not call this function directly unless you subclass\\n     * <code>Parse.Object</code>, in which case you can override this method\\n     * to provide additional validation on <code>set</code> and\\n     * <code>save</code>.  Your implementation should return\\n     *\\n     * @param {Object} attrs The current data to validate.\\n     * @param {Object} options A Backbone-like options object.\\n     * @return {} False if the data is valid.  An error object otherwise.\\n     * @see Parse.Object#set\\n     */\\n    validate: function(attrs, options) {\\n      if (_.has(attrs, \\\"ACL\\\") && !(attrs.ACL instanceof Parse.ACL)) {\\n        return new Parse.Error(Parse.Error.OTHER_CAUSE,\\n                               \\\"ACL must be a Parse.ACL.\\\");\\n      }\\n      var correct = true;\\n      Parse._objectEach(attrs, function(unused_value, key) {\\n        if (!(/^[A-Za-z][0-9A-Za-z_]*$/).test(key)) {\\n          correct = false;\\n        }\\n      });\\n      if (!correct) {\\n        return new Parse.Error(Parse.Error.INVALID_KEY_NAME);\\n      }\\n      return false;\\n    },\\n\\n    /**\\n     * Run validation against a set of incoming attributes, returning `true`\\n     * if all is well. If a specific `error` callback has been passed,\\n     * call that instead of firing the general `\\\"error\\\"` event.\\n     */\\n    _validate: function(attrs, options) {\\n      if (options.silent || !this.validate) {\\n        return true;\\n      }\\n      attrs = _.extend({}, this.attributes, attrs);\\n      var error = this.validate(attrs, options);\\n      if (!error) {\\n        return true;\\n      }\\n      if (options && options.error) {\\n        options.error(this, error, options);\\n      } else {\\n        this.trigger('error', this, error, options);\\n      }\\n      return false;\\n    },\\n\\n    /**\\n     * Returns the ACL for this object.\\n     * @returns {Parse.ACL} An instance of Parse.ACL.\\n     * @see Parse.Object#get\\n     */\\n    getACL: function() {\\n      return this.get(\\\"ACL\\\");\\n    },\\n\\n    /**\\n     * Sets the ACL to be used for this object.\\n     * @param {Parse.ACL} acl An instance of Parse.ACL.\\n     * @param {Object} options Optional Backbone-like options object to be\\n     *     passed in to set.\\n     * @return {Boolean} Whether the set passed validation.\\n     * @see Parse.Object#set\\n     */\\n    setACL: function(acl, options) {\\n      return this.set(\\\"ACL\\\", acl, options);\\n    }\\n\\n  });\\n\\n  /**\\n   * Returns the appropriate subclass for making new instances of the given\\n   * className string.\\n   */\\n  Parse.Object._getSubclass = function(className) {\\n    if (!_.isString(className)) {\\n      throw \\\"Parse.Object._getSubclass requires a string argument.\\\";\\n    }\\n    var ObjectClass = Parse.Object._classMap[className];\\n    if (!ObjectClass) {\\n      ObjectClass = Parse.Object.extend(className);\\n      Parse.Object._classMap[className] = ObjectClass;\\n    }\\n    return ObjectClass;\\n  };\\n\\n  /**\\n   * Creates an instance of a subclass of Parse.Object for the given classname.\\n   */\\n  Parse.Object._create = function(className, attributes, options) {\\n    var ObjectClass = Parse.Object._getSubclass(className);\\n    return new ObjectClass(attributes, options);\\n  };\\n\\n  /**\\n   * Returns a list of object ids given a list of objects.\\n   */\\n  Parse.Object._toObjectIdArray = function(list, omitObjectsWithData) {\\n    if (list.length === 0) {\\n      return Parse.Promise.as(list);\\n    }\\n\\n    var error;\\n    var className = list[0].className;\\n    var objectIds = [];\\n    for (var i = 0; i < list.length; i++) {\\n      var object = list[i];\\n      if (className !== object.className) {\\n        error = new Parse.Error(Parse.Error.INVALID_CLASS_NAME,\\n                                \\\"All objects should be of the same class\\\");\\n        return Parse.Promise.error(error);\\n      } else if (!object.id) {\\n        error = new Parse.Error(Parse.Error.MISSING_OBJECT_ID,\\n                                \\\"All objects must have an ID\\\");\\n        return Parse.Promise.error(error);\\n      } else if (omitObjectsWithData && object._hasData) {\\n        continue;\\n      }\\n      objectIds.push(object.id);\\n    }\\n\\n    return Parse.Promise.as(objectIds);\\n  };\\n\\n  /**\\n   * Updates a list of objects with fetched results.\\n   */\\n  Parse.Object._updateWithFetchedResults = function(list, fetched, forceFetch) {\\n    var fetchedObjectsById = {};\\n    Parse._arrayEach(fetched, function(object, i) {\\n      fetchedObjectsById[object.id] = object;\\n    });\\n\\n    for (var i = 0; i < list.length; i++) {\\n      var object = list[i];\\n      var fetchedObject = fetchedObjectsById[object.id];\\n      if (!fetchedObject && forceFetch) {\\n        var error = new Parse.Error(Parse.Error.OBJECT_NOT_FOUND,\\n                                \\\"All objects must exist on the server\\\");\\n        return Parse.Promise.error(error);\\n      }\\n\\n      object._mergeFromObject(fetchedObject);\\n    }\\n\\n    return Parse.Promise.as(list);\\n  };\\n\\n  /**\\n   * Fetches the objects given in list.  The forceFetch option will fetch all\\n   * objects if true and ignore objects with data if false.\\n   */\\n  Parse.Object._fetchAll = function(list, forceFetch) {\\n    if (list.length === 0) {\\n      return Parse.Promise.as(list);\\n    }\\n\\n    var omitObjectsWithData = !forceFetch;\\n    return Parse.Object._toObjectIdArray(\\n      list,\\n      omitObjectsWithData\\n    ).then(function(objectIds) {\\n      var className = list[0].className;\\n      var query = new Parse.Query(className);\\n      query.containedIn(\\\"objectId\\\", objectIds);\\n      query.limit = objectIds.length;\\n      return query.find();\\n    }).then(function(results) {\\n      return Parse.Object._updateWithFetchedResults(\\n        list,\\n        results,\\n        forceFetch\\n      );\\n    });\\n  };\\n\\n  // Set up a map of className to class so that we can create new instances of\\n  // Parse Objects from JSON automatically.\\n  Parse.Object._classMap = {};\\n\\n  Parse.Object._extend = Parse._extend;\\n\\n  /**\\n   * Creates a new subclass of Parse.Object for the given Parse class name.\\n   *\\n   * <p>Every extension of a Parse class will inherit from the most recent\\n   * previous extension of that class. When a Parse.Object is automatically\\n   * created by parsing JSON, it will use the most recent extension of that\\n   * class.</p>\\n   *\\n   * <p>You should call either:<pre>\\n   *     var MyClass = Parse.Object.extend(\\\"MyClass\\\", {\\n   *         <i>Instance methods</i>,\\n   *         initialize: function(attrs, options) {\\n   *             this.someInstanceProperty = [],\\n   *             <i>Other instance properties</i>\\n   *         }\\n   *     }, {\\n   *         <i>Class properties</i>\\n   *     });</pre>\\n   * or, for Backbone compatibility:<pre>\\n   *     var MyClass = Parse.Object.extend({\\n   *         className: \\\"MyClass\\\",\\n   *         <i>Instance methods</i>,\\n   *         initialize: function(attrs, options) {\\n   *             this.someInstanceProperty = [],\\n   *             <i>Other instance properties</i>\\n   *         }\\n   *     }, {\\n   *         <i>Class properties</i>\\n   *     });</pre></p>\\n   *\\n   * @param {String} className The name of the Parse class backing this model.\\n   * @param {Object} protoProps Instance properties to add to instances of the\\n   *     class returned from this method.\\n   * @param {Object} classProps Class properties to add the class returned from\\n   *     this method.\\n   * @return {Class} A new subclass of Parse.Object.\\n   */\\n  Parse.Object.extend = function(className, protoProps, classProps) {\\n    // Handle the case with only two args.\\n    if (!_.isString(className)) {\\n      if (className && _.has(className, \\\"className\\\")) {\\n        return Parse.Object.extend(className.className, className, protoProps);\\n      } else {\\n        throw new Error(\\n            \\\"Parse.Object.extend's first argument should be the className.\\\");\\n      }\\n    }\\n\\n    // If someone tries to subclass \\\"User\\\", coerce it to the right type.\\n    if (className === \\\"User\\\" && Parse.User._performUserRewrite) {\\n      className = \\\"_User\\\";\\n    }\\n    protoProps = protoProps || {};\\n    protoProps.className = className;\\n\\n    var NewClassObject = null;\\n    if (_.has(Parse.Object._classMap, className)) {\\n      var OldClassObject = Parse.Object._classMap[className];\\n      // This new subclass has been told to extend both from \\\"this\\\" and from\\n      // OldClassObject. This is multiple inheritance, which isn't supported.\\n      // For now, let's just pick one.\\n      NewClassObject = OldClassObject._extend(protoProps, classProps);\\n    } else {\\n      NewClassObject = this._extend(protoProps, classProps);\\n    }\\n    // Extending a subclass should reuse the classname automatically.\\n    NewClassObject.extend = function(arg0) {\\n      if (_.isString(arg0) || (arg0 && _.has(arg0, \\\"className\\\"))) {\\n        return Parse.Object.extend.apply(NewClassObject, arguments);\\n      }\\n      var newArguments = [className].concat(Parse._.toArray(arguments));\\n      return Parse.Object.extend.apply(NewClassObject, newArguments);\\n    };\\n\\n    /**\\n     * Creates a reference to a subclass of Parse.Object with the given id. This\\n     * does not exist on Parse.Object, only on subclasses.\\n     *\\n     * <p>A shortcut for: <pre>\\n     *  var Foo = Parse.Object.extend(\\\"Foo\\\");\\n     *  var pointerToFoo = new Foo();\\n     *  pointerToFoo.id = \\\"myObjectId\\\";\\n     * </pre>\\n     *\\n     * @name createWithoutData\\n     * @param {String} id The ID of the object to create a reference to.\\n     * @return {Parse.Object} A Parse.Object reference.\\n     * @function\\n     * @memberOf Parse.Object\\n     */\\n    NewClassObject.createWithoutData = function(id) {\\n      var obj = new NewClassObject();\\n      obj.id = id;\\n      return obj;\\n    };\\n\\n    Parse.Object._classMap[className] = NewClassObject;\\n    return NewClassObject;\\n  };\\n\\n  Parse.Object._findUnsavedChildren = function(object, children, files) {\\n    Parse._traverse(object, function(object) {\\n      if (object instanceof Parse.Object) {\\n        object._refreshCache();\\n        if (object.dirty()) {\\n          children.push(object);\\n        }\\n        return;\\n      }\\n\\n      if (object instanceof Parse.File) {\\n        if (!object.url()) {\\n          files.push(object);\\n        }\\n        return;\\n      }\\n    });\\n  };\\n\\n  Parse.Object._canBeSerializedAsValue = function(object) {\\n    // TODO(klimt): We should rewrite _traverse so that it can be used here.\\n    if (object instanceof Parse.Object) {\\n      return !!object.id;\\n    }\\n    if (object instanceof Parse.File) {\\n      // Don't recurse indefinitely into files.\\n      return true;\\n    }\\n\\n    var canBeSerializedAsValue = true;\\n\\n    if (_.isArray(object)) {\\n      Parse._arrayEach(object, function(child) {\\n        if (!Parse.Object._canBeSerializedAsValue(child)) {\\n          canBeSerializedAsValue = false;\\n        }\\n      });\\n    } else if (_.isObject(object)) {\\n      Parse._objectEach(object, function(child) {\\n        if (!Parse.Object._canBeSerializedAsValue(child)) {\\n          canBeSerializedAsValue = false;\\n        }\\n      });\\n    }\\n    return canBeSerializedAsValue;\\n  };\\n\\n  /**\\n   * @param {Object} object The root object.\\n   * @param {Object} options: The only valid option is useMasterKey.\\n   */\\n  Parse.Object._deepSaveAsync = function(object, options) {\\n    var unsavedChildren = [];\\n    var unsavedFiles = [];\\n    Parse.Object._findUnsavedChildren(object, unsavedChildren, unsavedFiles);\\n\\n    var promise = Parse.Promise.as();\\n    _.each(unsavedFiles, function(file) {\\n      promise = promise.then(function() {\\n        return file.save(options);\\n      });\\n    });\\n\\n    var objects = _.uniq(unsavedChildren);\\n    var remaining = _.uniq(objects);\\n\\n    return promise.then(function() {\\n      return Parse.Promise._continueWhile(function() {\\n        return remaining.length > 0;\\n      }, function() {\\n\\n        // Gather up all the objects that can be saved in this batch.\\n        var batch = [];\\n        var newRemaining = [];\\n        Parse._arrayEach(remaining, function(object) {\\n          // Limit batches to 20 objects.\\n          if (batch.length > 20) {\\n            newRemaining.push(object);\\n            return;\\n          }\\n\\n          if (object._canBeSerialized()) {\\n            batch.push(object);\\n          } else {\\n            newRemaining.push(object);\\n          }\\n        });\\n        remaining = newRemaining;\\n\\n        // If we can't save any objects, there must be a circular reference.\\n        if (batch.length === 0) {\\n          return Parse.Promise.error(\\n            new Parse.Error(Parse.Error.OTHER_CAUSE,\\n                            \\\"Tried to save a batch with a cycle.\\\"));\\n        }\\n\\n        // Reserve a spot in every object's save queue.\\n        var readyToStart = Parse.Promise.when(_.map(batch, function(object) {\\n          return object._allPreviousSaves || Parse.Promise.as();\\n        }));\\n        var batchFinished = new Parse.Promise();\\n        Parse._arrayEach(batch, function(object) {\\n          object._allPreviousSaves = batchFinished;\\n        });\\n\\n        // Save a single batch, whether previous saves succeeded or failed.\\n        return readyToStart._continueWith(function() {\\n          return Parse._request({\\n            route: \\\"batch\\\",\\n            method: \\\"POST\\\",\\n            useMasterKey: options.useMasterKey,\\n            sessionToken: options.sessionToken,\\n            data: {\\n              requests: _.map(batch, function(object) {\\n                var json = object._getSaveJSON();\\n                var method = \\\"POST\\\";\\n\\n                var path = \\\"/1/classes/\\\" + object.className;\\n                if (object.id) {\\n                  path = path + \\\"/\\\" + object.id;\\n                  method = \\\"PUT\\\";\\n                }\\n\\n                object._startSave();\\n\\n                return {\\n                  method: method,\\n                  path: path,\\n                  body: json\\n                };\\n              })\\n            }\\n          }).then(function(response, status, xhr) {\\n            var error;\\n            Parse._arrayEach(batch, function(object, i) {\\n              if (response[i].success) {\\n                object._finishSave(\\n                  object.parse(response[i].success, status, xhr));\\n              } else {\\n                error = error || response[i].error;\\n                object._cancelSave();\\n              }\\n            });\\n            if (error) {\\n              return Parse.Promise.error(\\n                new Parse.Error(error.code, error.error));\\n            }\\n\\n          }).then(function(results) {\\n            batchFinished.resolve(results);\\n            return results;\\n          }, function(error) {\\n            batchFinished.reject(error);\\n            return Parse.Promise.error(error);\\n          });\\n        });\\n      });\\n    }).then(function() {\\n      return object;\\n    });\\n  };\\n\\n}(this));\\n\\n(function(root) {\\n  root.Parse = root.Parse || {};\\n  var Parse = root.Parse;\\n  var _ = Parse._;\\n\\n  /**\\n   * Represents a Role on the Parse server. Roles represent groupings of\\n   * Users for the purposes of granting permissions (e.g. specifying an ACL\\n   * for an Object). Roles are specified by their sets of child users and\\n   * child roles, all of which are granted any permissions that the parent\\n   * role has.\\n   *\\n   * <p>Roles must have a name (which cannot be changed after creation of the\\n   * role), and must specify an ACL.</p>\\n   * @class\\n   * A Parse.Role is a local representation of a role persisted to the Parse\\n   * cloud.\\n   */\\n  Parse.Role = Parse.Object.extend(\\\"_Role\\\", /** @lends Parse.Role.prototype */ {\\n    // Instance Methods\\n    \\n    /**\\n     * Constructs a new ParseRole with the given name and ACL.\\n     * \\n     * @param {String} name The name of the Role to create.\\n     * @param {Parse.ACL} acl The ACL for this role. Roles must have an ACL.\\n     */\\n    constructor: function(name, acl) {\\n      if (_.isString(name) && (acl instanceof Parse.ACL)) {\\n        Parse.Object.prototype.constructor.call(this, null, null);\\n        this.setName(name);\\n        this.setACL(acl);\\n      } else {\\n        Parse.Object.prototype.constructor.call(this, name, acl);\\n      }\\n    },\\n    \\n    /**\\n     * Gets the name of the role.  You can alternatively call role.get(\\\"name\\\")\\n     * \\n     * @return {String} the name of the role.\\n     */\\n    getName: function() {\\n      return this.get(\\\"name\\\");\\n    },\\n    \\n    /**\\n     * Sets the name for a role. This value must be set before the role has\\n     * been saved to the server, and cannot be set once the role has been\\n     * saved.\\n     * \\n     * <p>\\n     *   A role's name can only contain alphanumeric characters, _, -, and\\n     *   spaces.\\n     * </p>\\n     *\\n     * <p>This is equivalent to calling role.set(\\\"name\\\", name)</p>\\n     * \\n     * @param {String} name The name of the role.\\n     * @param {Object} options Standard options object with success and error\\n     *     callbacks.\\n     */\\n    setName: function(name, options) {\\n      return this.set(\\\"name\\\", name, options);\\n    },\\n    \\n    /**\\n     * Gets the Parse.Relation for the Parse.Users that are direct\\n     * children of this role. These users are granted any privileges that this\\n     * role has been granted (e.g. read or write access through ACLs). You can\\n     * add or remove users from the role through this relation.\\n     * \\n     * <p>This is equivalent to calling role.relation(\\\"users\\\")</p>\\n     * \\n     * @return {Parse.Relation} the relation for the users belonging to this\\n     *     role.\\n     */\\n    getUsers: function() {\\n      return this.relation(\\\"users\\\");\\n    },\\n    \\n    /**\\n     * Gets the Parse.Relation for the Parse.Roles that are direct\\n     * children of this role. These roles' users are granted any privileges that\\n     * this role has been granted (e.g. read or write access through ACLs). You\\n     * can add or remove child roles from this role through this relation.\\n     * \\n     * <p>This is equivalent to calling role.relation(\\\"roles\\\")</p>\\n     * \\n     * @return {Parse.Relation} the relation for the roles belonging to this\\n     *     role.\\n     */\\n    getRoles: function() {\\n      return this.relation(\\\"roles\\\");\\n    },\\n    \\n    /**\\n     * @ignore\\n     */\\n    validate: function(attrs, options) {\\n      if (\\\"name\\\" in attrs && attrs.name !== this.getName()) {\\n        var newName = attrs.name;\\n        if (this.id && this.id !== attrs.objectId) {\\n          // Check to see if the objectId being set matches this.id.\\n          // This happens during a fetch -- the id is set before calling fetch.\\n          // Let the name be set in this case.\\n          return new Parse.Error(Parse.Error.OTHER_CAUSE,\\n              \\\"A role's name can only be set before it has been saved.\\\");\\n        }\\n        if (!_.isString(newName)) {\\n          return new Parse.Error(Parse.Error.OTHER_CAUSE,\\n              \\\"A role's name must be a String.\\\");\\n        }\\n        if (!(/^[0-9a-zA-Z\\\\-_ ]+$/).test(newName)) {\\n          return new Parse.Error(Parse.Error.OTHER_CAUSE,\\n              \\\"A role's name can only contain alphanumeric characters, _,\\\" +\\n              \\\" -, and spaces.\\\");\\n        }\\n      }\\n      if (Parse.Object.prototype.validate) {\\n        return Parse.Object.prototype.validate.call(this, attrs, options);\\n      }\\n      return false;\\n    }\\n  });\\n}(this));\\n\\n\\n/*global _: false */\\n(function(root) {\\n  root.Parse = root.Parse || {};\\n  var Parse = root.Parse;\\n  var _ = Parse._;\\n\\n  /**\\n   * Creates a new instance with the given models and options.  Typically, you\\n   * will not call this method directly, but will instead make a subclass using\\n   * <code>Parse.Collection.extend</code>.\\n   *\\n   * @param {Array} models An array of instances of <code>Parse.Object</code>.\\n   *\\n   * @param {Object} options An optional object with Backbone-style options.\\n   * Valid options are:<ul>\\n   *   <li>model: The Parse.Object subclass that this collection contains.\\n   *   <li>query: An instance of Parse.Query to use when fetching items.\\n   *   <li>comparator: A string property name or function to sort by.\\n   * </ul>\\n   *\\n   * @see Parse.Collection.extend\\n   *\\n   * @class\\n   *\\n   * <p>Provides a standard collection class for our sets of models, ordered\\n   * or unordered.  For more information, see the\\n   * <a href=\\\"http://documentcloud.github.com/backbone/#Collection\\\">Backbone\\n   * documentation</a>.</p>\\n   */\\n  Parse.Collection = function(models, options) {\\n    options = options || {};\\n    if (options.comparator) {\\n      this.comparator = options.comparator;\\n    }\\n    if (options.model) {\\n      this.model = options.model;\\n    }\\n    if (options.query) {\\n      this.query = options.query;\\n    }\\n    this._reset();\\n    this.initialize.apply(this, arguments);\\n    if (models) {\\n      this.reset(models, {silent: true, parse: options.parse});\\n    }\\n  };\\n\\n  // Define the Collection's inheritable methods.\\n  _.extend(Parse.Collection.prototype, Parse.Events,\\n      /** @lends Parse.Collection.prototype */ {\\n\\n    // The default model for a collection is just a Parse.Object.\\n    // This should be overridden in most cases.\\n    // TODO: think harder. this is likely to be weird.\\n    model: Parse.Object,\\n\\n    /**\\n     * Initialize is an empty function by default. Override it with your own\\n     * initialization logic.\\n     */\\n    initialize: function(){},\\n\\n    /**\\n     * The JSON representation of a Collection is an array of the\\n     * models' attributes.\\n     */\\n    toJSON: function() {\\n      return this.map(function(model){ return model.toJSON(); });\\n    },\\n\\n    /**\\n     * Add a model, or list of models to the set. Pass **silent** to avoid\\n     * firing the `add` event for every new model.\\n     *\\n     * @param {Array} models An array of instances of <code>Parse.Object</code>.\\n     *\\n     * @param {Object} options An optional object with Backbone-style options.\\n     * Valid options are:<ul>\\n     *   <li>at: The index at which to add the models.\\n     *   <li>silent: Set to true to avoid firing the `add` event for every new\\n     *   model.\\n     * </ul>\\n     */\\n    add: function(models, options) {\\n      var i, index, length, model, cid, id, cids = {}, ids = {};\\n      options = options || {};\\n      models = _.isArray(models) ? models.slice() : [models];\\n\\n      // Begin by turning bare objects into model references, and preventing\\n      // invalid models or duplicate models from being added.\\n      for (i = 0, length = models.length; i < length; i++) {\\n        models[i] = this._prepareModel(models[i], options);\\n        model = models[i];\\n        if (!model) {\\n          throw new Error(\\\"Can't add an invalid model to a collection\\\");\\n        }\\n        cid = model.cid;\\n        if (cids[cid] || this._byCid[cid]) {\\n          throw new Error(\\\"Duplicate cid: can't add the same model \\\" +\\n                          \\\"to a collection twice\\\");\\n        }\\n        id = model.id;\\n        if (!Parse._isNullOrUndefined(id) && (ids[id] || this._byId[id])) {\\n          throw new Error(\\\"Duplicate id: can't add the same model \\\" +\\n                          \\\"to a collection twice\\\");\\n        }\\n        ids[id] = model;\\n        cids[cid] = model;\\n      }\\n\\n      // Listen to added models' events, and index models for lookup by\\n      // `id` and by `cid`.\\n      for (i = 0; i < length; i++) {\\n        (model = models[i]).on('all', this._onModelEvent, this);\\n        this._byCid[model.cid] = model;\\n        if (model.id) {\\n          this._byId[model.id] = model;\\n        }\\n      }\\n\\n      // Insert models into the collection, re-sorting if needed, and triggering\\n      // `add` events unless silenced.\\n      this.length += length;\\n      index = Parse._isNullOrUndefined(options.at) ? \\n          this.models.length : options.at;\\n      this.models.splice.apply(this.models, [index, 0].concat(models));\\n      if (this.comparator) {\\n        this.sort({silent: true});\\n      }\\n      if (options.silent) {\\n        return this;\\n      }\\n      for (i = 0, length = this.models.length; i < length; i++) {\\n        model = this.models[i];\\n        if (cids[model.cid]) {\\n          options.index = i;\\n          model.trigger('add', model, this, options);\\n        }\\n      }\\n      return this;\\n    },\\n\\n    /**\\n     * Remove a model, or a list of models from the set. Pass silent to avoid\\n     * firing the <code>remove</code> event for every model removed.\\n     *\\n     * @param {Array} models The model or list of models to remove from the\\n     *   collection.\\n     * @param {Object} options An optional object with Backbone-style options.\\n     * Valid options are: <ul>\\n     *   <li>silent: Set to true to avoid firing the `remove` event.\\n     * </ul>\\n     */\\n    remove: function(models, options) {\\n      var i, l, index, model;\\n      options = options || {};\\n      models = _.isArray(models) ? models.slice() : [models];\\n      for (i = 0, l = models.length; i < l; i++) {\\n        model = this.getByCid(models[i]) || this.get(models[i]);\\n        if (!model) {\\n          continue;\\n        }\\n        delete this._byId[model.id];\\n        delete this._byCid[model.cid];\\n        index = this.indexOf(model);\\n        this.models.splice(index, 1);\\n        this.length--;\\n        if (!options.silent) {\\n          options.index = index;\\n          model.trigger('remove', model, this, options);\\n        }\\n        this._removeReference(model);\\n      }\\n      return this;\\n    },\\n\\n    /**\\n     * Gets a model from the set by id.\\n     * @param {String} id The Parse objectId identifying the Parse.Object to\\n     * fetch from this collection.\\n     */\\n    get: function(id) {\\n      return id && this._byId[id.id || id];\\n    },\\n\\n    /**\\n     * Gets a model from the set by client id.\\n     * @param {} cid The Backbone collection id identifying the Parse.Object to\\n     * fetch from this collection.\\n     */\\n    getByCid: function(cid) {\\n      return cid && this._byCid[cid.cid || cid];\\n    },\\n\\n    /**\\n     * Gets the model at the given index.\\n     *\\n     * @param {Number} index The index of the model to return.\\n     */\\n    at: function(index) {\\n      return this.models[index];\\n    },\\n\\n    /**\\n     * Forces the collection to re-sort itself. You don't need to call this\\n     * under normal circumstances, as the set will maintain sort order as each\\n     * item is added.\\n     * @param {Object} options An optional object with Backbone-style options.\\n     * Valid options are: <ul>\\n     *   <li>silent: Set to true to avoid firing the `reset` event.\\n     * </ul>\\n     */\\n    sort: function(options) {\\n      options = options || {};\\n      if (!this.comparator) {\\n        throw new Error('Cannot sort a set without a comparator');\\n      }\\n      var boundComparator = _.bind(this.comparator, this);\\n      if (this.comparator.length === 1) {\\n        this.models = this.sortBy(boundComparator);\\n      } else {\\n        this.models.sort(boundComparator);\\n      }\\n      if (!options.silent) {\\n        this.trigger('reset', this, options);\\n      }\\n      return this;\\n    },\\n\\n    /**\\n     * Plucks an attribute from each model in the collection.\\n     * @param {String} attr The attribute to return from each model in the\\n     * collection.\\n     */\\n    pluck: function(attr) {\\n      return _.map(this.models, function(model){ return model.get(attr); });\\n    },\\n\\n    /**\\n     * When you have more items than you want to add or remove individually,\\n     * you can reset the entire set with a new list of models, without firing\\n     * any `add` or `remove` events. Fires `reset` when finished.\\n     *\\n     * @param {Array} models The model or list of models to remove from the\\n     *   collection.\\n     * @param {Object} options An optional object with Backbone-style options.\\n     * Valid options are: <ul>\\n     *   <li>silent: Set to true to avoid firing the `reset` event.\\n     * </ul>\\n     */\\n    reset: function(models, options) {\\n      var self = this;\\n      models = models || [];\\n      options = options || {};\\n      Parse._arrayEach(this.models, function(model) {\\n        self._removeReference(model);\\n      });\\n      this._reset();\\n      this.add(models, {silent: true, parse: options.parse});\\n      if (!options.silent) {\\n        this.trigger('reset', this, options);\\n      }\\n      return this;\\n    },\\n\\n    /**\\n     * Fetches the default set of models for this collection, resetting the\\n     * collection when they arrive. If `add: true` is passed, appends the\\n     * models to the collection instead of resetting.\\n     *\\n     * @param {Object} options An optional object with Backbone-style options.\\n     * Valid options are:<ul>\\n     *   <li>silent: Set to true to avoid firing `add` or `reset` events for\\n     *   models fetched by this fetch.\\n     *   <li>success: A Backbone-style success callback.\\n     *   <li>error: An Backbone-style error callback.\\n     *   <li>useMasterKey: In Cloud Code and Node only, uses the Master Key for\\n     *       this request.\\n     *   <li>sessionToken: A valid session token, used for making a request on\\n     *       behalf of a specific user.\\n     * </ul>\\n     */\\n    fetch: function(options) {\\n      options = _.clone(options) || {};\\n      if (options.parse === undefined) {\\n        options.parse = true;\\n      }\\n      var collection = this;\\n      var query = this.query || new Parse.Query(this.model);\\n      return query.find({\\n        useMasterKey: options.useMasterKey,\\n        sessionToken: options.sessionToken\\n      }).then(function(results) {\\n        if (options.add) {\\n          collection.add(results, options);\\n        } else {\\n          collection.reset(results, options);\\n        }\\n        return collection;\\n      })._thenRunCallbacks(options, this);\\n    },\\n\\n    /**\\n     * Creates a new instance of a model in this collection. Add the model to\\n     * the collection immediately, unless `wait: true` is passed, in which case\\n     * we wait for the server to agree.\\n     *\\n     * @param {Parse.Object} model The new model to create and add to the\\n     *   collection.\\n     * @param {Object} options An optional object with Backbone-style options.\\n     * Valid options are:<ul>\\n     *   <li>wait: Set to true to wait for the server to confirm creation of the\\n     *       model before adding it to the collection.\\n     *   <li>silent: Set to true to avoid firing an `add` event.\\n     *   <li>success: A Backbone-style success callback.\\n     *   <li>error: An Backbone-style error callback.\\n     *   <li>useMasterKey: In Cloud Code and Node only, uses the Master Key for\\n     *       this request.\\n     *   <li>sessionToken: A valid session token, used for making a request on\\n     *       behalf of a specific user.\\n     * </ul>\\n     */\\n    create: function(model, options) {\\n      var coll = this;\\n      options = options ? _.clone(options) : {};\\n      model = this._prepareModel(model, options);\\n      if (!model) {\\n        return false;\\n      }\\n      if (!options.wait) {\\n        coll.add(model, options);\\n      }\\n      var success = options.success;\\n      options.success = function(nextModel, resp, xhr) {\\n        if (options.wait) {\\n          coll.add(nextModel, options);\\n        }\\n        if (success) {\\n          success(nextModel, resp);\\n        } else {\\n          nextModel.trigger('sync', model, resp, options);\\n        }\\n      };\\n      model.save(null, options);\\n      return model;\\n    },\\n\\n    /**\\n     * Converts a response into a list of models to be added to the collection.\\n     * The default implementation is just to pass it through.\\n     * @ignore\\n     */\\n    parse: function(resp, xhr) {\\n      return resp;\\n    },\\n\\n    /**\\n     * Proxy to _'s chain. Can't be proxied the same way the rest of the\\n     * underscore methods are proxied because it relies on the underscore\\n     * constructor.\\n     */\\n    chain: function() {\\n      return _(this.models).chain();\\n    },\\n\\n    /**\\n     * Reset all internal state. Called when the collection is reset.\\n     */\\n    _reset: function(options) {\\n      this.length = 0;\\n      this.models = [];\\n      this._byId  = {};\\n      this._byCid = {};\\n    },\\n\\n    /**\\n     * Prepare a model or hash of attributes to be added to this collection.\\n     */\\n    _prepareModel: function(model, options) {\\n      if (!(model instanceof Parse.Object)) {\\n        var attrs = model;\\n        options.collection = this;\\n        model = new this.model(attrs, options);\\n        if (!model._validate(model.attributes, options)) {\\n          model = false;\\n        }\\n      } else if (!model.collection) {\\n        model.collection = this;\\n      }\\n      return model;\\n    },\\n\\n    /**\\n     * Internal method to remove a model's ties to a collection.\\n     */\\n    _removeReference: function(model) {\\n      if (this === model.collection) {\\n        delete model.collection;\\n      }\\n      model.off('all', this._onModelEvent, this);\\n    },\\n\\n    /**\\n     * Internal method called every time a model in the set fires an event.\\n     * Sets need to update their indexes when models change ids. All other\\n     * events simply proxy through. \\\"add\\\" and \\\"remove\\\" events that originate\\n     * in other collections are ignored.\\n     */\\n    _onModelEvent: function(ev, model, collection, options) {\\n      if ((ev === 'add' || ev === 'remove') && collection !== this) {\\n        return;\\n      }\\n      if (ev === 'destroy') {\\n        this.remove(model, options);\\n      }\\n      if (model && ev === 'change:objectId') {\\n        delete this._byId[model.previous(\\\"objectId\\\")];\\n        this._byId[model.id] = model;\\n      }\\n      this.trigger.apply(this, arguments);\\n    }\\n\\n  });\\n\\n  // Underscore methods that we want to implement on the Collection.\\n  var methods = ['forEach', 'each', 'map', 'reduce', 'reduceRight', 'find',\\n    'detect', 'filter', 'select', 'reject', 'every', 'all', 'some', 'any',\\n    'include', 'contains', 'invoke', 'max', 'min', 'sortBy', 'sortedIndex',\\n    'toArray', 'size', 'first', 'initial', 'rest', 'last', 'without', 'indexOf',\\n    'shuffle', 'lastIndexOf', 'isEmpty', 'groupBy'];\\n\\n  // Mix in each Underscore method as a proxy to `Collection#models`.\\n  Parse._arrayEach(methods, function(method) {\\n    Parse.Collection.prototype[method] = function() {\\n      return _[method].apply(_, [this.models].concat(_.toArray(arguments)));\\n    };\\n  });\\n\\n  /**\\n   * Creates a new subclass of <code>Parse.Collection</code>.  For example,<pre>\\n   *   var MyCollection = Parse.Collection.extend({\\n   *     // Instance properties\\n   *\\n   *     model: MyClass,\\n   *     query: MyQuery,\\n   *\\n   *     getFirst: function() {\\n   *       return this.at(0);\\n   *     }\\n   *   }, {\\n   *     // Class properties\\n   *\\n   *     makeOne: function() {\\n   *       return new MyCollection();\\n   *     }\\n   *   });\\n   *\\n   *   var collection = new MyCollection();\\n   * </pre>\\n   *\\n   * @function\\n   * @param {Object} instanceProps Instance properties for the collection.\\n   * @param {Object} classProps Class properies for the collection.\\n   * @return {Class} A new subclass of <code>Parse.Collection</code>.\\n   */\\n  Parse.Collection.extend = Parse._extend;\\n\\n}(this));\\n\\n/*global _: false, document: false */\\n(function(root) {\\n  root.Parse = root.Parse || {};\\n  var Parse = root.Parse;\\n  var _ = Parse._;\\n\\n  /**\\n   * Creating a Parse.View creates its initial element outside of the DOM,\\n   * if an existing element is not provided...\\n   * @class\\n   *\\n   * <p>A fork of Backbone.View, provided for your convenience.  If you use this\\n   * class, you must also include jQuery, or another library that provides a\\n   * jQuery-compatible $ function.  For more information, see the\\n   * <a href=\\\"http://documentcloud.github.com/backbone/#View\\\">Backbone\\n   * documentation</a>.</p>\\n   * <p><strong><em>Available in the client SDK only.</em></strong></p>\\n   */\\n  Parse.View = function(options) {\\n    this.cid = _.uniqueId('view');\\n    this._configure(options || {});\\n    this._ensureElement();\\n    this.initialize.apply(this, arguments);\\n    this.delegateEvents();\\n  };\\n\\n  // Cached regex to split keys for `delegate`.\\n  var eventSplitter = /^(\\\\S+)\\\\s*(.*)$/;\\n\\n  // List of view options to be merged as properties.\\n  // TODO: include objectId, createdAt, updatedAt?\\n  var viewOptions = ['model', 'collection', 'el', 'id', 'attributes',\\n                     'className', 'tagName'];\\n\\n  // Set up all inheritable **Parse.View** properties and methods.\\n  _.extend(Parse.View.prototype, Parse.Events,\\n           /** @lends Parse.View.prototype */ {\\n\\n    // The default `tagName` of a View's element is `\\\"div\\\"`.\\n    tagName: 'div',\\n\\n    /**\\n     * jQuery delegate for element lookup, scoped to DOM elements within the\\n     * current view. This should be prefered to global lookups where possible.\\n     */\\n    $: function(selector) {\\n      return this.$el.find(selector);\\n    },\\n\\n    /**\\n     * Initialize is an empty function by default. Override it with your own\\n     * initialization logic.\\n     */\\n    initialize: function(){},\\n\\n    /**\\n     * The core function that your view should override, in order\\n     * to populate its element (`this.el`), with the appropriate HTML. The\\n     * convention is for **render** to always return `this`.\\n     */\\n    render: function() {\\n      return this;\\n    },\\n\\n    /**\\n     * Remove this view from the DOM. Note that the view isn't present in the\\n     * DOM by default, so calling this method may be a no-op.\\n     */\\n    remove: function() {\\n      this.$el.remove();\\n      return this;\\n    },\\n\\n    /**\\n     * For small amounts of DOM Elements, where a full-blown template isn't\\n     * needed, use **make** to manufacture elements, one at a time.\\n     * <pre>\\n     *     var el = this.make('li', {'class': 'row'},\\n     *                        this.model.escape('title'));</pre>\\n     */\\n    make: function(tagName, attributes, content) {\\n      var el = document.createElement(tagName);\\n      if (attributes) {\\n        Parse.$(el).attr(attributes);\\n      }\\n      if (content) {\\n        Parse.$(el).html(content);\\n      }\\n      return el;\\n    },\\n\\n    /**\\n     * Changes the view's element (`this.el` property), including event\\n     * re-delegation.\\n     */\\n    setElement: function(element, delegate) {\\n      this.$el = Parse.$(element);\\n      this.el = this.$el[0];\\n      if (delegate !== false) {\\n        this.delegateEvents();\\n      }\\n      return this;\\n    },\\n\\n    /**\\n     * Set callbacks.  <code>this.events</code> is a hash of\\n     * <pre>\\n     * *{\\\"event selector\\\": \\\"callback\\\"}*\\n     *\\n     *     {\\n     *       'mousedown .title':  'edit',\\n     *       'click .button':     'save'\\n     *       'click .open':       function(e) { ... }\\n     *     }\\n     * </pre>\\n     * pairs. Callbacks will be bound to the view, with `this` set properly.\\n     * Uses event delegation for efficiency.\\n     * Omitting the selector binds the event to `this.el`.\\n     * This only works for delegate-able events: not `focus`, `blur`, and\\n     * not `change`, `submit`, and `reset` in Internet Explorer.\\n     */\\n    delegateEvents: function(events) {\\n      events = events || Parse._getValue(this, 'events');\\n      if (!events) {\\n        return;\\n      }\\n      this.undelegateEvents();\\n      var self = this;\\n      Parse._objectEach(events, function(method, key) {\\n        if (!_.isFunction(method)) {\\n          method = self[events[key]];\\n        }\\n        if (!method) {\\n          throw new Error('Event \\\"' + events[key] + '\\\" does not exist');\\n        }\\n        var match = key.match(eventSplitter);\\n        var eventName = match[1], selector = match[2];\\n        method = _.bind(method, self);\\n        eventName += '.delegateEvents' + self.cid;\\n        if (selector === '') {\\n          self.$el.bind(eventName, method);\\n        } else {\\n          self.$el.delegate(selector, eventName, method);\\n        }\\n      });\\n    },\\n\\n    /**\\n     * Clears all callbacks previously bound to the view with `delegateEvents`.\\n     * You usually don't need to use this, but may wish to if you have multiple\\n     * Backbone views attached to the same DOM element.\\n     */\\n    undelegateEvents: function() {\\n      this.$el.unbind('.delegateEvents' + this.cid);\\n    },\\n\\n    /**\\n     * Performs the initial configuration of a View with a set of options.\\n     * Keys with special meaning *(model, collection, id, className)*, are\\n     * attached directly to the view.\\n     */\\n    _configure: function(options) {\\n      if (this.options) {\\n        options = _.extend({}, this.options, options);\\n      }\\n      var self = this;\\n      _.each(viewOptions, function(attr) {\\n        if (options[attr]) {\\n          self[attr] = options[attr];\\n        }\\n      });\\n      this.options = options;\\n    },\\n\\n    /**\\n     * Ensure that the View has a DOM element to render into.\\n     * If `this.el` is a string, pass it through `$()`, take the first\\n     * matching element, and re-assign it to `el`. Otherwise, create\\n     * an element from the `id`, `className` and `tagName` properties.\\n     */\\n    _ensureElement: function() {\\n      if (!this.el) {\\n        var attrs = Parse._getValue(this, 'attributes') || {};\\n        if (this.id) {\\n          attrs.id = this.id;\\n        }\\n        if (this.className) {\\n          attrs['class'] = this.className;\\n        }\\n        this.setElement(this.make(this.tagName, attrs), false);\\n      } else {\\n        this.setElement(this.el, false);\\n      }\\n    }\\n\\n  });\\n\\n  /**\\n   * @function\\n   * @param {Object} instanceProps Instance properties for the view.\\n   * @param {Object} classProps Class properies for the view.\\n   * @return {Class} A new subclass of <code>Parse.View</code>.\\n   */\\n  Parse.View.extend = Parse._extend;\\n\\n}(this));\\n\\n(function(root) {\\n  root.Parse = root.Parse || {};\\n  var Parse = root.Parse;\\n  var _ = Parse._;\\n\\n  /**\\n   * @class\\n   *\\n   * <p>A Parse.User object is a local representation of a user persisted to the\\n   * Parse cloud. This class is a subclass of a Parse.Object, and retains the\\n   * same functionality of a Parse.Object, but also extends it with various\\n   * user specific methods, like authentication, signing up, and validation of\\n   * uniqueness.</p>\\n   */\\n  Parse.User = Parse.Object.extend(\\\"_User\\\", /** @lends Parse.User.prototype */ {\\n    // Instance Variables\\n    _isCurrentUser: false,\\n\\n\\n    // Instance Methods\\n    \\n    /**\\n     * Merges another object's attributes into this object.\\n     */\\n    _mergeFromObject: function(other) {\\n      if (other.getSessionToken()) {\\n        this._sessionToken = other.getSessionToken();      \\n      }    \\n      Parse.User.__super__._mergeFromObject.call(this, other);\\n    },    \\n\\n    /**\\n     * Internal method to handle special fields in a _User response.\\n     */\\n    _mergeMagicFields: function(attrs) {\\n      if (attrs.sessionToken) {\\n        this._sessionToken = attrs.sessionToken;\\n        delete attrs.sessionToken;\\n      }\\n      Parse.User.__super__._mergeMagicFields.call(this, attrs);\\n    },\\n\\n    /**\\n     * Removes null values from authData (which exist temporarily for\\n     * unlinking)\\n     */\\n    _cleanupAuthData: function() {\\n      if (!this.isCurrent()) {\\n        return;\\n      }\\n      var authData = this.get('authData');\\n      if (!authData) {\\n        return;\\n      }\\n      Parse._objectEach(this.get('authData'), function(value, key) {\\n        if (!authData[key]) {\\n          delete authData[key];\\n        }\\n      });\\n    },\\n\\n    /**\\n     * Synchronizes authData for all providers.\\n     */\\n    _synchronizeAllAuthData: function() {\\n      var authData = this.get('authData');\\n      if (!authData) {\\n        return;\\n      }\\n\\n      var self = this;\\n      Parse._objectEach(this.get('authData'), function(value, key) {\\n        self._synchronizeAuthData(key);\\n      });\\n    },\\n\\n    /**\\n     * Synchronizes auth data for a provider (e.g. puts the access token in the\\n     * right place to be used by the Facebook SDK).\\n     */\\n    _synchronizeAuthData: function(provider) {\\n      if (!this.isCurrent()) {\\n        return;\\n      }\\n      var authType;\\n      if (_.isString(provider)) {\\n        authType = provider;\\n        provider = Parse.User._authProviders[authType];\\n      } else {\\n        authType = provider.getAuthType();\\n      }\\n      var authData = this.get('authData');\\n      if (!authData || !provider) {\\n        return;\\n      }\\n      var success = provider.restoreAuthentication(authData[authType]);\\n      if (!success) {\\n        this._unlinkFrom(provider);\\n      }\\n    },\\n\\n    _handleSaveResult: function(makeCurrent) {\\n      // Clean up and synchronize the authData object, removing any unset values\\n      if (makeCurrent) {\\n        this._isCurrentUser = true;\\n      }\\n      this._cleanupAuthData();\\n      this._synchronizeAllAuthData();\\n      // Don't keep the password around.\\n      delete this._serverData.password;\\n      this._rebuildEstimatedDataForKey(\\\"password\\\");\\n      this._refreshCache();\\n      if (makeCurrent || this.isCurrent()) {\\n        Parse.User._saveCurrentUser(this);\\n      }\\n    },\\n\\n    /**\\n     * Unlike in the Android/iOS SDKs, logInWith is unnecessary, since you can\\n     * call linkWith on the user (even if it doesn't exist yet on the server).\\n     */\\n    _linkWith: function(provider, options) {\\n      var authType;\\n      if (_.isString(provider)) {\\n        authType = provider;\\n        provider = Parse.User._authProviders[provider];\\n      } else {\\n        authType = provider.getAuthType();\\n      }\\n      if (_.has(options, 'authData')) {\\n        var authData = this.get('authData') || {};\\n        authData[authType] = options.authData;\\n        this.set('authData', authData);\\n\\n        // Overridden so that the user can be made the current user.\\n        var newOptions = _.clone(options) || {};\\n        newOptions.success = function(model) {\\n          model._handleSaveResult(true);\\n          if (options.success) {\\n            options.success.apply(this, arguments);\\n          }\\n        };\\n        return this.save({'authData': authData}, newOptions);\\n      } else {\\n        var self = this;\\n        var promise = new Parse.Promise();\\n        provider.authenticate({\\n          success: function(provider, result) {\\n            self._linkWith(provider, {\\n              authData: result,\\n              success: options.success,\\n              error: options.error\\n            }).then(function() {\\n              promise.resolve(self);\\n            });\\n          },\\n          error: function(provider, error) {\\n            if (options.error) {\\n              options.error(self, error);\\n            }\\n            promise.reject(error);\\n          }\\n        });\\n        return promise;\\n      }\\n    },\\n\\n    /**\\n     * Unlinks a user from a service.\\n     */\\n    _unlinkFrom: function(provider, options) {\\n      var authType;\\n      if (_.isString(provider)) {\\n        authType = provider;\\n        provider = Parse.User._authProviders[provider];\\n      } else {\\n        authType = provider.getAuthType();\\n      }\\n      var newOptions = _.clone(options);\\n      var self = this;\\n      newOptions.authData = null;\\n      newOptions.success = function(model) {\\n        self._synchronizeAuthData(provider);\\n        if (options.success) {\\n          options.success.apply(this, arguments);\\n        }\\n      };\\n      return this._linkWith(provider, newOptions);\\n    },\\n\\n    /**\\n     * Checks whether a user is linked to a service.\\n     */\\n    _isLinked: function(provider) {\\n      var authType;\\n      if (_.isString(provider)) {\\n        authType = provider;\\n      } else {\\n        authType = provider.getAuthType();\\n      }\\n      var authData = this.get('authData') || {};\\n      return !!authData[authType];\\n    },\\n\\n    /**\\n     * Deauthenticates all providers.\\n     */\\n    _logOutWithAll: function() {\\n      var authData = this.get('authData');\\n      if (!authData) {\\n        return;\\n      }\\n      var self = this;\\n      Parse._objectEach(this.get('authData'), function(value, key) {\\n        self._logOutWith(key);\\n      });\\n    },\\n\\n    /**\\n     * Deauthenticates a single provider (e.g. removing access tokens from the\\n     * Facebook SDK).\\n     */\\n    _logOutWith: function(provider) {\\n      if (!this.isCurrent()) {\\n        return;\\n      }\\n      if (_.isString(provider)) {\\n        provider = Parse.User._authProviders[provider];\\n      }\\n      if (provider && provider.deauthenticate) {\\n        provider.deauthenticate();\\n      }\\n    },\\n\\n    /**\\n     * Signs up a new user. You should call this instead of save for\\n     * new Parse.Users. This will create a new Parse.User on the server, and\\n     * also persist the session on disk so that you can access the user using\\n     * <code>current</code>.\\n     *\\n     * <p>A username and password must be set before calling signUp.</p>\\n     *\\n     * <p>Calls options.success or options.error on completion.</p>\\n     *\\n     * @param {Object} attrs Extra fields to set on the new user, or null.\\n     * @param {Object} options A Backbone-style options object.\\n     * @return {Parse.Promise} A promise that is fulfilled when the signup\\n     *     finishes.\\n     * @see Parse.User.signUp\\n     */\\n    signUp: function(attrs, options) {\\n      var error;\\n      options = options || {};\\n\\n      var username = (attrs && attrs.username) || this.get(\\\"username\\\");\\n      if (!username || (username === \\\"\\\")) {\\n        error = new Parse.Error(\\n            Parse.Error.OTHER_CAUSE,\\n            \\\"Cannot sign up user with an empty name.\\\");\\n        if (options && options.error) {\\n          options.error(this, error);\\n        }\\n        return Parse.Promise.error(error);\\n      }\\n\\n      var password = (attrs && attrs.password) || this.get(\\\"password\\\");\\n      if (!password || (password === \\\"\\\")) {\\n        error = new Parse.Error(\\n            Parse.Error.OTHER_CAUSE,\\n            \\\"Cannot sign up user with an empty password.\\\");\\n        if (options && options.error) {\\n          options.error(this, error);\\n        }\\n        return Parse.Promise.error(error);\\n      }\\n\\n      // Overridden so that the user can be made the current user.\\n      var newOptions = _.clone(options);\\n      newOptions.success = function(model) {\\n        model._handleSaveResult(Parse.User._canUseCurrentUser());\\n        if (options.success) {\\n          options.success.apply(this, arguments);\\n        }\\n      };\\n      return this.save(attrs, newOptions);\\n    },\\n\\n    /**\\n     * Logs in a Parse.User. On success, this saves the session to localStorage,\\n     * so you can retrieve the currently logged in user using\\n     * <code>current</code>.\\n     *\\n     * <p>A username and password must be set before calling logIn.</p>\\n     *\\n     * <p>Calls options.success or options.error on completion.</p>\\n     *\\n     * @param {Object} options A Backbone-style options object.\\n     * @see Parse.User.logIn\\n     * @return {Parse.Promise} A promise that is fulfilled with the user when\\n     *     the login is complete.\\n     */\\n    logIn: function(options) {\\n      if (!Parse.User._canUseCurrentUser()) {\\n        throw new Error(\\n          'It is not possible to log in on a server environment.'\\n        );\\n      }\\n      var model = this;\\n      options = options || {};\\n      var request = Parse._request({\\n        route: \\\"login\\\",\\n        method: \\\"GET\\\",\\n        useMasterKey: options.useMasterKey,\\n        data: this.toJSON()\\n      });\\n      return request.then(function(resp, status, xhr) {\\n        var serverAttrs = model.parse(resp, status, xhr);\\n        model._finishFetch(serverAttrs);\\n        model._handleSaveResult(true);\\n        return model;\\n      })._thenRunCallbacks(options, this);\\n    },\\n\\n    /**\\n     * @see Parse.Object#save\\n     */\\n    save: function(arg1, arg2, arg3) {\\n      var i, attrs, current, options, saved;\\n      if (_.isObject(arg1) || _.isNull(arg1) || _.isUndefined(arg1)) {\\n        attrs = arg1;\\n        options = arg2;\\n      } else {\\n        attrs = {};\\n        attrs[arg1] = arg2;\\n        options = arg3;\\n      }\\n      options = options || {};\\n\\n      var newOptions = _.clone(options);\\n      newOptions.success = function(model) {\\n        model._handleSaveResult(false);\\n        if (options.success) {\\n          options.success.apply(this, arguments);\\n        }\\n      };\\n      return Parse.Object.prototype.save.call(this, attrs, newOptions);\\n    },\\n\\n    /**\\n     * @see Parse.Object#fetch\\n     */\\n    fetch: function(options) {\\n      var newOptions = options ? _.clone(options) : {};\\n      newOptions.success = function(model) {\\n        model._handleSaveResult(false);\\n        if (options && options.success) {\\n          options.success.apply(this, arguments);\\n        }\\n      };\\n      return Parse.Object.prototype.fetch.call(this, newOptions);\\n    },\\n\\n    /**\\n     * Returns true if <code>current</code> would return this user.\\n     * @see Parse.User#current\\n     */\\n    isCurrent: function() {\\n      return this._isCurrentUser;\\n    },\\n\\n    /**\\n     * Returns get(\\\"username\\\").\\n     * @return {String}\\n     * @see Parse.Object#get\\n     */\\n    getUsername: function() {\\n      return this.get(\\\"username\\\");\\n    },\\n\\n    /**\\n     * Calls set(\\\"username\\\", username, options) and returns the result.\\n     * @param {String} username\\n     * @param {Object} options A Backbone-style options object.\\n     * @return {Boolean}\\n     * @see Parse.Object.set\\n     */\\n    setUsername: function(username, options) {\\n      return this.set(\\\"username\\\", username, options);\\n    },\\n\\n    /**\\n     * Calls set(\\\"password\\\", password, options) and returns the result.\\n     * @param {String} password\\n     * @param {Object} options A Backbone-style options object.\\n     * @return {Boolean}\\n     * @see Parse.Object.set\\n     */\\n    setPassword: function(password, options) {\\n      return this.set(\\\"password\\\", password, options);\\n    },\\n\\n    /**\\n     * Returns get(\\\"email\\\").\\n     * @return {String}\\n     * @see Parse.Object#get\\n     */\\n    getEmail: function() {\\n      return this.get(\\\"email\\\");\\n    },\\n\\n    /**\\n     * Calls set(\\\"email\\\", email, options) and returns the result.\\n     * @param {String} email\\n     * @param {Object} options A Backbone-style options object.\\n     * @return {Boolean}\\n     * @see Parse.Object.set\\n     */\\n    setEmail: function(email, options) {\\n      return this.set(\\\"email\\\", email, options);\\n    },\\n\\n    /**\\n     * Checks whether this user is the current user and has been authenticated.\\n     * @return (Boolean) whether this user is the current user and is logged in.\\n     */\\n    authenticated: function() {\\n      return !!this._sessionToken &&\\n          (Parse.User.current() && Parse.User.current().id === this.id);\\n    },\\n\\n    /**\\n     * Returns the session token for this user, if the user has been logged in,\\n     * or if it is the result of a query with the master key. Otherwise, returns\\n     * undefined.\\n     * @return {String} the session token, or undefined\\n     */\\n    getSessionToken: function() {\\n      return this._sessionToken;\\n    },\\n\\n    /**\\n     * Request a revocable session token to replace the older style of token.\\n     * @param {Object} options A Backbone-style options object.\\n     *\\n     * @return {Parse.Promise} A promise that is resolved when the replacement\\n     *   token has been fetched.\\n     */\\n    _upgradeToRevocableSession: function(options) {\\n      options = options || {};\\n      if (!Parse.User.current()) {\\n        return Parse.Promise.as()._thenRunCallbacks(options);\\n      }\\n      var currentSession = Parse.User.current().getSessionToken();\\n      if (Parse.Session._isRevocable(currentSession)) {\\n        return Parse.Promise.as()._thenRunCallbacks(options);\\n      }\\n      return Parse._request({\\n        route: 'upgradeToRevocableSession',\\n        method: 'POST',\\n        useMasterKey: options.useMasterKey,\\n        sessionToken: currentSession\\n      }).then(function(result) {\\n        var session = new Parse.Session();\\n        session._finishFetch(result);\\n        var currentUser = Parse.User.current();\\n        currentUser._sessionToken = session.getSessionToken();\\n        Parse.User._saveCurrentUser(currentUser);\\n      })._thenRunCallbacks(options);\\n    },\\n\\n  }, /** @lends Parse.User */ {\\n    // Class Variables\\n\\n    // The currently logged-in user.\\n    _currentUser: null,\\n\\n    // Whether currentUser is known to match the serialized version on disk.\\n    // This is useful for saving a localstorage check if you try to load\\n    // _currentUser frequently while there is none stored.\\n    _currentUserMatchesDisk: false,\\n\\n    // The localStorage key suffix that the current user is stored under.\\n    _CURRENT_USER_KEY: \\\"currentUser\\\",\\n\\n    // The mapping of auth provider names to actual providers\\n    _authProviders: {},\\n\\n    // Whether to rewrite className User to _User\\n    _performUserRewrite: true,\\n\\n    // Whether to send a Revocable Session header\\n    _isRevocableSessionEnabled: false,\\n\\n    // Whether to enable a memory-unsafe current user in node.js\\n    _enableUnsafeCurrentUser: false,\\n\\n\\n    // Class Methods\\n\\n    /**\\n     * Signs up a new user with a username (or email) and password.\\n     * This will create a new Parse.User on the server, and also persist the\\n     * session in localStorage so that you can access the user using\\n     * {@link #current}.\\n     *\\n     * <p>Calls options.success or options.error on completion.</p>\\n     *\\n     * @param {String} username The username (or email) to sign up with.\\n     * @param {String} password The password to sign up with.\\n     * @param {Object} attrs Extra fields to set on the new user.\\n     * @param {Object} options A Backbone-style options object.\\n     * @return {Parse.Promise} A promise that is fulfilled with the user when\\n     *     the signup completes.\\n     * @see Parse.User#signUp\\n     */\\n    signUp: function(username, password, attrs, options) {\\n      attrs = attrs || {};\\n      attrs.username = username;\\n      attrs.password = password;\\n      var user = Parse.Object._create(\\\"_User\\\");\\n      return user.signUp(attrs, options);\\n    },\\n\\n    /**\\n     * Logs in a user with a username (or email) and password. On success, this\\n     * saves the session to disk, so you can retrieve the currently logged in\\n     * user using <code>current</code>.\\n     *\\n     * <p>Calls options.success or options.error on completion.</p>\\n     *\\n     * @param {String} username The username (or email) to log in with.\\n     * @param {String} password The password to log in with.\\n     * @param {Object} options A Backbone-style options object.\\n     * @return {Parse.Promise} A promise that is fulfilled with the user when\\n     *     the login completes.\\n     * @see Parse.User#logIn\\n     */\\n    logIn: function(username, password, options) {\\n      var user = Parse.Object._create(\\\"_User\\\");\\n      user._finishFetch({ username: username, password: password });\\n      return user.logIn(options);\\n    },\\n\\n    /**\\n     * Logs in a user with a session token. On success, this saves the session\\n     * to disk, so you can retrieve the currently logged in user using\\n     * <code>current</code>.\\n     *\\n     * <p>Calls options.success or options.error on completion.</p>\\n     *\\n     * @param {String} sessionToken The sessionToken to log in with.\\n     * @param {Object} options A Backbone-style options object.\\n     * @return {Parse.Promise} A promise that is fulfilled with the user when\\n     *     the login completes.\\n     */\\n    become: function(sessionToken, options) {\\n      if (!Parse.User._canUseCurrentUser()) {\\n        throw new Error(\\n          'It is not secure to become a user on a node.js server environment.'\\n        );\\n      }\\n      options = options || {};\\n\\n      var user = Parse.Object._create(\\\"_User\\\");\\n      return Parse._request({\\n        route: \\\"users\\\",\\n        className: \\\"me\\\",\\n        method: \\\"GET\\\",\\n        useMasterKey: options.useMasterKey,\\n        sessionToken: sessionToken\\n      }).then(function(resp, status, xhr) {\\n        var serverAttrs = user.parse(resp, status, xhr);\\n        user._finishFetch(serverAttrs);\\n        user._handleSaveResult(true);\\n        return user;\\n\\n      })._thenRunCallbacks(options, user);\\n    },\\n\\n    /**\\n     * Logs out the currently logged in user session. This will remove the\\n     * session from disk, log out of linked services, and future calls to\\n     * <code>current</code> will return <code>null</code>.\\n     * @return {Parse.Promise} A promise that is resolved when the session is\\n     *   destroyed on the server.\\n     */\\n    logOut: function() {\\n      if (!Parse.User._canUseCurrentUser()) {\\n        throw new Error(\\n          'There is no current user user on a node.js server environment.'\\n        );\\n      }\\n      return Parse.User._currentAsync().then(function(currentUser) {\\n        var promise = Parse.Storage.removeItemAsync(\\n          Parse._getParsePath(Parse.User._CURRENT_USER_KEY));\\n\\n        if (currentUser !== null) {\\n          var currentSession = currentUser.getSessionToken();\\n          if (Parse.Session._isRevocable(currentSession)) {\\n            promise.then(function() {\\n              return Parse._request({\\n                route: 'logout',\\n                method: 'POST',\\n                sessionToken: currentSession\\n              });\\n            });\\n          }\\n          currentUser._logOutWithAll();\\n          currentUser._isCurrentUser = false;\\n        }\\n        Parse.User._currentUserMatchesDisk = true;\\n        Parse.User._currentUser = null;\\n\\n        return promise;\\n      });\\n    },\\n\\n    /**\\n     * Requests a password reset email to be sent to the specified email address\\n     * associated with the user account. This email allows the user to securely\\n     * reset their password on the Parse site.\\n     *\\n     * <p>Calls options.success or options.error on completion.</p>\\n     *\\n     * @param {String} email The email address associated with the user that\\n     *     forgot their password.\\n     * @param {Object} options A Backbone-style options object.\\n     */\\n    requestPasswordReset: function(email, options) {\\n      options = options || {};\\n      var request = Parse._request({\\n        route: \\\"requestPasswordReset\\\",\\n        method: \\\"POST\\\",\\n        useMasterKey: options.useMasterKey,\\n        data: { email: email }\\n      });\\n      return request._thenRunCallbacks(options);\\n    },\\n\\n    /**\\n     * Retrieves the currently logged in ParseUser with a valid session,\\n     * either from memory or localStorage, if necessary.\\n     * @return {Parse.Object} The currently logged in Parse.User.\\n     */\\n    current: function() {\\n      if (!Parse.User._canUseCurrentUser()) {\\n        throw new Error(\\n          'There is no current user user on a node.js server environment.'\\n        );\\n      }\\n      if (Parse.Storage.async) {\\n        // We can't return the current user synchronously\\n        Parse.User._currentAsync();\\n        return Parse.User._currentUser;\\n      }\\n      \\n      if (Parse.User._currentUser) {\\n        return Parse.User._currentUser;\\n      }\\n\\n      if (Parse.User._currentUserMatchesDisk) {\\n        // TODO: Lazily log in anonymous user.\\n        return Parse.User._currentUser;\\n      }\\n\\n      // Load the user from local storage.\\n      Parse.User._currentUserMatchesDisk = true;\\n\\n      var userData = Parse.Storage.getItem(Parse._getParsePath(\\n          Parse.User._CURRENT_USER_KEY));\\n      if (!userData) {\\n        // TODO: Lazily log in anonymous user.\\n        return null;\\n      }\\n      Parse.User._currentUser = Parse.Object._create(\\\"_User\\\");\\n      Parse.User._currentUser._isCurrentUser = true;\\n\\n      var json = JSON.parse(userData);\\n      Parse.User._currentUser.id = json._id;\\n      delete json._id;\\n      Parse.User._currentUser._sessionToken = json._sessionToken;\\n      delete json._sessionToken;\\n      Parse.User._currentUser._finishFetch(json);\\n\\n      Parse.User._currentUser._synchronizeAllAuthData();\\n      Parse.User._currentUser._refreshCache();\\n      Parse.User._currentUser._opSetQueue = [{}];\\n      return Parse.User._currentUser;\\n    },\\n\\n    /**\\n     * Retrieves the currently logged in ParseUser from asynchronous Storage.\\n     * @return {Parse.Promise} A Promise that is resolved with the currently\\n     *   logged in Parse User\\n     */\\n    _currentAsync: function() {\\n      if (Parse.User._currentUser) {\\n        return Parse.Promise.as(Parse.User._currentUser);\\n      }\\n\\n      if (Parse.User._currentUserMatchesDisk) {\\n        return Parse.Promise.as(Parse.User._currentUser);\\n      }\\n\\n      // Load the user from Storage\\n      return Parse.Storage.getItemAsync(Parse._getParsePath(\\n        Parse.User._CURRENT_USER_KEY)).then(function(userData) {\\n        if (!userData) {\\n          return null;\\n        }\\n        Parse.User._currentUser = Parse.Object._create(\\\"_User\\\");\\n        Parse.User._currentUser._isCurrentUser = true;\\n\\n        var json = JSON.parse(userData);\\n        Parse.User._currentUser.id = json._id;\\n        delete json._id;\\n        Parse.User._currentUser._sessionToken = json._sessionToken;\\n        delete json._sessionToken;\\n        Parse.User._currentUser._finishFetch(json);\\n\\n        Parse.User._currentUser._synchronizeAllAuthData();\\n        Parse.User._currentUser._refreshCache();\\n        Parse.User._currentUser._opSetQueue = [{}];\\n        return Parse.User._currentUser;\\n      });\\n    },\\n\\n    /**\\n     * Allow someone to define a custom User class without className\\n     * being rewritten to _User. The default behavior is to rewrite\\n     * User to _User for legacy reasons. This allows developers to\\n     * override that behavior.\\n     *\\n     * @param {Boolean} isAllowed Whether or not to allow custom User class\\n     */\\n    allowCustomUserClass: function(isAllowed) {\\n      this._performUserRewrite = !isAllowed;\\n    },\\n\\n    /**\\n     * Allow a legacy application to start using revocable sessions. If the\\n     * current session token is not revocable, a request will be made for a new,\\n     * revocable session.\\n     * It is not necessary to call this method from cloud code unless you are\\n     * handling user signup or login from the server side. In a cloud code call,\\n     * this function will not attempt to upgrade the current token.\\n     * @param {Object} options A Backbone-style options object.\\n     *\\n     * @return {Parse.Promise} A promise that is resolved when the process has\\n     *   completed. If a replacement session token is requested, the promise\\n     *   will be resolved after a new token has been fetched.\\n     */\\n    enableRevocableSession: function(options) {\\n      options = options || {};\\n      Parse.User._isRevocableSessionEnabled = true;\\n      if (Parse.User._canUseCurrentUser() && Parse.User.current()) {\\n        return Parse.User.current()._upgradeToRevocableSession(options);\\n      }\\n      return Parse.Promise.as()._thenRunCallbacks(options);\\n    },\\n\\n    /**\\n     *\\n     */\\n    enableUnsafeCurrentUser: function() {\\n      Parse.User._enableUnsafeCurrentUser = true;\\n    },\\n\\n    _canUseCurrentUser: function() {\\n      return !Parse._isNode || Parse.User._enableUnsafeCurrentUser;\\n    },\\n\\n    /**\\n     * Persists a user as currentUser to localStorage, and into the singleton.\\n     */\\n    _saveCurrentUser: function(user) {\\n      if (Parse.User._currentUser !== null &&\\n          Parse.User._currentUser !== user) {\\n        Parse.User.logOut();\\n      }\\n      user._isCurrentUser = true;\\n      Parse.User._currentUser = user;\\n      Parse.User._currentUserMatchesDisk = true;\\n\\n      var json = user.toJSON();\\n      json._id = user.id;\\n      json._sessionToken = user._sessionToken;\\n      if (Parse.Storage.async) {\\n        Parse.Storage.setItemAsync(\\n          Parse._getParsePath(Parse.User._CURRENT_USER_KEY),\\n          JSON.stringify(json));\\n      } else {\\n        Parse.Storage.setItem(\\n          Parse._getParsePath(Parse.User._CURRENT_USER_KEY),\\n          JSON.stringify(json));\\n      }\\n    },\\n\\n    _registerAuthenticationProvider: function(provider) {\\n      Parse.User._authProviders[provider.getAuthType()] = provider;\\n      // Synchronize the current user with the auth provider.\\n      if (Parse.User.current()) {\\n        Parse.User.current()._synchronizeAuthData(provider.getAuthType());\\n      }\\n    },\\n\\n    _logInWith: function(provider, options) {\\n      var user = Parse.Object._create(\\\"_User\\\");\\n      return user._linkWith(provider, options);\\n    }\\n\\n  });\\n}(this));\\n\\n\\n(function(root) {\\n  root.Parse = root.Parse || {};\\n  var Parse = root.Parse;\\n\\n  /**\\n   * @class\\n   *\\n   * <p>A Parse.Session object is a local representation of a revocable session.\\n   * This class is a subclass of a Parse.Object, and retains the same\\n   * functionality of a Parse.Object.</p>\\n   */\\n  Parse.Session = Parse.Object.extend('_Session',\\n  /** @lends Parse.Session.prototype */\\n  {\\n    /**\\n     * Returns the session token string.\\n     * @return {String}\\n     */\\n    getSessionToken: function() {\\n      return this._sessionToken;\\n    },\\n\\n    /**\\n     * Internal method to handle special fields in a _Session response.\\n     */\\n    _mergeMagicFields: function(attrs) {\\n      if (attrs.sessionToken) {\\n        this._sessionToken = attrs.sessionToken;\\n        delete attrs.sessionToken;\\n      }\\n      Parse.Session.__super__._mergeMagicFields.call(this, attrs);\\n    },\\n  }, /** @lends Parse.Session */ {\\n\\n    // Throw an error when modifying these read-only fields\\n    readOnlyAttributes: {\\n      createdWith: true,\\n      expiresAt: true,\\n      installationId: true,\\n      restricted: true,\\n      sessionToken: true,\\n      user: true\\n    },\\n\\n    /**\\n     * Retrieves the Session object for the currently logged in session.\\n     * @return {Parse.Promise} A promise that is resolved with the Parse.Session\\n     *   object after it has been fetched.\\n     */\\n    current: function(options) {\\n      options = options || {};\\n\\n      var session = Parse.Object._create('_Session');\\n      var currentToken = Parse.User.current().getSessionToken();\\n      return Parse._request({\\n        route: 'sessions',\\n        className: 'me',\\n        method: 'GET',\\n        useMasterKey: options.useMasterKey,\\n        sessionToken: currentToken\\n      }).then(function(resp, status, xhr) {\\n        var serverAttrs = session.parse(resp, status, xhr);\\n        session._finishFetch(serverAttrs);\\n        return session;\\n      })._thenRunCallbacks(options, session);\\n    },\\n\\n    /**\\n     * Determines whether a session token is revocable.\\n     * @return {Boolean}\\n     */\\n    _isRevocable: function(token) {\\n      return token.indexOf('r:') > -1;\\n    },\\n\\n    /**\\n     * Determines whether the current session token is revocable.\\n     * This method is useful for migrating Express.js or Node.js web apps to\\n     * use revocable sessions. If you are migrating an app that uses the Parse\\n     * SDK in the browser only, please use Parse.User.enableRevocableSession()\\n     * instead, so that sessions can be automatically upgraded.\\n     * @return {Boolean}\\n     */\\n    isCurrentSessionRevocable: function() {\\n      if (Parse.User.current() !== null) {\\n        return Parse.Session._isRevocable(\\n          Parse.User.current().getSessionToken()\\n        );\\n      }\\n    }\\n  });\\n})(this);\\n\\n// Parse.Query is a way to create a list of Parse.Objects.\\n(function(root) {\\n  root.Parse = root.Parse || {};\\n  var Parse = root.Parse;\\n  var _ = Parse._;\\n\\n  /**\\n   * Creates a new parse Parse.Query for the given Parse.Object subclass.\\n   * @param objectClass -\\n   *   An instance of a subclass of Parse.Object, or a Parse className string.\\n   * @class\\n   *\\n   * <p>Parse.Query defines a query that is used to fetch Parse.Objects. The\\n   * most common use case is finding all objects that match a query through the\\n   * <code>find</code> method. For example, this sample code fetches all objects\\n   * of class <code>MyClass</code>. It calls a different function depending on\\n   * whether the fetch succeeded or not.\\n   * \\n   * <pre>\\n   * var query = new Parse.Query(MyClass);\\n   * query.find({\\n   *   success: function(results) {\\n   *     // results is an array of Parse.Object.\\n   *   },\\n   *\\n   *   error: function(error) {\\n   *     // error is an instance of Parse.Error.\\n   *   }\\n   * });</pre></p>\\n   * \\n   * <p>A Parse.Query can also be used to retrieve a single object whose id is\\n   * known, through the get method. For example, this sample code fetches an\\n   * object of class <code>MyClass</code> and id <code>myId</code>. It calls a\\n   * different function depending on whether the fetch succeeded or not.\\n   * \\n   * <pre>\\n   * var query = new Parse.Query(MyClass);\\n   * query.get(myId, {\\n   *   success: function(object) {\\n   *     // object is an instance of Parse.Object.\\n   *   },\\n   *\\n   *   error: function(object, error) {\\n   *     // error is an instance of Parse.Error.\\n   *   }\\n   * });</pre></p>\\n   * \\n   * <p>A Parse.Query can also be used to count the number of objects that match\\n   * the query without retrieving all of those objects. For example, this\\n   * sample code counts the number of objects of the class <code>MyClass</code>\\n   * <pre>\\n   * var query = new Parse.Query(MyClass);\\n   * query.count({\\n   *   success: function(number) {\\n   *     // There are number instances of MyClass.\\n   *   },\\n   *\\n   *   error: function(error) {\\n   *     // error is an instance of Parse.Error.\\n   *   }\\n   * });</pre></p>\\n   */\\n  Parse.Query = function(objectClass) {\\n    if (_.isString(objectClass)) {\\n      objectClass = Parse.Object._getSubclass(objectClass);\\n    }\\n\\n    this.objectClass = objectClass;\\n\\n    this.className = objectClass.prototype.className;\\n\\n    this._where = {};\\n    this._include = [];\\n    this._limit = -1; // negative limit means, do not send a limit\\n    this._skip = 0;\\n    this._extraOptions = {};\\n  };\\n\\n  /**\\n   * Constructs a Parse.Query that is the OR of the passed in queries.  For\\n   * example:\\n   * <pre>var compoundQuery = Parse.Query.or(query1, query2, query3);</pre>\\n   *\\n   * will create a compoundQuery that is an or of the query1, query2, and\\n   * query3.\\n   * @param {...Parse.Query} var_args The list of queries to OR.\\n   * @return {Parse.Query} The query that is the OR of the passed in queries.\\n   */\\n  Parse.Query.or = function() {\\n    var queries = _.toArray(arguments);\\n    var className = null;\\n    Parse._arrayEach(queries, function(q) {\\n      if (_.isNull(className)) {\\n        className = q.className;\\n      }\\n\\n      if (className !== q.className) {\\n        throw \\\"All queries must be for the same class\\\";\\n      }\\n    });\\n    var query = new Parse.Query(className);\\n    query._orQuery(queries);\\n    return query;\\n  };\\n\\n  Parse.Query.prototype = {\\n    /**\\n     * Constructs a Parse.Object whose id is already known by fetching data from\\n     * the server.  Either options.success or options.error is called when the\\n     * find completes.\\n     *\\n     * @param {String} objectId The id of the object to be fetched.\\n     * @param {Object} options A Backbone-style options object.\\n     * Valid options are:<ul>\\n     *   <li>success: A Backbone-style success callback\\n     *   <li>error: An Backbone-style error callback.\\n     *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\\n     *     be used for this request.\\n     *   <li>sessionToken: A valid session token, used for making a request on\\n     *       behalf of a specific user.\\n     * </ul>\\n     */\\n    get: function(objectId, options) {\\n      var self = this;\\n      self.equalTo('objectId', objectId);\\n\\n      var firstOptions = {};\\n      if (options && _.has(options, 'useMasterKey')) {\\n        firstOptions = { useMasterKey: options.useMasterKey };\\n      }\\n      if (options && _.has(options, 'sessionToken')) {\\n        firstOptions.sessionToken = options.sessionToken;\\n      }\\n\\n      return self.first(firstOptions).then(function(response) {\\n        if (response) {\\n          return response;\\n        }\\n\\n        var errorObject = new Parse.Error(Parse.Error.OBJECT_NOT_FOUND,\\n                                          \\\"Object not found.\\\");\\n        return Parse.Promise.error(errorObject);\\n\\n      })._thenRunCallbacks(options, null);\\n    },\\n\\n    /**\\n     * Returns a JSON representation of this query.\\n     * @return {Object} The JSON representation of the query.\\n     */\\n    toJSON: function() {\\n      var params = {\\n        where: this._where\\n      };\\n\\n      if (this._include.length > 0) {\\n        params.include = this._include.join(\\\",\\\");\\n      }\\n      if (this._select) {\\n        params.keys = this._select.join(\\\",\\\");\\n      }\\n      if (this._limit >= 0) {\\n        params.limit = this._limit;\\n      }\\n      if (this._skip > 0) {\\n        params.skip = this._skip;\\n      }\\n      if (this._order !== undefined) {\\n        params.order = this._order.join(\\\",\\\");\\n      }\\n\\n      Parse._objectEach(this._extraOptions, function(v, k) {\\n        params[k] = v;\\n      });\\n\\n      return params;\\n    },\\n\\n    /**\\n     * Retrieves a list of ParseObjects that satisfy this query.\\n     * Either options.success or options.error is called when the find\\n     * completes.\\n     *\\n     * @param {Object} options A Backbone-style options object. Valid options\\n     * are:<ul>\\n     *   <li>success: Function to call when the find completes successfully.\\n     *   <li>error: Function to call when the find fails.\\n     *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\\n     *     be used for this request.\\n     *   <li>sessionToken: A valid session token, used for making a request on\\n     *       behalf of a specific user.\\n     * </ul>\\n     *\\n     * @return {Parse.Promise} A promise that is resolved with the results when\\n     * the query completes.\\n     */\\n    find: function(options) {\\n      var self = this;\\n      options = options || {};\\n\\n      var request = Parse._request({\\n        route: \\\"classes\\\",\\n        className: this.className,\\n        method: \\\"GET\\\",\\n        useMasterKey: options.useMasterKey,\\n        sessionToken: options.sessionToken,\\n        data: this.toJSON()\\n      });\\n\\n      return request.then(function(response) {\\n        return _.map(response.results, function(json) {\\n          var obj;\\n          if (response.className) {\\n            obj = new Parse.Object(response.className);\\n          } else {\\n            obj = new self.objectClass();\\n          }\\n          obj._finishFetch(json, true);\\n          return obj;\\n        });\\n      })._thenRunCallbacks(options);\\n    },\\n\\n    /**\\n     * Counts the number of objects that match this query.\\n     * Either options.success or options.error is called when the count\\n     * completes.\\n     *\\n     * @param {Object} options A Backbone-style options object. Valid options\\n     * are:<ul>\\n     *   <li>success: Function to call when the count completes successfully.\\n     *   <li>error: Function to call when the find fails.\\n     *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\\n     *     be used for this request.\\n     *   <li>sessionToken: A valid session token, used for making a request on\\n     *       behalf of a specific user.\\n     * </ul>\\n     *\\n     * @return {Parse.Promise} A promise that is resolved with the count when\\n     * the query completes.\\n     */\\n    count: function(options) {\\n      var self = this;\\n      options = options || {};\\n\\n      var params = this.toJSON();\\n      params.limit = 0;\\n      params.count = 1;\\n      var request = Parse._request({\\n        route: \\\"classes\\\",\\n        className: self.className, \\n        method: \\\"GET\\\",\\n        useMasterKey: options.useMasterKey,\\n        sessionToken: options.sessionToken,\\n        data: params\\n      });\\n\\n      return request.then(function(response) {\\n        return response.count;\\n      })._thenRunCallbacks(options);\\n    },\\n\\n    /**\\n     * Retrieves at most one Parse.Object that satisfies this query.\\n     *\\n     * Either options.success or options.error is called when it completes.\\n     * success is passed the object if there is one. otherwise, undefined.\\n     *\\n     * @param {Object} options A Backbone-style options object. Valid options\\n     * are:<ul>\\n     *   <li>success: Function to call when the find completes successfully.\\n     *   <li>error: Function to call when the find fails.\\n     *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\\n     *     be used for this request.\\n     *   <li>sessionToken: A valid session token, used for making a request on\\n     *       behalf of a specific user.\\n     * </ul>\\n     *\\n     * @return {Parse.Promise} A promise that is resolved with the object when\\n     * the query completes.\\n     */\\n    first: function(options) {\\n      var self = this;\\n      options = options || {};\\n\\n      var params = this.toJSON();\\n      params.limit = 1;\\n      var request = Parse._request({\\n        route: \\\"classes\\\",\\n        className: this.className, \\n        method: \\\"GET\\\",\\n        useMasterKey: options.useMasterKey,\\n        sessionToken: options.sessionToken,\\n        data: params\\n      });\\n\\n      return request.then(function(response) {\\n        return _.map(response.results, function(json) {\\n          var obj;\\n          if (response.className) {\\n            obj = new Parse.Object(response.className);\\n          } else {\\n            obj = new self.objectClass();\\n          }\\n          obj._finishFetch(json, true);\\n          return obj;\\n        })[0];\\n      })._thenRunCallbacks(options);\\n    },\\n\\n    /**\\n     * Returns a new instance of Parse.Collection backed by this query.\\n     * @param {Array} items An array of instances of <code>Parse.Object</code>\\n     *     with which to start this Collection.\\n     * @param {Object} options An optional object with Backbone-style options.\\n     * Valid options are:<ul>\\n     *   <li>model: The Parse.Object subclass that this collection contains.\\n     *   <li>query: An instance of Parse.Query to use when fetching items.\\n     *   <li>comparator: A string property name or function to sort by.\\n     * </ul>\\n     * @return {Parse.Collection}\\n     */\\n    collection: function(items, options) {\\n      options = options || {};\\n      return new Parse.Collection(items, _.extend(options, {\\n        model: this.objectClass,\\n        query: this\\n      }));\\n    },\\n\\n    /**\\n     * Sets the number of results to skip before returning any results.\\n     * This is useful for pagination.\\n     * Default is to skip zero results.\\n     * @param {Number} n the number of results to skip.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    skip: function(n) {\\n      this._skip = n;\\n      return this;\\n    },\\n\\n    /**\\n     * Sets the limit of the number of results to return. The default limit is\\n     * 100, with a maximum of 1000 results being returned at a time.\\n     * @param {Number} n the number of results to limit to.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    limit: function(n) {\\n      this._limit = n;\\n      return this;\\n    },\\n\\n    /**\\n     * Add a constraint to the query that requires a particular key's value to\\n     * be equal to the provided value.\\n     * @param {String} key The key to check.\\n     * @param value The value that the Parse.Object must contain.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    equalTo: function(key, value) {\\n      if (_.isUndefined(value)) {\\n        return this.doesNotExist(key);\\n      } \\n\\n      this._where[key] = Parse._encode(value);\\n      return this;\\n    },\\n\\n    /**\\n     * Helper for condition queries\\n     */\\n    _addCondition: function(key, condition, value) {\\n      // Check if we already have a condition\\n      if (!this._where[key]) {\\n        this._where[key] = {};\\n      }\\n      this._where[key][condition] = Parse._encode(value);\\n      return this;\\n    },\\n\\n    /**\\n     * Add a constraint to the query that requires a particular key's value to\\n     * be not equal to the provided value.\\n     * @param {String} key The key to check.\\n     * @param value The value that must not be equalled.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    notEqualTo: function(key, value) {\\n      this._addCondition(key, \\\"$ne\\\", value);\\n      return this;\\n    },\\n\\n    /**\\n     * Add a constraint to the query that requires a particular key's value to\\n     * be less than the provided value.\\n     * @param {String} key The key to check.\\n     * @param value The value that provides an upper bound.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    lessThan: function(key, value) {\\n      this._addCondition(key, \\\"$lt\\\", value);\\n      return this;\\n    },\\n\\n    /**\\n     * Add a constraint to the query that requires a particular key's value to\\n     * be greater than the provided value.\\n     * @param {String} key The key to check.\\n     * @param value The value that provides an lower bound.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    greaterThan: function(key, value) {\\n      this._addCondition(key, \\\"$gt\\\", value);\\n      return this;\\n    },\\n\\n    /**\\n     * Add a constraint to the query that requires a particular key's value to\\n     * be less than or equal to the provided value.\\n     * @param {String} key The key to check.\\n     * @param value The value that provides an upper bound.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    lessThanOrEqualTo: function(key, value) {\\n      this._addCondition(key, \\\"$lte\\\", value);\\n      return this;\\n    },\\n\\n    /**\\n     * Add a constraint to the query that requires a particular key's value to\\n     * be greater than or equal to the provided value.\\n     * @param {String} key The key to check.\\n     * @param value The value that provides an lower bound.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    greaterThanOrEqualTo: function(key, value) {\\n      this._addCondition(key, \\\"$gte\\\", value);\\n      return this;\\n    },\\n\\n    /**\\n     * Add a constraint to the query that requires a particular key's value to\\n     * be contained in the provided list of values.\\n     * @param {String} key The key to check.\\n     * @param {Array} values The values that will match.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    containedIn: function(key, values) {\\n      this._addCondition(key, \\\"$in\\\", values);\\n      return this;\\n    },\\n\\n    /**\\n     * Add a constraint to the query that requires a particular key's value to\\n     * not be contained in the provided list of values.\\n     * @param {String} key The key to check.\\n     * @param {Array} values The values that will not match.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    notContainedIn: function(key, values) {\\n      this._addCondition(key, \\\"$nin\\\", values);\\n      return this;\\n    },\\n\\n    /**\\n     * Add a constraint to the query that requires a particular key's value to\\n     * contain each one of the provided list of values.\\n     * @param {String} key The key to check.  This key's value must be an array.\\n     * @param {Array} values The values that will match.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    containsAll: function(key, values) {\\n      this._addCondition(key, \\\"$all\\\", values);\\n      return this;\\n    },\\n\\n\\n    /**\\n     * Add a constraint for finding objects that contain the given key.\\n     * @param {String} key The key that should exist.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    exists: function(key) {\\n      this._addCondition(key, \\\"$exists\\\", true);\\n      return this;\\n    },\\n\\n    /**\\n     * Add a constraint for finding objects that do not contain a given key.\\n     * @param {String} key The key that should not exist\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    doesNotExist: function(key) {\\n      this._addCondition(key, \\\"$exists\\\", false);\\n      return this;\\n    },\\n\\n    /**\\n     * Add a regular expression constraint for finding string values that match\\n     * the provided regular expression.\\n     * This may be slow for large datasets.\\n     * @param {String} key The key that the string to match is stored in.\\n     * @param {RegExp} regex The regular expression pattern to match.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    matches: function(key, regex, modifiers) {\\n      this._addCondition(key, \\\"$regex\\\", regex);\\n      if (!modifiers) { modifiers = \\\"\\\"; }\\n      // Javascript regex options support mig as inline options but store them \\n      // as properties of the object. We support mi & should migrate them to\\n      // modifiers\\n      if (regex.ignoreCase) { modifiers += 'i'; }\\n      if (regex.multiline) { modifiers += 'm'; }\\n\\n      if (modifiers && modifiers.length) {\\n        this._addCondition(key, \\\"$options\\\", modifiers);\\n      }\\n      return this;\\n    },\\n\\n    /**\\n     * Add a constraint that requires that a key's value matches a Parse.Query\\n     * constraint.\\n     * @param {String} key The key that the contains the object to match the\\n     *                     query.\\n     * @param {Parse.Query} query The query that should match.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    matchesQuery: function(key, query) {\\n      var queryJSON = query.toJSON();\\n      queryJSON.className = query.className;\\n      this._addCondition(key, \\\"$inQuery\\\", queryJSON);\\n      return this;\\n    },\\n\\n   /**\\n     * Add a constraint that requires that a key's value not matches a\\n     * Parse.Query constraint.\\n     * @param {String} key The key that the contains the object to match the\\n     *                     query.\\n     * @param {Parse.Query} query The query that should not match.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    doesNotMatchQuery: function(key, query) {\\n      var queryJSON = query.toJSON();\\n      queryJSON.className = query.className;\\n      this._addCondition(key, \\\"$notInQuery\\\", queryJSON);\\n      return this;\\n    },\\n\\n\\n    /**\\n     * Add a constraint that requires that a key's value matches a value in\\n     * an object returned by a different Parse.Query.\\n     * @param {String} key The key that contains the value that is being\\n     *                     matched.\\n     * @param {String} queryKey The key in the objects returned by the query to\\n     *                          match against.\\n     * @param {Parse.Query} query The query to run.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    matchesKeyInQuery: function(key, queryKey, query) {\\n      var queryJSON = query.toJSON();\\n      queryJSON.className = query.className;\\n      this._addCondition(key, \\\"$select\\\",\\n                         { key: queryKey, query: queryJSON });\\n      return this;\\n    },\\n\\n    /**\\n     * Add a constraint that requires that a key's value not match a value in\\n     * an object returned by a different Parse.Query.\\n     * @param {String} key The key that contains the value that is being\\n     *                     excluded.\\n     * @param {String} queryKey The key in the objects returned by the query to\\n     *                          match against.\\n     * @param {Parse.Query} query The query to run.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    doesNotMatchKeyInQuery: function(key, queryKey, query) {\\n      var queryJSON = query.toJSON();\\n      queryJSON.className = query.className;\\n      this._addCondition(key, \\\"$dontSelect\\\",\\n                         { key: queryKey, query: queryJSON });\\n      return this;\\n    },\\n\\n    /**\\n     * Add constraint that at least one of the passed in queries matches.\\n     * @param {Array} queries\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    _orQuery: function(queries) {\\n      var queryJSON = _.map(queries, function(q) {\\n        return q.toJSON().where;\\n      });\\n\\n      this._where.$or = queryJSON;\\n      return this;\\n    },\\n\\n    /**\\n     * Converts a string into a regex that matches it.\\n     * Surrounding with \\\\Q .. \\\\E does this, we just need to escape \\\\E's in\\n     * the text separately.\\n     */\\n    _quote: function(s) {\\n      return \\\"\\\\\\\\Q\\\" + s.replace(\\\"\\\\\\\\E\\\", \\\"\\\\\\\\E\\\\\\\\\\\\\\\\E\\\\\\\\Q\\\") + \\\"\\\\\\\\E\\\";\\n    },\\n\\n    /**\\n     * Add a constraint for finding string values that contain a provided\\n     * string.  This may be slow for large datasets.\\n     * @param {String} key The key that the string to match is stored in.\\n     * @param {String} substring The substring that the value must contain.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    contains: function(key, value) {\\n      this._addCondition(key, \\\"$regex\\\", this._quote(value));\\n      return this;\\n    },\\n\\n    /**\\n     * Add a constraint for finding string values that start with a provided\\n     * string.  This query will use the backend index, so it will be fast even\\n     * for large datasets.\\n     * @param {String} key The key that the string to match is stored in.\\n     * @param {String} prefix The substring that the value must start with.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    startsWith: function(key, value) {\\n      this._addCondition(key, \\\"$regex\\\", \\\"^\\\" + this._quote(value));\\n      return this;\\n    },\\n\\n    /**\\n     * Add a constraint for finding string values that end with a provided\\n     * string.  This will be slow for large datasets.\\n     * @param {String} key The key that the string to match is stored in.\\n     * @param {String} suffix The substring that the value must end with.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    endsWith: function(key, value) {\\n      this._addCondition(key, \\\"$regex\\\", this._quote(value) + \\\"$\\\");\\n      return this;\\n    },\\n\\n    /**\\n     * Sorts the results in ascending order by the given key.\\n     * \\n     * @param {(String|String[]|...String} key The key to order by, which is a \\n     * string of comma separated values, or an Array of keys, or multiple keys.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    ascending: function() {\\n      this._order = [];\\n      return this.addAscending.apply(this, arguments);\\n    },\\n\\n    /**\\n     * Sorts the results in ascending order by the given key, \\n     * but can also add secondary sort descriptors without overwriting _order.\\n     * \\n     * @param {(String|String[]|...String} key The key to order by, which is a\\n     * string of comma separated values, or an Array of keys, or multiple keys.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    addAscending: function(key) {\\n      var self = this; \\n      if (!this._order) {\\n        this._order = [];\\n      }\\n      Parse._arrayEach(arguments, function(key) {\\n        if (Array.isArray(key)) {\\n          key = key.join();\\n        }\\n        self._order = self._order.concat(key.replace(/\\\\s/g, \\\"\\\").split(\\\",\\\"));\\n      });\\n      return this;\\n    },\\n\\n    /**\\n     * Sorts the results in descending order by the given key.\\n     * \\n     * @param {(String|String[]|...String} key The key to order by, which is a\\n     * string of comma separated values, or an Array of keys, or multiple keys.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    descending: function(key) {\\n      this._order = [];\\n      return this.addDescending.apply(this, arguments);\\n    },\\n\\n    /**\\n     * Sorts the results in descending order by the given key,\\n     * but can also add secondary sort descriptors without overwriting _order.\\n     * \\n     * @param {(String|String[]|...String} key The key to order by, which is a\\n     * string of comma separated values, or an Array of keys, or multiple keys.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    addDescending: function(key) {\\n      var self = this; \\n      if (!this._order) {\\n        this._order = [];\\n      }\\n      Parse._arrayEach(arguments, function(key) {\\n        if (Array.isArray(key)) {\\n          key = key.join();\\n        }\\n        self._order = self._order.concat(\\n          _.map(key.replace(/\\\\s/g, \\\"\\\").split(\\\",\\\"), \\n            function(k) { return \\\"-\\\" + k; }));\\n      });\\n      return this;\\n    },\\n\\n    /**\\n     * Add a proximity based constraint for finding objects with key point\\n     * values near the point given.\\n     * @param {String} key The key that the Parse.GeoPoint is stored in.\\n     * @param {Parse.GeoPoint} point The reference Parse.GeoPoint that is used.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    near: function(key, point) {\\n      if (!(point instanceof Parse.GeoPoint)) {\\n        // Try to cast it to a GeoPoint, so that near(\\\"loc\\\", [20,30]) works.\\n        point = new Parse.GeoPoint(point);\\n      }\\n      this._addCondition(key, \\\"$nearSphere\\\", point);\\n      return this;\\n    },\\n\\n    /**\\n     * Add a proximity based constraint for finding objects with key point\\n     * values near the point given and within the maximum distance given.\\n     * @param {String} key The key that the Parse.GeoPoint is stored in.\\n     * @param {Parse.GeoPoint} point The reference Parse.GeoPoint that is used.\\n     * @param {Number} maxDistance Maximum distance (in radians) of results to\\n     *   return.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    withinRadians: function(key, point, distance) {\\n      this.near(key, point);\\n      this._addCondition(key, \\\"$maxDistance\\\", distance);\\n      return this;\\n    },\\n\\n    /**\\n     * Add a proximity based constraint for finding objects with key point\\n     * values near the point given and within the maximum distance given.\\n     * Radius of earth used is 3958.8 miles.\\n     * @param {String} key The key that the Parse.GeoPoint is stored in.\\n     * @param {Parse.GeoPoint} point The reference Parse.GeoPoint that is used.\\n     * @param {Number} maxDistance Maximum distance (in miles) of results to\\n     *     return.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    withinMiles: function(key, point, distance) {\\n      return this.withinRadians(key, point, distance / 3958.8);\\n    },\\n\\n    /**\\n     * Add a proximity based constraint for finding objects with key point\\n     * values near the point given and within the maximum distance given.\\n     * Radius of earth used is 6371.0 kilometers.\\n     * @param {String} key The key that the Parse.GeoPoint is stored in.\\n     * @param {Parse.GeoPoint} point The reference Parse.GeoPoint that is used.\\n     * @param {Number} maxDistance Maximum distance (in kilometers) of results\\n     *     to return.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    withinKilometers: function(key, point, distance) {\\n      return this.withinRadians(key, point, distance / 6371.0);\\n    },\\n\\n    /**\\n     * Add a constraint to the query that requires a particular key's\\n     * coordinates be contained within a given rectangular geographic bounding\\n     * box.\\n     * @param {String} key The key to be constrained.\\n     * @param {Parse.GeoPoint} southwest\\n     *     The lower-left inclusive corner of the box.\\n     * @param {Parse.GeoPoint} northeast\\n     *     The upper-right inclusive corner of the box.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    withinGeoBox: function(key, southwest, northeast) {\\n      if (!(southwest instanceof Parse.GeoPoint)) {\\n        southwest = new Parse.GeoPoint(southwest);\\n      }\\n      if (!(northeast instanceof Parse.GeoPoint)) {\\n        northeast = new Parse.GeoPoint(northeast);\\n      }\\n      this._addCondition(key, '$within', { '$box': [southwest, northeast] });\\n      return this;\\n    },\\n\\n    /**\\n     * Include nested Parse.Objects for the provided key.  You can use dot\\n     * notation to specify which fields in the included object are also fetched.\\n     * @param {String} key The name of the key to include.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    include: function() {\\n      var self = this;\\n      Parse._arrayEach(arguments, function(key) {\\n        if (_.isArray(key)) {\\n          self._include = self._include.concat(key);\\n        } else {\\n          self._include.push(key);\\n        }\\n      });\\n      return this;\\n    },\\n\\n    /**\\n     * Restrict the fields of the returned Parse.Objects to include only the\\n     * provided keys.  If this is called multiple times, then all of the keys\\n     * specified in each of the calls will be included.\\n     * @param {Array} keys The names of the keys to include.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    select: function() {\\n      var self = this;\\n      this._select = this._select || [];\\n      Parse._arrayEach(arguments, function(key) {\\n        if (_.isArray(key)) {\\n          self._select = self._select.concat(key);\\n        } else {\\n          self._select.push(key);\\n        }\\n      });\\n      return this;\\n    },\\n\\n    /**\\n     * Iterates over each result of a query, calling a callback for each one. If\\n     * the callback returns a promise, the iteration will not continue until\\n     * that promise has been fulfilled. If the callback returns a rejected\\n     * promise, then iteration will stop with that error. The items are\\n     * processed in an unspecified order. The query may not have any sort order,\\n     * and may not use limit or skip.\\n     * @param {Function} callback Callback that will be called with each result\\n     *     of the query.\\n     * @param {Object} options An optional Backbone-like options object with\\n     *     success and error callbacks that will be invoked once the iteration\\n     *     has finished.\\n     * @return {Parse.Promise} A promise that will be fulfilled once the\\n     *     iteration has completed.\\n     */\\n    each: function(callback, options) {\\n      options = options || {};\\n\\n      if (this._order || this._skip || (this._limit >= 0)) {\\n        var error =\\n          \\\"Cannot iterate on a query with sort, skip, or limit.\\\";\\n        return Parse.Promise.error(error)._thenRunCallbacks(options);\\n      }\\n\\n      var promise = new Parse.Promise();\\n\\n      var query = new Parse.Query(this.objectClass);\\n      // We can override the batch size from the options.\\n      // This is undocumented, but useful for testing.\\n      query._limit = options.batchSize || 100;\\n      query._where = _.clone(this._where);\\n      query._include = _.clone(this._include);\\n      if (this._select) {\\n        query._select = _.clone(this._select);\\n      }\\n\\n      query.ascending('objectId');\\n\\n      var findOptions = {};\\n      if (_.has(options, \\\"useMasterKey\\\")) {\\n        findOptions.useMasterKey = options.useMasterKey;\\n      }\\n      if (_.has(options, 'sessionToken')) {\\n        findOptions.sessionToken = options.sessionToken;\\n      }\\n\\n      var finished = false;\\n      return Parse.Promise._continueWhile(function() {\\n        return !finished;\\n\\n      }, function() {\\n        return query.find(findOptions).then(function(results) {\\n          var callbacksDone = Parse.Promise.as();\\n          Parse._.each(results, function(result) {\\n            callbacksDone = callbacksDone.then(function() {\\n              return callback(result);\\n            });\\n          });\\n\\n          return callbacksDone.then(function() {\\n            if (results.length >= query._limit) {\\n              query.greaterThan(\\\"objectId\\\", results[results.length - 1].id);\\n            } else {\\n              finished = true;\\n            }\\n          });\\n        });\\n      })._thenRunCallbacks(options);\\n    }\\n  };\\n\\n}(this));\\n\\n/*global FB: false , console: false*/\\n(function(root) {\\n  root.Parse = root.Parse || {};\\n  var Parse = root.Parse;\\n  var _ = Parse._;\\n\\n  var PUBLIC_KEY = \\\"*\\\";\\n\\n  var initialized = false;\\n  var requestedPermissions;\\n  var initOptions;\\n  var provider = {\\n    authenticate: function(options) {\\n      var self = this;\\n      FB.login(function(response) {\\n        if (response.authResponse) {\\n          if (options.success) {\\n            options.success(self, {\\n              id: response.authResponse.userID,\\n              access_token: response.authResponse.accessToken,\\n              expiration_date: new Date(response.authResponse.expiresIn * 1000 +\\n                  (new Date()).getTime()).toJSON()\\n            });\\n          }\\n        } else {\\n          if (options.error) {\\n            options.error(self, response);\\n          }\\n        }\\n      }, {\\n        scope: requestedPermissions\\n      });\\n    },\\n    restoreAuthentication: function(authData) {\\n      if (authData) {\\n        var authResponse = {\\n          userID: authData.id,\\n          accessToken: authData.access_token,\\n          expiresIn: (Parse._parseDate(authData.expiration_date).getTime() -\\n              (new Date()).getTime()) / 1000\\n        };\\n        var newOptions = _.clone(initOptions);\\n        newOptions.authResponse = authResponse;\\n\\n        // Suppress checks for login status from the browser.\\n        newOptions.status = false;\\n\\n        // If the user doesn't match the one known by the FB SDK, log out.\\n        // Most of the time, the users will match -- it's only in cases where\\n        // the FB SDK knows of a different user than the one being restored\\n        // from a Parse User that logged in with username/password.\\n        var existingResponse = FB.getAuthResponse();\\n        if (existingResponse &&\\n            existingResponse.userID !== authResponse.userID) {\\n          FB.logout();\\n        }\\n\\n        FB.init(newOptions);\\n      }\\n      return true;\\n    },\\n    getAuthType: function() {\\n      return \\\"facebook\\\";\\n    },\\n    deauthenticate: function() {\\n      this.restoreAuthentication(null);\\n    }\\n  };\\n\\n  /**\\n   * Provides a set of utilities for using Parse with Facebook.\\n   * @namespace\\n   * Provides a set of utilities for using Parse with Facebook.\\n   */\\n  Parse.FacebookUtils = {\\n    /**\\n     * Initializes Parse Facebook integration.  Call this function after you\\n     * have loaded the Facebook Javascript SDK with the same parameters\\n     * as you would pass to<code>\\n     * <a href=\\n     * \\\"https://developers.facebook.com/docs/reference/javascript/FB.init/\\\">\\n     * FB.init()</a></code>.  Parse.FacebookUtils will invoke FB.init() for you\\n     * with these arguments.\\n     *\\n     * @param {Object} options Facebook options argument as described here:\\n     *   <a href=\\n     *   \\\"https://developers.facebook.com/docs/reference/javascript/FB.init/\\\">\\n     *   FB.init()</a>. The status flag will be coerced to 'false' because it\\n     *   interferes with Parse Facebook integration. Call FB.getLoginStatus()\\n     *   explicitly if this behavior is required by your application.\\n     */\\n    init: function(options) {\\n      if (typeof(FB) === 'undefined') {\\n        throw \\\"The Facebook JavaScript SDK must be loaded before calling init.\\\";\\n      } \\n      initOptions = _.clone(options) || {};\\n      if (initOptions.status && typeof(console) !== \\\"undefined\\\") {\\n        var warn = console.warn || console.log || function() {};\\n        warn.call(console, \\\"The 'status' flag passed into\\\" +\\n          \\\" FB.init, when set to true, can interfere with Parse Facebook\\\" +\\n          \\\" integration, so it has been suppressed. Please call\\\" +\\n          \\\" FB.getLoginStatus() explicitly if you require this behavior.\\\");\\n      }\\n      initOptions.status = false;\\n      FB.init(initOptions);\\n      Parse.User._registerAuthenticationProvider(provider);\\n      initialized = true;\\n    },\\n\\n    /**\\n     * Gets whether the user has their account linked to Facebook.\\n     * \\n     * @param {Parse.User} user User to check for a facebook link.\\n     *     The user must be logged in on this device.\\n     * @return {Boolean} <code>true</code> if the user has their account\\n     *     linked to Facebook.\\n     */\\n    isLinked: function(user) {\\n      return user._isLinked(\\\"facebook\\\");\\n    },\\n\\n    /**\\n     * Logs in a user using Facebook. This method delegates to the Facebook\\n     * SDK to authenticate the user, and then automatically logs in (or\\n     * creates, in the case where it is a new user) a Parse.User.\\n     * \\n     * @param {String, Object} permissions The permissions required for Facebook\\n     *    log in.  This is a comma-separated string of permissions.\\n     *    Alternatively, supply a Facebook authData object as described in our\\n     *    REST API docs if you want to handle getting facebook auth tokens\\n     *    yourself.\\n     * @param {Object} options Standard options object with success and error\\n     *    callbacks.\\n     */\\n    logIn: function(permissions, options) {\\n      if (!permissions || _.isString(permissions)) {\\n        if (!initialized) {\\n          throw \\\"You must initialize FacebookUtils before calling logIn.\\\";\\n        }\\n        requestedPermissions = permissions;\\n        return Parse.User._logInWith(\\\"facebook\\\", options);\\n      } else {\\n        var newOptions = _.clone(options) || {};\\n        newOptions.authData = permissions;\\n        return Parse.User._logInWith(\\\"facebook\\\", newOptions);\\n      }\\n    },\\n\\n    /**\\n     * Links Facebook to an existing PFUser. This method delegates to the\\n     * Facebook SDK to authenticate the user, and then automatically links\\n     * the account to the Parse.User.\\n     *\\n     * @param {Parse.User} user User to link to Facebook. This must be the\\n     *     current user.\\n     * @param {String, Object} permissions The permissions required for Facebook\\n     *    log in.  This is a comma-separated string of permissions. \\n     *    Alternatively, supply a Facebook authData object as described in our\\n     *    REST API docs if you want to handle getting facebook auth tokens\\n     *    yourself.\\n     * @param {Object} options Standard options object with success and error\\n     *    callbacks.\\n     */\\n    link: function(user, permissions, options) {\\n      if (!permissions || _.isString(permissions)) {\\n        if (!initialized) {\\n          throw \\\"You must initialize FacebookUtils before calling link.\\\";\\n        }\\n        requestedPermissions = permissions;\\n        return user._linkWith(\\\"facebook\\\", options);\\n      } else {\\n        var newOptions = _.clone(options) || {};\\n        newOptions.authData = permissions;\\n        return user._linkWith(\\\"facebook\\\", newOptions);\\n      }\\n    },\\n\\n    /**\\n     * Unlinks the Parse.User from a Facebook account. \\n     * \\n     * @param {Parse.User} user User to unlink from Facebook. This must be the\\n     *     current user.\\n     * @param {Object} options Standard options object with success and error\\n     *    callbacks.\\n     */\\n    unlink: function(user, options) {\\n      if (!initialized) {\\n        throw \\\"You must initialize FacebookUtils before calling unlink.\\\";\\n      }\\n      return user._unlinkFrom(\\\"facebook\\\", options);\\n    }\\n  };\\n  \\n}(this));\\n\\n/*global _: false, document: false, window: false, navigator: false */\\n(function(root) {\\n  root.Parse = root.Parse || {};\\n  var Parse = root.Parse;\\n  var _ = Parse._;\\n\\n  /**\\n   * History serves as a global router (per frame) to handle hashchange\\n   * events or pushState, match the appropriate route, and trigger\\n   * callbacks. You shouldn't ever have to create one of these yourself\\n   * — you should use the reference to <code>Parse.history</code>\\n   * that will be created for you automatically if you make use of \\n   * Routers with routes.\\n   * @class\\n   *   \\n   * <p>A fork of Backbone.History, provided for your convenience.  If you \\n   * use this class, you must also include jQuery, or another library \\n   * that provides a jQuery-compatible $ function.  For more information,\\n   * see the <a href=\\\"http://documentcloud.github.com/backbone/#History\\\">\\n   * Backbone documentation</a>.</p>\\n   * <p><strong><em>Available in the client SDK only.</em></strong></p>\\n   */\\n  Parse.History = function() {\\n    this.handlers = [];\\n    _.bindAll(this, 'checkUrl');\\n  };\\n\\n  // Cached regex for cleaning leading hashes and slashes .\\n  var routeStripper = /^[#\\\\/]/;\\n\\n  // Cached regex for detecting MSIE.\\n  var isExplorer = /msie [\\\\w.]+/;\\n\\n  // Has the history handling already been started?\\n  Parse.History.started = false;\\n\\n  // Set up all inheritable **Parse.History** properties and methods.\\n  _.extend(Parse.History.prototype, Parse.Events,\\n           /** @lends Parse.History.prototype */ {\\n\\n    // The default interval to poll for hash changes, if necessary, is\\n    // twenty times a second.\\n    interval: 50,\\n\\n    // Gets the true hash value. Cannot use location.hash directly due to bug\\n    // in Firefox where location.hash will always be decoded.\\n    getHash: function(windowOverride) {\\n      var loc = windowOverride ? windowOverride.location : window.location;\\n      var match = loc.href.match(/#(.*)$/);\\n      return match ? match[1] : '';\\n    },\\n\\n    // Get the cross-browser normalized URL fragment, either from the URL,\\n    // the hash, or the override.\\n    getFragment: function(fragment, forcePushState) {\\n      if (Parse._isNullOrUndefined(fragment)) {\\n        if (this._hasPushState || forcePushState) {\\n          fragment = window.location.pathname;\\n          var search = window.location.search;\\n          if (search) {\\n            fragment += search;\\n          }\\n        } else {\\n          fragment = this.getHash();\\n        }\\n      }\\n      if (!fragment.indexOf(this.options.root)) {\\n        fragment = fragment.substr(this.options.root.length);\\n      }\\n      return fragment.replace(routeStripper, '');\\n    },\\n\\n    /**\\n     * Start the hash change handling, returning `true` if the current\\n     * URL matches an existing route, and `false` otherwise.\\n     */\\n    start: function(options) {\\n      if (Parse.History.started) {\\n        throw new Error(\\\"Parse.history has already been started\\\");\\n      }\\n      Parse.History.started = true;\\n\\n      // Figure out the initial configuration. Do we need an iframe?\\n      // Is pushState desired ... is it available?\\n      this.options = _.extend({}, {root: '/'}, this.options, options);\\n      this._wantsHashChange = this.options.hashChange !== false;\\n      this._wantsPushState = !!this.options.pushState;\\n      this._hasPushState = !!(this.options.pushState && \\n                              window.history &&\\n                              window.history.pushState);\\n      var fragment = this.getFragment();\\n      var docMode = document.documentMode;\\n      var oldIE = (isExplorer.exec(navigator.userAgent.toLowerCase()) &&\\n                   (!docMode || docMode <= 7));\\n\\n      if (oldIE) {\\n        this.iframe = Parse.$('<iframe src=\\\"javascript:0\\\" tabindex=\\\"-1\\\" />')\\n                      .hide().appendTo('body')[0].contentWindow;\\n        this.navigate(fragment);\\n      }\\n\\n      // Depending on whether we're using pushState or hashes, and whether\\n      // 'onhashchange' is supported, determine how we check the URL state.\\n      if (this._hasPushState) {\\n        Parse.$(window).bind('popstate', this.checkUrl);\\n      } else if (this._wantsHashChange &&\\n                 ('onhashchange' in window) &&\\n                 !oldIE) {\\n        Parse.$(window).bind('hashchange', this.checkUrl);\\n      } else if (this._wantsHashChange) {\\n        this._checkUrlInterval = window.setInterval(this.checkUrl,\\n                                                    this.interval);\\n      }\\n\\n      // Determine if we need to change the base url, for a pushState link\\n      // opened by a non-pushState browser.\\n      this.fragment = fragment;\\n      var loc = window.location;\\n      var atRoot  = loc.pathname === this.options.root;\\n\\n      // If we've started off with a route from a `pushState`-enabled browser,\\n      // but we're currently in a browser that doesn't support it...\\n      if (this._wantsHashChange && \\n          this._wantsPushState && \\n          !this._hasPushState &&\\n          !atRoot) {\\n        this.fragment = this.getFragment(null, true);\\n        window.location.replace(this.options.root + '#' + this.fragment);\\n        // Return immediately as browser will do redirect to new url\\n        return true;\\n\\n      // Or if we've started out with a hash-based route, but we're currently\\n      // in a browser where it could be `pushState`-based instead...\\n      } else if (this._wantsPushState &&\\n                 this._hasPushState && \\n                 atRoot &&\\n                 loc.hash) {\\n        this.fragment = this.getHash().replace(routeStripper, '');\\n        window.history.replaceState({}, document.title,\\n            loc.protocol + '//' + loc.host + this.options.root + this.fragment);\\n      }\\n\\n      if (!this.options.silent) {\\n        return this.loadUrl();\\n      }\\n    },\\n\\n    // Disable Parse.history, perhaps temporarily. Not useful in a real app,\\n    // but possibly useful for unit testing Routers.\\n    stop: function() {\\n      Parse.$(window).unbind('popstate', this.checkUrl)\\n                     .unbind('hashchange', this.checkUrl);\\n      window.clearInterval(this._checkUrlInterval);\\n      Parse.History.started = false;\\n    },\\n\\n    // Add a route to be tested when the fragment changes. Routes added later\\n    // may override previous routes.\\n    route: function(route, callback) {\\n      this.handlers.unshift({route: route, callback: callback});\\n    },\\n\\n    // Checks the current URL to see if it has changed, and if it has,\\n    // calls `loadUrl`, normalizing across the hidden iframe.\\n    checkUrl: function(e) {\\n      var current = this.getFragment();\\n      if (current === this.fragment && this.iframe) {\\n        current = this.getFragment(this.getHash(this.iframe));\\n      }\\n      if (current === this.fragment) {\\n        return false;\\n      }\\n      if (this.iframe) {\\n        this.navigate(current);\\n      }\\n      if (!this.loadUrl()) {\\n        this.loadUrl(this.getHash());\\n      }\\n    },\\n\\n    // Attempt to load the current URL fragment. If a route succeeds with a\\n    // match, returns `true`. If no defined routes matches the fragment,\\n    // returns `false`.\\n    loadUrl: function(fragmentOverride) {\\n      var fragment = this.fragment = this.getFragment(fragmentOverride);\\n      var matched = _.any(this.handlers, function(handler) {\\n        if (handler.route.test(fragment)) {\\n          handler.callback(fragment);\\n          return true;\\n        }\\n      });\\n      return matched;\\n    },\\n\\n    // Save a fragment into the hash history, or replace the URL state if the\\n    // 'replace' option is passed. You are responsible for properly URL-encoding\\n    // the fragment in advance.\\n    //\\n    // The options object can contain `trigger: true` if you wish to have the\\n    // route callback be fired (not usually desirable), or `replace: true`, if\\n    // you wish to modify the current URL without adding an entry to the\\n    // history.\\n    navigate: function(fragment, options) {\\n      if (!Parse.History.started) {\\n        return false;\\n      }\\n      if (!options || options === true) {\\n        options = {trigger: options};\\n      }\\n      var frag = (fragment || '').replace(routeStripper, '');\\n      if (this.fragment === frag) {\\n        return;\\n      }\\n\\n      // If pushState is available, we use it to set the fragment as a real URL.\\n      if (this._hasPushState) {\\n        if (frag.indexOf(this.options.root) !== 0) {\\n          frag = this.options.root + frag;\\n        }\\n        this.fragment = frag;\\n        var replaceOrPush = options.replace ? 'replaceState' : 'pushState';\\n        window.history[replaceOrPush]({}, document.title, frag);\\n\\n      // If hash changes haven't been explicitly disabled, update the hash\\n      // fragment to store history.\\n      } else if (this._wantsHashChange) {\\n        this.fragment = frag;\\n        this._updateHash(window.location, frag, options.replace);\\n        if (this.iframe &&\\n            (frag !== this.getFragment(this.getHash(this.iframe)))) {\\n          // Opening and closing the iframe tricks IE7 and earlier\\n          // to push a history entry on hash-tag change.\\n          // When replace is true, we don't want this.\\n          if (!options.replace) {\\n            this.iframe.document.open().close();\\n          }\\n          this._updateHash(this.iframe.location, frag, options.replace);\\n        }\\n\\n      // If you've told us that you explicitly don't want fallback hashchange-\\n      // based history, then `navigate` becomes a page refresh.\\n      } else {\\n        window.location.assign(this.options.root + fragment);\\n      }\\n      if (options.trigger) {\\n        this.loadUrl(fragment);\\n      }\\n    },\\n\\n    // Update the hash location, either replacing the current entry, or adding\\n    // a new one to the browser history.\\n    _updateHash: function(location, fragment, replace) {\\n      if (replace) {\\n        var s = location.toString().replace(/(javascript:|#).*$/, '');\\n        location.replace(s + '#' + fragment);\\n      } else {\\n        location.hash = fragment;\\n      }\\n    }\\n  });\\n}(this));\\n\\n/*global _: false*/\\n(function(root) {\\n  root.Parse = root.Parse || {};\\n  var Parse = root.Parse;\\n  var _ = Parse._;\\n\\n  /**\\n   * Routers map faux-URLs to actions, and fire events when routes are\\n   * matched. Creating a new one sets its `routes` hash, if not set statically.\\n   * @class\\n   *\\n   * <p>A fork of Backbone.Router, provided for your convenience.\\n   * For more information, see the\\n   * <a href=\\\"http://documentcloud.github.com/backbone/#Router\\\">Backbone\\n   * documentation</a>.</p>\\n   * <p><strong><em>Available in the client SDK only.</em></strong></p>\\n   */\\n  Parse.Router = function(options) {\\n    options = options || {};\\n    if (options.routes) {\\n      this.routes = options.routes;\\n    }\\n    this._bindRoutes();\\n    this.initialize.apply(this, arguments);\\n  };\\n\\n  // Cached regular expressions for matching named param parts and splatted\\n  // parts of route strings.\\n  var namedParam    = /:\\\\w+/g;\\n  var splatParam    = /\\\\*\\\\w+/g;\\n  var escapeRegExp  = /[\\\\-\\\\[\\\\]{}()+?.,\\\\\\\\\\\\^\\\\$\\\\|#\\\\s]/g;\\n\\n  // Set up all inheritable **Parse.Router** properties and methods.\\n  _.extend(Parse.Router.prototype, Parse.Events,\\n           /** @lends Parse.Router.prototype */ {\\n\\n    /**\\n     * Initialize is an empty function by default. Override it with your own\\n     * initialization logic.\\n     */\\n    initialize: function(){},\\n\\n    /**\\n     * Manually bind a single named route to a callback. For example:\\n     *\\n     * <pre>this.route('search/:query/p:num', 'search', function(query, num) {\\n     *       ...\\n     *     });</pre>\\n     */\\n    route: function(route, name, callback) {\\n      Parse.history = Parse.history || new Parse.History();\\n      if (!_.isRegExp(route)) {\\n        route = this._routeToRegExp(route);\\n      } \\n      if (!callback) {\\n        callback = this[name];\\n      }\\n      Parse.history.route(route, _.bind(function(fragment) {\\n        var args = this._extractParameters(route, fragment);\\n        if (callback) {\\n          callback.apply(this, args);\\n        }\\n        this.trigger.apply(this, ['route:' + name].concat(args));\\n        Parse.history.trigger('route', this, name, args);\\n      }, this));\\n      return this;\\n    },\\n\\n    /**\\n     * Whenever you reach a point in your application that you'd\\n     * like to save as a URL, call navigate in order to update the\\n     * URL. If you wish to also call the route function, set the \\n     * trigger option to true. To update the URL without creating\\n     * an entry in the browser's history, set the replace option\\n     * to true.\\n     */\\n    navigate: function(fragment, options) {\\n      Parse.history.navigate(fragment, options);\\n    },\\n\\n    // Bind all defined routes to `Parse.history`. We have to reverse the\\n    // order of the routes here to support behavior where the most general\\n    // routes can be defined at the bottom of the route map.\\n    _bindRoutes: function() {\\n      if (!this.routes) { \\n        return;\\n      }\\n      var routes = [];\\n      for (var route in this.routes) {\\n        if (this.routes.hasOwnProperty(route)) {\\n          routes.unshift([route, this.routes[route]]);\\n        }\\n      }\\n      for (var i = 0, l = routes.length; i < l; i++) {\\n        this.route(routes[i][0], routes[i][1], this[routes[i][1]]);\\n      }\\n    },\\n\\n    // Convert a route string into a regular expression, suitable for matching\\n    // against the current location hash.\\n    _routeToRegExp: function(route) {\\n      route = route.replace(escapeRegExp, '\\\\\\\\$&')\\n                   .replace(namedParam, '([^\\\\/]+)')\\n                   .replace(splatParam, '(.*?)');\\n      return new RegExp('^' + route + '$');\\n    },\\n\\n    // Given a route, and a URL fragment that it matches, return the array of\\n    // extracted parameters.\\n    _extractParameters: function(route, fragment) {\\n      return route.exec(fragment).slice(1);\\n    }\\n  });\\n\\n  /**\\n   * @function\\n   * @param {Object} instanceProps Instance properties for the router.\\n   * @param {Object} classProps Class properies for the router.\\n   * @return {Class} A new subclass of <code>Parse.Router</code>.\\n   */\\n  Parse.Router.extend = Parse._extend;\\n}(this));\\n(function(root) {\\n  root.Parse = root.Parse || {};\\n  var Parse = root.Parse;\\n  var _ = Parse._;\\n\\n  /**\\n   * @namespace Contains functions for calling and declaring\\n   * <a href=\\\"/docs/cloud_code_guide#functions\\\">cloud functions</a>.\\n   * <p><strong><em>\\n   *   Some functions are only available from Cloud Code.\\n   * </em></strong></p>\\n   */\\n  Parse.Cloud = Parse.Cloud || {};\\n\\n  _.extend(Parse.Cloud, /** @lends Parse.Cloud */ {\\n    /**\\n     * Makes a call to a cloud function.\\n     * @param {String} name The function name.\\n     * @param {Object} data The parameters to send to the cloud function.\\n     * @param {Object} options A Backbone-style options object\\n     * options.success, if set, should be a function to handle a successful\\n     * call to a cloud function.  options.error should be a function that\\n     * handles an error running the cloud function.  Both functions are\\n     * optional.  Both functions take a single argument.\\n     * @return {Parse.Promise} A promise that will be resolved with the result\\n     * of the function.\\n     */\\n    run: function(name, data, options) {\\n      options = options || {};\\n\\n      var request = Parse._request({\\n        route: \\\"functions\\\",\\n        className: name,\\n        method: 'POST',\\n        useMasterKey: options.useMasterKey,\\n        sessionToken: options.sessionToken,\\n        data: Parse._encode(data, null, true)\\n      });\\n\\n      return request.then(function(resp) {\\n        return Parse._decode(null, resp).result;\\n      })._thenRunCallbacks(options);\\n    }\\n  });\\n}(this));\\n\\n(function(root) {\\n  root.Parse = root.Parse || {};\\n  var Parse = root.Parse;\\n\\n  Parse.Installation = Parse.Object.extend(\\\"_Installation\\\");\\n\\n  /**\\n   * Contains functions to deal with Push in Parse\\n   * @name Parse.Push\\n   * @namespace\\n   */\\n  Parse.Push = Parse.Push || {};\\n\\n  /**\\n   * Sends a push notification.\\n   * @param {Object} data -  The data of the push notification.  Valid fields\\n   * are:\\n   *   <ol>\\n   *     <li>channels - An Array of channels to push to.</li>\\n   *     <li>push_time - A Date object for when to send the push.</li>\\n   *     <li>expiration_time -  A Date object for when to expire\\n   *         the push.</li>\\n   *     <li>expiration_interval - The seconds from now to expire the push.</li>\\n   *     <li>where - A Parse.Query over Parse.Installation that is used to match\\n   *         a set of installations to push to.</li>\\n   *     <li>data - The data to send as part of the push</li>\\n   *   <ol>\\n   * @param {Object} options An object that has an optional success function,\\n   * that takes no arguments and will be called on a successful push, and\\n   * an error function that takes a Parse.Error and will be called if the push\\n   * failed.\\n   * @return {Parse.Promise} A promise that is fulfilled when the push request\\n   *     completes.\\n   */\\n  Parse.Push.send = function(data, options) {\\n    options = options || {};\\n\\n    if (data.where) {\\n      data.where = data.where.toJSON().where;\\n    }\\n\\n    if (data.push_time) {\\n      data.push_time = data.push_time.toJSON();\\n    }\\n\\n    if (data.expiration_time) {\\n      data.expiration_time = data.expiration_time.toJSON();\\n    }\\n\\n    if (data.expiration_time && data.expiration_interval) {\\n      throw \\\"Both expiration_time and expiration_interval can't be set\\\";\\n    }\\n\\n    var request = Parse._request({\\n      route: 'push',\\n      method: 'POST',\\n      data: data,\\n      useMasterKey: options.useMasterKey\\n    });\\n    return request._thenRunCallbacks(options);\\n  };\\n}(this));\\n\"\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/script-loader/~/raw-loader!./~/jsx-loader?insertPragma=React.DOM!./~/parse/build/parse-latest.js\n ** module id = 7\n ** module chunks = 0\n **/","/** @jsx React.DOM *//*\n * Foundation Responsive Library\n * http://foundation.zurb.com\n * Copyright 2014, ZURB\n * Free to use under the MIT license.\n * http://www.opensource.org/licenses/mit-license.php\n*/\n\n(function ($, window, document, undefined) {\n  'use strict';\n\n  var header_helpers = function (class_array) {\n    var i = class_array.length;\n    var head = $('head');\n\n    while (i--) {\n      if (head.has('.' + class_array[i]).length === 0) {\n        head.append('<meta class=\"' + class_array[i] + '\" />');\n      }\n    }\n  };\n\n  header_helpers([\n    'foundation-mq-small',\n    'foundation-mq-small-only',\n    'foundation-mq-medium',\n    'foundation-mq-medium-only',\n    'foundation-mq-large',\n    'foundation-mq-large-only',\n    'foundation-mq-xlarge',\n    'foundation-mq-xlarge-only',\n    'foundation-mq-xxlarge',\n    'foundation-data-attribute-namespace']);\n\n  // Enable FastClick if present\n\n  $(function () {\n    if (typeof FastClick !== 'undefined') {\n      // Don't attach to body if undefined\n      if (typeof document.body !== 'undefined') {\n        FastClick.attach(document.body);\n      }\n    }\n  });\n\n  // private Fast Selector wrapper,\n  // returns jQuery object. Only use where\n  // getElementById is not available.\n  var S = function (selector, context) {\n    if (typeof selector === 'string') {\n      if (context) {\n        var cont;\n        if (context.jquery) {\n          cont = context[0];\n          if (!cont) {\n            return context;\n          }\n        } else {\n          cont = context;\n        }\n        return $(cont.querySelectorAll(selector));\n      }\n\n      return $(document.querySelectorAll(selector));\n    }\n\n    return $(selector, context);\n  };\n\n  // Namespace functions.\n\n  var attr_name = function (init) {\n    var arr = [];\n    if (!init) {\n      arr.push('data');\n    }\n    if (this.namespace.length > 0) {\n      arr.push(this.namespace);\n    }\n    arr.push(this.name);\n\n    return arr.join('-');\n  };\n\n  var add_namespace = function (str) {\n    var parts = str.split('-'),\n        i = parts.length,\n        arr = [];\n\n    while (i--) {\n      if (i !== 0) {\n        arr.push(parts[i]);\n      } else {\n        if (this.namespace.length > 0) {\n          arr.push(this.namespace, parts[i]);\n        } else {\n          arr.push(parts[i]);\n        }\n      }\n    }\n\n    return arr.reverse().join('-');\n  };\n\n  // Event binding and data-options updating.\n\n  var bindings = function (method, options) {\n    var self = this,\n        bind = function(){\n          var $this = S(this),\n              should_bind_events = !$this.data(self.attr_name(true) + '-init');\n          $this.data(self.attr_name(true) + '-init', $.extend({}, self.settings, (options || method), self.data_options($this)));\n\n          if (should_bind_events) {\n            self.events(this);\n          }\n        };\n\n    if (S(this.scope).is('[' + this.attr_name() +']')) {\n      bind.call(this.scope);\n    } else {\n      S('[' + this.attr_name() +']', this.scope).each(bind);\n    }\n    // # Patch to fix #5043 to move this *after* the if/else clause in order for Backbone and similar frameworks to have improved control over event binding and data-options updating.\n    if (typeof method === 'string') {\n      return this[method].call(this, options);\n    }\n\n  };\n\n  var single_image_loaded = function (image, callback) {\n    function loaded () {\n      callback(image[0]);\n    }\n\n    function bindLoad () {\n      this.one('load', loaded);\n\n      if (/MSIE (\\d+\\.\\d+);/.test(navigator.userAgent)) {\n        var src = this.attr( 'src' ),\n            param = src.match( /\\?/ ) ? '&' : '?';\n\n        param += 'random=' + (new Date()).getTime();\n        this.attr('src', src + param);\n      }\n    }\n\n    if (!image.attr('src')) {\n      loaded();\n      return;\n    }\n\n    if (image[0].complete || image[0].readyState === 4) {\n      loaded();\n    } else {\n      bindLoad.call(image);\n    }\n  };\n\n  /*! matchMedia() polyfill - Test a CSS media type/query in JS. Authors & copyright (c) 2012: Scott Jehl, Paul Irish, Nicholas Zakas, David Knight. Dual MIT/BSD license */\n\n  window.matchMedia || (window.matchMedia = function() {\n      \"use strict\";\n\n      // For browsers that support matchMedium api such as IE 9 and webkit\n      var styleMedia = (window.styleMedia || window.media);\n\n      // For those that don't support matchMedium\n      if (!styleMedia) {\n          var style       = document.createElement('style'),\n              script      = document.getElementsByTagName('script')[0],\n              info        = null;\n\n          style.type  = 'text/css';\n          style.id    = 'matchmediajs-test';\n\n          script.parentNode.insertBefore(style, script);\n\n          // 'style.currentStyle' is used by IE <= 8 and 'window.getComputedStyle' for all other browsers\n          info = ('getComputedStyle' in window) && window.getComputedStyle(style, null) || style.currentStyle;\n\n          styleMedia = {\n              matchMedium: function(media) {\n                  var text = '@media ' + media + '{ #matchmediajs-test { width: 1px; } }';\n\n                  // 'style.styleSheet' is used by IE <= 8 and 'style.textContent' for all other browsers\n                  if (style.styleSheet) {\n                      style.styleSheet.cssText = text;\n                  } else {\n                      style.textContent = text;\n                  }\n\n                  // Test if media query is true or false\n                  return info.width === '1px';\n              }\n          };\n      }\n\n      return function(media) {\n          return {\n              matches: styleMedia.matchMedium(media || 'all'),\n              media: media || 'all'\n          };\n      };\n  }());\n\n  /*\n   * jquery.requestAnimationFrame\n   * https://github.com/gnarf37/jquery-requestAnimationFrame\n   * Requires jQuery 1.8+\n   *\n   * Copyright (c) 2012 Corey Frang\n   * Licensed under the MIT license.\n   */\n\n  (function(jQuery) {\n\n\n  // requestAnimationFrame polyfill adapted from Erik Möller\n  // fixes from Paul Irish and Tino Zijdel\n  // http://paulirish.com/2011/requestanimationframe-for-smart-animating/\n  // http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating\n\n  var animating,\n      lastTime = 0,\n      vendors = ['webkit', 'moz'],\n      requestAnimationFrame = window.requestAnimationFrame,\n      cancelAnimationFrame = window.cancelAnimationFrame,\n      jqueryFxAvailable = 'undefined' !== typeof jQuery.fx;\n\n  for (; lastTime < vendors.length && !requestAnimationFrame; lastTime++) {\n    requestAnimationFrame = window[ vendors[lastTime] + 'RequestAnimationFrame' ];\n    cancelAnimationFrame = cancelAnimationFrame ||\n      window[ vendors[lastTime] + 'CancelAnimationFrame' ] ||\n      window[ vendors[lastTime] + 'CancelRequestAnimationFrame' ];\n  }\n\n  function raf() {\n    if (animating) {\n      requestAnimationFrame(raf);\n\n      if (jqueryFxAvailable) {\n        jQuery.fx.tick();\n      }\n    }\n  }\n\n  if (requestAnimationFrame) {\n    // use rAF\n    window.requestAnimationFrame = requestAnimationFrame;\n    window.cancelAnimationFrame = cancelAnimationFrame;\n\n    if (jqueryFxAvailable) {\n      jQuery.fx.timer = function (timer) {\n        if (timer() && jQuery.timers.push(timer) && !animating) {\n          animating = true;\n          raf();\n        }\n      };\n\n      jQuery.fx.stop = function () {\n        animating = false;\n      };\n    }\n  } else {\n    // polyfill\n    window.requestAnimationFrame = function (callback) {\n      var currTime = new Date().getTime(),\n        timeToCall = Math.max(0, 16 - (currTime - lastTime)),\n        id = window.setTimeout(function () {\n          callback(currTime + timeToCall);\n        }, timeToCall);\n      lastTime = currTime + timeToCall;\n      return id;\n    };\n\n    window.cancelAnimationFrame = function (id) {\n      clearTimeout(id);\n    };\n\n  }\n\n  }( $ ));\n\n  function removeQuotes (string) {\n    if (typeof string === 'string' || string instanceof String) {\n      string = string.replace(/^['\\\\/\"]+|(;\\s?})+|['\\\\/\"]+$/g, '');\n    }\n\n    return string;\n  }\n\n  window.Foundation = {\n    name : 'Foundation',\n\n    version : '5.5.2',\n\n    media_queries : {\n      'small'       : S('.foundation-mq-small').css('font-family').replace(/^[\\/\\\\'\"]+|(;\\s?})+|[\\/\\\\'\"]+$/g, ''),\n      'small-only'  : S('.foundation-mq-small-only').css('font-family').replace(/^[\\/\\\\'\"]+|(;\\s?})+|[\\/\\\\'\"]+$/g, ''),\n      'medium'      : S('.foundation-mq-medium').css('font-family').replace(/^[\\/\\\\'\"]+|(;\\s?})+|[\\/\\\\'\"]+$/g, ''),\n      'medium-only' : S('.foundation-mq-medium-only').css('font-family').replace(/^[\\/\\\\'\"]+|(;\\s?})+|[\\/\\\\'\"]+$/g, ''),\n      'large'       : S('.foundation-mq-large').css('font-family').replace(/^[\\/\\\\'\"]+|(;\\s?})+|[\\/\\\\'\"]+$/g, ''),\n      'large-only'  : S('.foundation-mq-large-only').css('font-family').replace(/^[\\/\\\\'\"]+|(;\\s?})+|[\\/\\\\'\"]+$/g, ''),\n      'xlarge'      : S('.foundation-mq-xlarge').css('font-family').replace(/^[\\/\\\\'\"]+|(;\\s?})+|[\\/\\\\'\"]+$/g, ''),\n      'xlarge-only' : S('.foundation-mq-xlarge-only').css('font-family').replace(/^[\\/\\\\'\"]+|(;\\s?})+|[\\/\\\\'\"]+$/g, ''),\n      'xxlarge'     : S('.foundation-mq-xxlarge').css('font-family').replace(/^[\\/\\\\'\"]+|(;\\s?})+|[\\/\\\\'\"]+$/g, '')\n    },\n\n    stylesheet : $('<style></style>').appendTo('head')[0].sheet,\n\n    global : {\n      namespace : undefined\n    },\n\n    init : function (scope, libraries, method, options, response) {\n      var args = [scope, method, options, response],\n          responses = [];\n\n      // check RTL\n      this.rtl = /rtl/i.test(S('html').attr('dir'));\n\n      // set foundation global scope\n      this.scope = scope || this.scope;\n\n      this.set_namespace();\n\n      if (libraries && typeof libraries === 'string' && !/reflow/i.test(libraries)) {\n        if (this.libs.hasOwnProperty(libraries)) {\n          responses.push(this.init_lib(libraries, args));\n        }\n      } else {\n        for (var lib in this.libs) {\n          responses.push(this.init_lib(lib, libraries));\n        }\n      }\n\n      S(window).load(function () {\n        S(window)\n          .trigger('resize.fndtn.clearing')\n          .trigger('resize.fndtn.dropdown')\n          .trigger('resize.fndtn.equalizer')\n          .trigger('resize.fndtn.interchange')\n          .trigger('resize.fndtn.joyride')\n          .trigger('resize.fndtn.magellan')\n          .trigger('resize.fndtn.topbar')\n          .trigger('resize.fndtn.slider');\n      });\n\n      return scope;\n    },\n\n    init_lib : function (lib, args) {\n      if (this.libs.hasOwnProperty(lib)) {\n        this.patch(this.libs[lib]);\n\n        if (args && args.hasOwnProperty(lib)) {\n            if (typeof this.libs[lib].settings !== 'undefined') {\n              $.extend(true, this.libs[lib].settings, args[lib]);\n            } else if (typeof this.libs[lib].defaults !== 'undefined') {\n              $.extend(true, this.libs[lib].defaults, args[lib]);\n            }\n          return this.libs[lib].init.apply(this.libs[lib], [this.scope, args[lib]]);\n        }\n\n        args = args instanceof Array ? args : new Array(args);\n        return this.libs[lib].init.apply(this.libs[lib], args);\n      }\n\n      return function () {};\n    },\n\n    patch : function (lib) {\n      lib.scope = this.scope;\n      lib.namespace = this.global.namespace;\n      lib.rtl = this.rtl;\n      lib['data_options'] = this.utils.data_options;\n      lib['attr_name'] = attr_name;\n      lib['add_namespace'] = add_namespace;\n      lib['bindings'] = bindings;\n      lib['S'] = this.utils.S;\n    },\n\n    inherit : function (scope, methods) {\n      var methods_arr = methods.split(' '),\n          i = methods_arr.length;\n\n      while (i--) {\n        if (this.utils.hasOwnProperty(methods_arr[i])) {\n          scope[methods_arr[i]] = this.utils[methods_arr[i]];\n        }\n      }\n    },\n\n    set_namespace : function () {\n\n      // Description:\n      //    Don't bother reading the namespace out of the meta tag\n      //    if the namespace has been set globally in javascript\n      //\n      // Example:\n      //    Foundation.global.namespace = 'my-namespace';\n      // or make it an empty string:\n      //    Foundation.global.namespace = '';\n      //\n      //\n\n      // If the namespace has not been set (is undefined), try to read it out of the meta element.\n      // Otherwise use the globally defined namespace, even if it's empty ('')\n      var namespace = ( this.global.namespace === undefined ) ? $('.foundation-data-attribute-namespace').css('font-family') : this.global.namespace;\n\n      // Finally, if the namsepace is either undefined or false, set it to an empty string.\n      // Otherwise use the namespace value.\n      this.global.namespace = ( namespace === undefined || /false/i.test(namespace) ) ? '' : namespace;\n    },\n\n    libs : {},\n\n    // methods that can be inherited in libraries\n    utils : {\n\n      // Description:\n      //    Fast Selector wrapper returns jQuery object. Only use where getElementById\n      //    is not available.\n      //\n      // Arguments:\n      //    Selector (String): CSS selector describing the element(s) to be\n      //    returned as a jQuery object.\n      //\n      //    Scope (String): CSS selector describing the area to be searched. Default\n      //    is document.\n      //\n      // Returns:\n      //    Element (jQuery Object): jQuery object containing elements matching the\n      //    selector within the scope.\n      S : S,\n\n      // Description:\n      //    Executes a function a max of once every n milliseconds\n      //\n      // Arguments:\n      //    Func (Function): Function to be throttled.\n      //\n      //    Delay (Integer): Function execution threshold in milliseconds.\n      //\n      // Returns:\n      //    Lazy_function (Function): Function with throttling applied.\n      throttle : function (func, delay) {\n        var timer = null;\n\n        return function () {\n          var context = this, args = arguments;\n\n          if (timer == null) {\n            timer = setTimeout(function () {\n              func.apply(context, args);\n              timer = null;\n            }, delay);\n          }\n        };\n      },\n\n      // Description:\n      //    Executes a function when it stops being invoked for n seconds\n      //    Modified version of _.debounce() http://underscorejs.org\n      //\n      // Arguments:\n      //    Func (Function): Function to be debounced.\n      //\n      //    Delay (Integer): Function execution threshold in milliseconds.\n      //\n      //    Immediate (Bool): Whether the function should be called at the beginning\n      //    of the delay instead of the end. Default is false.\n      //\n      // Returns:\n      //    Lazy_function (Function): Function with debouncing applied.\n      debounce : function (func, delay, immediate) {\n        var timeout, result;\n        return function () {\n          var context = this, args = arguments;\n          var later = function () {\n            timeout = null;\n            if (!immediate) {\n              result = func.apply(context, args);\n            }\n          };\n          var callNow = immediate && !timeout;\n          clearTimeout(timeout);\n          timeout = setTimeout(later, delay);\n          if (callNow) {\n            result = func.apply(context, args);\n          }\n          return result;\n        };\n      },\n\n      // Description:\n      //    Parses data-options attribute\n      //\n      // Arguments:\n      //    El (jQuery Object): Element to be parsed.\n      //\n      // Returns:\n      //    Options (Javascript Object): Contents of the element's data-options\n      //    attribute.\n      data_options : function (el, data_attr_name) {\n        data_attr_name = data_attr_name || 'options';\n        var opts = {}, ii, p, opts_arr,\n            data_options = function (el) {\n              var namespace = Foundation.global.namespace;\n\n              if (namespace.length > 0) {\n                return el.data(namespace + '-' + data_attr_name);\n              }\n\n              return el.data(data_attr_name);\n            };\n\n        var cached_options = data_options(el);\n\n        if (typeof cached_options === 'object') {\n          return cached_options;\n        }\n\n        opts_arr = (cached_options || ':').split(';');\n        ii = opts_arr.length;\n\n        function isNumber (o) {\n          return !isNaN (o - 0) && o !== null && o !== '' && o !== false && o !== true;\n        }\n\n        function trim (str) {\n          if (typeof str === 'string') {\n            return $.trim(str);\n          }\n          return str;\n        }\n\n        while (ii--) {\n          p = opts_arr[ii].split(':');\n          p = [p[0], p.slice(1).join(':')];\n\n          if (/true/i.test(p[1])) {\n            p[1] = true;\n          }\n          if (/false/i.test(p[1])) {\n            p[1] = false;\n          }\n          if (isNumber(p[1])) {\n            if (p[1].indexOf('.') === -1) {\n              p[1] = parseInt(p[1], 10);\n            } else {\n              p[1] = parseFloat(p[1]);\n            }\n          }\n\n          if (p.length === 2 && p[0].length > 0) {\n            opts[trim(p[0])] = trim(p[1]);\n          }\n        }\n\n        return opts;\n      },\n\n      // Description:\n      //    Adds JS-recognizable media queries\n      //\n      // Arguments:\n      //    Media (String): Key string for the media query to be stored as in\n      //    Foundation.media_queries\n      //\n      //    Class (String): Class name for the generated <meta> tag\n      register_media : function (media, media_class) {\n        if (Foundation.media_queries[media] === undefined) {\n          $('head').append('<meta class=\"' + media_class + '\"/>');\n          Foundation.media_queries[media] = removeQuotes($('.' + media_class).css('font-family'));\n        }\n      },\n\n      // Description:\n      //    Add custom CSS within a JS-defined media query\n      //\n      // Arguments:\n      //    Rule (String): CSS rule to be appended to the document.\n      //\n      //    Media (String): Optional media query string for the CSS rule to be\n      //    nested under.\n      add_custom_rule : function (rule, media) {\n        if (media === undefined && Foundation.stylesheet) {\n          Foundation.stylesheet.insertRule(rule, Foundation.stylesheet.cssRules.length);\n        } else {\n          var query = Foundation.media_queries[media];\n\n          if (query !== undefined) {\n            Foundation.stylesheet.insertRule('@media ' +\n              Foundation.media_queries[media] + '{ ' + rule + ' }', Foundation.stylesheet.cssRules.length);\n          }\n        }\n      },\n\n      // Description:\n      //    Performs a callback function when an image is fully loaded\n      //\n      // Arguments:\n      //    Image (jQuery Object): Image(s) to check if loaded.\n      //\n      //    Callback (Function): Function to execute when image is fully loaded.\n      image_loaded : function (images, callback) {\n        var self = this,\n            unloaded = images.length;\n\n        function pictures_has_height(images) {\n          var pictures_number = images.length;\n\n          for (var i = pictures_number - 1; i >= 0; i--) {\n            if(images.attr('height') === undefined) {\n              return false;\n            };\n          };\n\n          return true;\n        }\n\n        if (unloaded === 0 || pictures_has_height(images)) {\n          callback(images);\n        }\n\n        images.each(function () {\n          single_image_loaded(self.S(this), function () {\n            unloaded -= 1;\n            if (unloaded === 0) {\n              callback(images);\n            }\n          });\n        });\n      },\n\n      // Description:\n      //    Returns a random, alphanumeric string\n      //\n      // Arguments:\n      //    Length (Integer): Length of string to be generated. Defaults to random\n      //    integer.\n      //\n      // Returns:\n      //    Rand (String): Pseudo-random, alphanumeric string.\n      random_str : function () {\n        if (!this.fidx) {\n          this.fidx = 0;\n        }\n        this.prefix = this.prefix || [(this.name || 'F'), (+new Date).toString(36)].join('-');\n\n        return this.prefix + (this.fidx++).toString(36);\n      },\n\n      // Description:\n      //    Helper for window.matchMedia\n      //\n      // Arguments:\n      //    mq (String): Media query\n      //\n      // Returns:\n      //    (Boolean): Whether the media query passes or not\n      match : function (mq) {\n        return window.matchMedia(mq).matches;\n      },\n\n      // Description:\n      //    Helpers for checking Foundation default media queries with JS\n      //\n      // Returns:\n      //    (Boolean): Whether the media query passes or not\n\n      is_small_up : function () {\n        return this.match(Foundation.media_queries.small);\n      },\n\n      is_medium_up : function () {\n        return this.match(Foundation.media_queries.medium);\n      },\n\n      is_large_up : function () {\n        return this.match(Foundation.media_queries.large);\n      },\n\n      is_xlarge_up : function () {\n        return this.match(Foundation.media_queries.xlarge);\n      },\n\n      is_xxlarge_up : function () {\n        return this.match(Foundation.media_queries.xxlarge);\n      },\n\n      is_small_only : function () {\n        return !this.is_medium_up() && !this.is_large_up() && !this.is_xlarge_up() && !this.is_xxlarge_up();\n      },\n\n      is_medium_only : function () {\n        return this.is_medium_up() && !this.is_large_up() && !this.is_xlarge_up() && !this.is_xxlarge_up();\n      },\n\n      is_large_only : function () {\n        return this.is_medium_up() && this.is_large_up() && !this.is_xlarge_up() && !this.is_xxlarge_up();\n      },\n\n      is_xlarge_only : function () {\n        return this.is_medium_up() && this.is_large_up() && this.is_xlarge_up() && !this.is_xxlarge_up();\n      },\n\n      is_xxlarge_only : function () {\n        return this.is_medium_up() && this.is_large_up() && this.is_xlarge_up() && this.is_xxlarge_up();\n      }\n    }\n  };\n\n  $.fn.foundation = function () {\n    var args = Array.prototype.slice.call(arguments, 0);\n\n    return this.each(function () {\n      Foundation.init.apply(Foundation, [this].concat(args));\n      return this;\n    });\n  };\n\n}(jQuery, window, window.document));\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./bower_components/foundation/js/foundation/foundation.js\n ** module id = 8\n ** module chunks = 0\n **/","/** @jsx React.DOM */;(function ($, window, document, undefined) {\n  'use strict';\n\n  Foundation.libs.reveal = {\n    name : 'reveal',\n\n    version : '5.5.2',\n\n    locked : false,\n\n    settings : {\n      animation : 'fadeAndPop',\n      animation_speed : 250,\n      close_on_background_click : true,\n      close_on_esc : true,\n      dismiss_modal_class : 'close-reveal-modal',\n      multiple_opened : false,\n      bg_class : 'reveal-modal-bg',\n      root_element : 'body',\n      open : function(){},\n      opened : function(){},\n      close : function(){},\n      closed : function(){},\n      on_ajax_error: $.noop,\n      bg : $('.reveal-modal-bg'),\n      css : {\n        open : {\n          'opacity' : 0,\n          'visibility' : 'visible',\n          'display' : 'block'\n        },\n        close : {\n          'opacity' : 1,\n          'visibility' : 'hidden',\n          'display' : 'none'\n        }\n      }\n    },\n\n    init : function (scope, method, options) {\n      $.extend(true, this.settings, method, options);\n      this.bindings(method, options);\n    },\n\n    events : function (scope) {\n      var self = this,\n          S = self.S;\n\n      S(this.scope)\n        .off('.reveal')\n        .on('click.fndtn.reveal', '[' + this.add_namespace('data-reveal-id') + ']:not([disabled])', function (e) {\n          e.preventDefault();\n\n          if (!self.locked) {\n            var element = S(this),\n                ajax = element.data(self.data_attr('reveal-ajax')),\n                replaceContentSel = element.data(self.data_attr('reveal-replace-content'));\n\n            self.locked = true;\n\n            if (typeof ajax === 'undefined') {\n              self.open.call(self, element);\n            } else {\n              var url = ajax === true ? element.attr('href') : ajax;\n              self.open.call(self, element, {url : url}, { replaceContentSel : replaceContentSel });\n            }\n          }\n        });\n\n      S(document)\n        .on('click.fndtn.reveal', this.close_targets(), function (e) {\n          e.preventDefault();\n          if (!self.locked) {\n            var settings = S('[' + self.attr_name() + '].open').data(self.attr_name(true) + '-init') || self.settings,\n                bg_clicked = S(e.target)[0] === S('.' + settings.bg_class)[0];\n\n            if (bg_clicked) {\n              if (settings.close_on_background_click) {\n                e.stopPropagation();\n              } else {\n                return;\n              }\n            }\n\n            self.locked = true;\n            self.close.call(self, bg_clicked ? S('[' + self.attr_name() + '].open:not(.toback)') : S(this).closest('[' + self.attr_name() + ']'));\n          }\n        });\n\n      if (S('[' + self.attr_name() + ']', this.scope).length > 0) {\n        S(this.scope)\n          // .off('.reveal')\n          .on('open.fndtn.reveal', this.settings.open)\n          .on('opened.fndtn.reveal', this.settings.opened)\n          .on('opened.fndtn.reveal', this.open_video)\n          .on('close.fndtn.reveal', this.settings.close)\n          .on('closed.fndtn.reveal', this.settings.closed)\n          .on('closed.fndtn.reveal', this.close_video);\n      } else {\n        S(this.scope)\n          // .off('.reveal')\n          .on('open.fndtn.reveal', '[' + self.attr_name() + ']', this.settings.open)\n          .on('opened.fndtn.reveal', '[' + self.attr_name() + ']', this.settings.opened)\n          .on('opened.fndtn.reveal', '[' + self.attr_name() + ']', this.open_video)\n          .on('close.fndtn.reveal', '[' + self.attr_name() + ']', this.settings.close)\n          .on('closed.fndtn.reveal', '[' + self.attr_name() + ']', this.settings.closed)\n          .on('closed.fndtn.reveal', '[' + self.attr_name() + ']', this.close_video);\n      }\n\n      return true;\n    },\n\n    // PATCH #3: turning on key up capture only when a reveal window is open\n    key_up_on : function (scope) {\n      var self = this;\n\n      // PATCH #1: fixing multiple keyup event trigger from single key press\n      self.S('body').off('keyup.fndtn.reveal').on('keyup.fndtn.reveal', function ( event ) {\n        var open_modal = self.S('[' + self.attr_name() + '].open'),\n            settings = open_modal.data(self.attr_name(true) + '-init') || self.settings ;\n        // PATCH #2: making sure that the close event can be called only while unlocked,\n        //           so that multiple keyup.fndtn.reveal events don't prevent clean closing of the reveal window.\n        if ( settings && event.which === 27  && settings.close_on_esc && !self.locked) { // 27 is the keycode for the Escape key\n          self.close.call(self, open_modal);\n        }\n      });\n\n      return true;\n    },\n\n    // PATCH #3: turning on key up capture only when a reveal window is open\n    key_up_off : function (scope) {\n      this.S('body').off('keyup.fndtn.reveal');\n      return true;\n    },\n\n    open : function (target, ajax_settings) {\n      var self = this,\n          modal;\n\n      if (target) {\n        if (typeof target.selector !== 'undefined') {\n          // Find the named node; only use the first one found, since the rest of the code assumes there's only one node\n          modal = self.S('#' + target.data(self.data_attr('reveal-id'))).first();\n        } else {\n          modal = self.S(this.scope);\n\n          ajax_settings = target;\n        }\n      } else {\n        modal = self.S(this.scope);\n      }\n\n      var settings = modal.data(self.attr_name(true) + '-init');\n      settings = settings || this.settings;\n\n\n      if (modal.hasClass('open') && target.attr('data-reveal-id') == modal.attr('id')) {\n        return self.close(modal);\n      }\n\n      if (!modal.hasClass('open')) {\n        var open_modal = self.S('[' + self.attr_name() + '].open');\n\n        if (typeof modal.data('css-top') === 'undefined') {\n          modal.data('css-top', parseInt(modal.css('top'), 10))\n            .data('offset', this.cache_offset(modal));\n        }\n\n        modal.attr('tabindex','0').attr('aria-hidden','false');\n\n        this.key_up_on(modal);    // PATCH #3: turning on key up capture only when a reveal window is open\n\n        // Prevent namespace event from triggering twice\n        modal.on('open.fndtn.reveal', function(e) {\n          if (e.namespace !== 'fndtn.reveal') return;\n        });\n\n        modal.on('open.fndtn.reveal').trigger('open.fndtn.reveal');\n\n        if (open_modal.length < 1) {\n          this.toggle_bg(modal, true);\n        }\n\n        if (typeof ajax_settings === 'string') {\n          ajax_settings = {\n            url : ajax_settings\n          };\n        }\n\n        if (typeof ajax_settings === 'undefined' || !ajax_settings.url) {\n          if (open_modal.length > 0) {\n            if (settings.multiple_opened) {\n              self.to_back(open_modal);\n            } else {\n              self.hide(open_modal, settings.css.close);\n            }\n          }\n\n          this.show(modal, settings.css.open);\n        } else {\n          var old_success = typeof ajax_settings.success !== 'undefined' ? ajax_settings.success : null;\n          $.extend(ajax_settings, {\n            success : function (data, textStatus, jqXHR) {\n              if ( $.isFunction(old_success) ) {\n                var result = old_success(data, textStatus, jqXHR);\n                if (typeof result == 'string') {\n                  data = result;\n                }\n              }\n\n              if (typeof options !== 'undefined' && typeof options.replaceContentSel !== 'undefined') {\n                modal.find(options.replaceContentSel).html(data);\n              } else {\n                modal.html(data);\n              }\n\n              self.S(modal).foundation('section', 'reflow');\n              self.S(modal).children().foundation();\n\n              if (open_modal.length > 0) {\n                if (settings.multiple_opened) {\n                  self.to_back(open_modal);\n                } else {\n                  self.hide(open_modal, settings.css.close);\n                }\n              }\n              self.show(modal, settings.css.open);\n            }\n          });\n\n          // check for if user initalized with error callback\n          if (settings.on_ajax_error !== $.noop) {\n            $.extend(ajax_settings, {\n              error : settings.on_ajax_error\n            });\n          }\n\n          $.ajax(ajax_settings);\n        }\n      }\n      self.S(window).trigger('resize');\n    },\n\n    close : function (modal) {\n      var modal = modal && modal.length ? modal : this.S(this.scope),\n          open_modals = this.S('[' + this.attr_name() + '].open'),\n          settings = modal.data(this.attr_name(true) + '-init') || this.settings,\n          self = this;\n\n      if (open_modals.length > 0) {\n\n        modal.removeAttr('tabindex','0').attr('aria-hidden','true');\n\n        this.locked = true;\n        this.key_up_off(modal);   // PATCH #3: turning on key up capture only when a reveal window is open\n\n        modal.trigger('close.fndtn.reveal');\n\n        if ((settings.multiple_opened && open_modals.length === 1) || !settings.multiple_opened || modal.length > 1) {\n          self.toggle_bg(modal, false);\n          self.to_front(modal);\n        }\n\n        if (settings.multiple_opened) {\n          self.hide(modal, settings.css.close, settings);\n          self.to_front($($.makeArray(open_modals).reverse()[1]));\n        } else {\n          self.hide(open_modals, settings.css.close, settings);\n        }\n      }\n    },\n\n    close_targets : function () {\n      var base = '.' + this.settings.dismiss_modal_class;\n\n      if (this.settings.close_on_background_click) {\n        return base + ', .' + this.settings.bg_class;\n      }\n\n      return base;\n    },\n\n    toggle_bg : function (modal, state) {\n      if (this.S('.' + this.settings.bg_class).length === 0) {\n        this.settings.bg = $('<div />', {'class': this.settings.bg_class})\n          .appendTo('body').hide();\n      }\n\n      var visible = this.settings.bg.filter(':visible').length > 0;\n      if ( state != visible ) {\n        if ( state == undefined ? visible : !state ) {\n          this.hide(this.settings.bg);\n        } else {\n          this.show(this.settings.bg);\n        }\n      }\n    },\n\n    show : function (el, css) {\n      // is modal\n      if (css) {\n        var settings = el.data(this.attr_name(true) + '-init') || this.settings,\n            root_element = settings.root_element,\n            context = this;\n\n        if (el.parent(root_element).length === 0) {\n          var placeholder = el.wrap('<div style=\"display: none;\" />').parent();\n\n          el.on('closed.fndtn.reveal.wrapped', function () {\n            el.detach().appendTo(placeholder);\n            el.unwrap().unbind('closed.fndtn.reveal.wrapped');\n          });\n\n          el.detach().appendTo(root_element);\n        }\n\n        var animData = getAnimationData(settings.animation);\n        if (!animData.animate) {\n          this.locked = false;\n        }\n        if (animData.pop) {\n          css.top = $(window).scrollTop() - el.data('offset') + 'px';\n          var end_css = {\n            top: $(window).scrollTop() + el.data('css-top') + 'px',\n            opacity: 1\n          };\n\n          return setTimeout(function () {\n            return el\n              .css(css)\n              .animate(end_css, settings.animation_speed, 'linear', function () {\n                context.locked = false;\n                el.trigger('opened.fndtn.reveal');\n              })\n              .addClass('open');\n          }, settings.animation_speed / 2);\n        }\n\n        if (animData.fade) {\n          css.top = $(window).scrollTop() + el.data('css-top') + 'px';\n          var end_css = {opacity: 1};\n\n          return setTimeout(function () {\n            return el\n              .css(css)\n              .animate(end_css, settings.animation_speed, 'linear', function () {\n                context.locked = false;\n                el.trigger('opened.fndtn.reveal');\n              })\n              .addClass('open');\n          }, settings.animation_speed / 2);\n        }\n\n        return el.css(css).show().css({opacity : 1}).addClass('open').trigger('opened.fndtn.reveal');\n      }\n\n      var settings = this.settings;\n\n      // should we animate the background?\n      if (getAnimationData(settings.animation).fade) {\n        return el.fadeIn(settings.animation_speed / 2);\n      }\n\n      this.locked = false;\n\n      return el.show();\n    },\n\n    to_back : function(el) {\n      el.addClass('toback');\n    },\n\n    to_front : function(el) {\n      el.removeClass('toback');\n    },\n\n    hide : function (el, css) {\n      // is modal\n      if (css) {\n        var settings = el.data(this.attr_name(true) + '-init'),\n            context = this;\n        settings = settings || this.settings;\n\n        var animData = getAnimationData(settings.animation);\n        if (!animData.animate) {\n          this.locked = false;\n        }\n        if (animData.pop) {\n          var end_css = {\n            top: - $(window).scrollTop() - el.data('offset') + 'px',\n            opacity: 0\n          };\n\n          return setTimeout(function () {\n            return el\n              .animate(end_css, settings.animation_speed, 'linear', function () {\n                context.locked = false;\n                el.css(css).trigger('closed.fndtn.reveal');\n              })\n              .removeClass('open');\n          }, settings.animation_speed / 2);\n        }\n\n        if (animData.fade) {\n          var end_css = {opacity : 0};\n\n          return setTimeout(function () {\n            return el\n              .animate(end_css, settings.animation_speed, 'linear', function () {\n                context.locked = false;\n                el.css(css).trigger('closed.fndtn.reveal');\n              })\n              .removeClass('open');\n          }, settings.animation_speed / 2);\n        }\n\n        return el.hide().css(css).removeClass('open').trigger('closed.fndtn.reveal');\n      }\n\n      var settings = this.settings;\n\n      // should we animate the background?\n      if (getAnimationData(settings.animation).fade) {\n        return el.fadeOut(settings.animation_speed / 2);\n      }\n\n      return el.hide();\n    },\n\n    close_video : function (e) {\n      var video = $('.flex-video', e.target),\n          iframe = $('iframe', video);\n\n      if (iframe.length > 0) {\n        iframe.attr('data-src', iframe[0].src);\n        iframe.attr('src', iframe.attr('src'));\n        video.hide();\n      }\n    },\n\n    open_video : function (e) {\n      var video = $('.flex-video', e.target),\n          iframe = video.find('iframe');\n\n      if (iframe.length > 0) {\n        var data_src = iframe.attr('data-src');\n        if (typeof data_src === 'string') {\n          iframe[0].src = iframe.attr('data-src');\n        } else {\n          var src = iframe[0].src;\n          iframe[0].src = undefined;\n          iframe[0].src = src;\n        }\n        video.show();\n      }\n    },\n\n    data_attr : function (str) {\n      if (this.namespace.length > 0) {\n        return this.namespace + '-' + str;\n      }\n\n      return str;\n    },\n\n    cache_offset : function (modal) {\n      var offset = modal.show().height() + parseInt(modal.css('top'), 10) + modal.scrollY;\n\n      modal.hide();\n\n      return offset;\n    },\n\n    off : function () {\n      $(this.scope).off('.fndtn.reveal');\n    },\n\n    reflow : function () {}\n  };\n\n  /*\n   * getAnimationData('popAndFade') // {animate: true,  pop: true,  fade: true}\n   * getAnimationData('fade')       // {animate: true,  pop: false, fade: true}\n   * getAnimationData('pop')        // {animate: true,  pop: true,  fade: false}\n   * getAnimationData('foo')        // {animate: false, pop: false, fade: false}\n   * getAnimationData(null)         // {animate: false, pop: false, fade: false}\n   */\n  function getAnimationData(str) {\n    var fade = /fade/i.test(str);\n    var pop = /pop/i.test(str);\n    return {\n      animate : fade || pop,\n      pop : pop,\n      fade : fade\n    };\n  }\n}(jQuery, window, window.document));\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./bower_components/foundation/js/foundation/foundation.reveal.js\n ** module id = 9\n ** module chunks = 0\n **/"],"sourceRoot":"","file":"app-bundle.js"}
Binary file ../workspace/.sass-cache/6627585c2aaa8cd141fd57f5d591f655962fa360/_global.scssc matches
../workspace/README.md:* javascript/jquery
Binary file ../workspace/.git/index matches
